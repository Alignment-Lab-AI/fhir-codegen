// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinitionSlicing>))]
  public class ElementDefinitionSlicing : Element,  IFhirJsonSerializable {
    /// <summary>
    /// A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
    /// </summary>
    public List<string> Discriminator { get; set; }
    /// <summary>
    /// Extension container element for Discriminator
    /// </summary>
    public List<Element> _Discriminator { get; set; }
    /// <summary>
    /// If the matching elements have to occur in the same order as defined in the profile.
    /// </summary>
    public bool? Ordered { get; set; }
    /// <summary>
    /// Extension container element for Ordered
    /// </summary>
    public Element _Ordered { get; set; }
    /// <summary>
    /// Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    /// </summary>
    public string Rules { get; set; }
    /// <summary>
    /// Extension container element for Rules
    /// </summary>
    public Element _Rules { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if ((Discriminator != null) && (Discriminator.Count != 0))
      {
        writer.WritePropertyName("discriminator");
        writer.WriteStartArray();

        foreach (string valDiscriminator in Discriminator)
        {
          writer.WriteStringValue(valDiscriminator);
        }

        writer.WriteEndArray();
      }

      if ((_Discriminator != null) && (_Discriminator.Count != 0))
      {
        writer.WritePropertyName("_discriminator");
        writer.WriteStartArray();

        foreach (Element val_Discriminator in _Discriminator)
        {
          val_Discriminator.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (Ordered != null)
      {
        writer.WriteBoolean("ordered", (bool)Ordered!);
      }

      if (_Ordered != null)
      {
        writer.WritePropertyName("_ordered");
        _Ordered.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Rules))
      {
        writer.WriteString("rules", (string)Rules!);
      }

      if (_Rules != null)
      {
        writer.WritePropertyName("_rules");
        _Rules.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "discriminator":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Discriminator = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Discriminator.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Discriminator.Count == 0)
          {
            Discriminator = null;
          }

          break;

        case "_discriminator":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Discriminator = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Discriminator = new fhirCsR2.Models.Element();
            obj_Discriminator.DeserializeJson(ref reader, options);
            _Discriminator.Add(obj_Discriminator);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Discriminator.Count == 0)
          {
            _Discriminator = null;
          }

          break;

        case "ordered":
          Ordered = reader.GetBoolean();
          break;

        case "_ordered":
          _Ordered = new fhirCsR2.Models.Element();
          _Ordered.DeserializeJson(ref reader, options);
          break;

        case "rules":
          Rules = reader.GetString();
          break;

        case "_rules":
          _Rules = new fhirCsR2.Models.Element();
          _Rules.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.slicing.rules field
  /// </summary>
  public static class ElementDefinitionSlicingRulesCodes {
    public const string CLOSED = "closed";
    public const string OPEN = "open";
    public const string OPENATEND = "openAtEnd";
  }
  /// <summary>
  /// Information about the base definition of the element, provided to make it unncessary for tools to trace the deviation of the element through the derived and related profiles. This information is only provided where the element definition represents a constraint on another element definition, and must be present if there is a base element definition.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinitionBase>))]
  public class ElementDefinitionBase : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Maximum cardinality of the base element identified by the path.
    /// </summary>
    public string Max { get; set; }
    /// <summary>
    /// Extension container element for Max
    /// </summary>
    public Element _Max { get; set; }
    /// <summary>
    /// Minimum cardinality of the base element identified by the path.
    /// </summary>
    public int Min { get; set; }
    /// <summary>
    /// Extension container element for Min
    /// </summary>
    public Element _Min { get; set; }
    /// <summary>
    /// The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [[[StructureDefinition]]] without a StructureDefinition.base.
    /// </summary>
    public string Path { get; set; }
    /// <summary>
    /// Extension container element for Path
    /// </summary>
    public Element _Path { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Path))
      {
        writer.WriteString("path", (string)Path!);
      }

      if (_Path != null)
      {
        writer.WritePropertyName("_path");
        _Path.SerializeJson(writer, options);
      }

      writer.WriteNumber("min", Min);

      if (_Min != null)
      {
        writer.WritePropertyName("_min");
        _Min.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Max))
      {
        writer.WriteString("max", (string)Max!);
      }

      if (_Max != null)
      {
        writer.WritePropertyName("_max");
        _Max.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "max":
          Max = reader.GetString();
          break;

        case "_max":
          _Max = new fhirCsR2.Models.Element();
          _Max.DeserializeJson(ref reader, options);
          break;

        case "min":
          Min = reader.GetInt32();
          break;

        case "_min":
          _Min = new fhirCsR2.Models.Element();
          _Min.DeserializeJson(ref reader, options);
          break;

        case "path":
          Path = reader.GetString();
          break;

        case "_path":
          _Path = new fhirCsR2.Models.Element();
          _Path.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The data type or resource that the value of this element is permitted to be.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinitionType>))]
  public class ElementDefinitionType : Element,  IFhirJsonSerializable {
    /// <summary>
    /// If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
    /// </summary>
    public List<string> Aggregation { get; set; }
    /// <summary>
    /// Extension container element for Aggregation
    /// </summary>
    public List<Element> _Aggregation { get; set; }
    /// <summary>
    /// Name of Data type or Resource that is a(or the) type used for this element.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// Identifies a profile structure or implementation Guide that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile. When more than one profile is specified, the content must conform to all of them. When an implementation guide is specified, the resource SHALL conform to at least one profile defined in the implementation guide.
    /// </summary>
    public List<string> Profile { get; set; }
    /// <summary>
    /// Extension container element for Profile
    /// </summary>
    public List<Element> _Profile { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if ((Profile != null) && (Profile.Count != 0))
      {
        writer.WritePropertyName("profile");
        writer.WriteStartArray();

        foreach (string valProfile in Profile)
        {
          writer.WriteStringValue(valProfile);
        }

        writer.WriteEndArray();
      }

      if ((_Profile != null) && (_Profile.Count != 0))
      {
        writer.WritePropertyName("_profile");
        writer.WriteStartArray();

        foreach (Element val_Profile in _Profile)
        {
          val_Profile.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Aggregation != null) && (Aggregation.Count != 0))
      {
        writer.WritePropertyName("aggregation");
        writer.WriteStartArray();

        foreach (string valAggregation in Aggregation)
        {
          writer.WriteStringValue(valAggregation);
        }

        writer.WriteEndArray();
      }

      if ((_Aggregation != null) && (_Aggregation.Count != 0))
      {
        writer.WritePropertyName("_aggregation");
        writer.WriteStartArray();

        foreach (Element val_Aggregation in _Aggregation)
        {
          val_Aggregation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "aggregation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Aggregation = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Aggregation.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Aggregation.Count == 0)
          {
            Aggregation = null;
          }

          break;

        case "_aggregation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Aggregation = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Aggregation = new fhirCsR2.Models.Element();
            obj_Aggregation.DeserializeJson(ref reader, options);
            _Aggregation.Add(obj_Aggregation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Aggregation.Count == 0)
          {
            _Aggregation = null;
          }

          break;

        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR2.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "profile":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Profile = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Profile.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Profile.Count == 0)
          {
            Profile = null;
          }

          break;

        case "_profile":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Profile = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Profile = new fhirCsR2.Models.Element();
            obj_Profile.DeserializeJson(ref reader, options);
            _Profile.Add(obj_Profile);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Profile.Count == 0)
          {
            _Profile = null;
          }

          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.type.aggregation field
  /// </summary>
  public static class ElementDefinitionTypeAggregationCodes {
    public const string CONTAINED = "contained";
    public const string REFERENCED = "referenced";
    public const string BUNDLED = "bundled";
  }
  /// <summary>
  /// Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinitionConstraint>))]
  public class ElementDefinitionConstraint : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    /// </summary>
    public string Human { get; set; }
    /// <summary>
    /// Extension container element for Human
    /// </summary>
    public Element _Human { get; set; }
    /// <summary>
    /// Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    /// </summary>
    public string Key { get; set; }
    /// <summary>
    /// Extension container element for Key
    /// </summary>
    public Element _Key { get; set; }
    /// <summary>
    /// Description of why this constraint is necessary or appropriate.
    /// </summary>
    public string Requirements { get; set; }
    /// <summary>
    /// Extension container element for Requirements
    /// </summary>
    public Element _Requirements { get; set; }
    /// <summary>
    /// Identifies the impact constraint violation has on the conformance of the instance.
    /// </summary>
    public string Severity { get; set; }
    /// <summary>
    /// Extension container element for Severity
    /// </summary>
    public Element _Severity { get; set; }
    /// <summary>
    /// Used in Schematron tests of the validity of the resource.
    /// </summary>
    public string Xpath { get; set; }
    /// <summary>
    /// Extension container element for Xpath
    /// </summary>
    public Element _Xpath { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Key))
      {
        writer.WriteString("key", (string)Key!);
      }

      if (_Key != null)
      {
        writer.WritePropertyName("_key");
        _Key.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Requirements))
      {
        writer.WriteString("requirements", (string)Requirements!);
      }

      if (_Requirements != null)
      {
        writer.WritePropertyName("_requirements");
        _Requirements.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Severity))
      {
        writer.WriteString("severity", (string)Severity!);
      }

      if (_Severity != null)
      {
        writer.WritePropertyName("_severity");
        _Severity.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Human))
      {
        writer.WriteString("human", (string)Human!);
      }

      if (_Human != null)
      {
        writer.WritePropertyName("_human");
        _Human.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Xpath))
      {
        writer.WriteString("xpath", (string)Xpath!);
      }

      if (_Xpath != null)
      {
        writer.WritePropertyName("_xpath");
        _Xpath.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "human":
          Human = reader.GetString();
          break;

        case "_human":
          _Human = new fhirCsR2.Models.Element();
          _Human.DeserializeJson(ref reader, options);
          break;

        case "key":
          Key = reader.GetString();
          break;

        case "_key":
          _Key = new fhirCsR2.Models.Element();
          _Key.DeserializeJson(ref reader, options);
          break;

        case "requirements":
          Requirements = reader.GetString();
          break;

        case "_requirements":
          _Requirements = new fhirCsR2.Models.Element();
          _Requirements.DeserializeJson(ref reader, options);
          break;

        case "severity":
          Severity = reader.GetString();
          break;

        case "_severity":
          _Severity = new fhirCsR2.Models.Element();
          _Severity.DeserializeJson(ref reader, options);
          break;

        case "xpath":
          Xpath = reader.GetString();
          break;

        case "_xpath":
          _Xpath = new fhirCsR2.Models.Element();
          _Xpath.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.constraint.severity field
  /// </summary>
  public static class ElementDefinitionConstraintSeverityCodes {
    public const string ERROR = "error";
    public const string WARNING = "warning";
  }
  /// <summary>
  /// Binds to a value set if this element is coded (code, Coding, CodeableConcept).
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinitionBinding>))]
  public class ElementDefinitionBinding : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Describes the intended use of this particular set of codes.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
    /// </summary>
    public string Strength { get; set; }
    /// <summary>
    /// Extension container element for Strength
    /// </summary>
    public Element _Strength { get; set; }
    /// <summary>
    /// Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
    /// </summary>
    public string ValueSetUri { get; set; }
    /// <summary>
    /// Extension container element for ValueSetUri
    /// </summary>
    public Element _ValueSetUri { get; set; }
    /// <summary>
    /// Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
    /// </summary>
    public Reference ValueSetReference { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Strength))
      {
        writer.WriteString("strength", (string)Strength!);
      }

      if (_Strength != null)
      {
        writer.WritePropertyName("_strength");
        _Strength.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueSetUri))
      {
        writer.WriteString("valueSetUri", (string)ValueSetUri!);
      }

      if (_ValueSetUri != null)
      {
        writer.WritePropertyName("_valueSetUri");
        _ValueSetUri.SerializeJson(writer, options);
      }

      if (ValueSetReference != null)
      {
        writer.WritePropertyName("valueSetReference");
        ValueSetReference.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "strength":
          Strength = reader.GetString();
          break;

        case "_strength":
          _Strength = new fhirCsR2.Models.Element();
          _Strength.DeserializeJson(ref reader, options);
          break;

        case "valueSetUri":
          ValueSetUri = reader.GetString();
          break;

        case "_valueSetUri":
          _ValueSetUri = new fhirCsR2.Models.Element();
          _ValueSetUri.DeserializeJson(ref reader, options);
          break;

        case "valueSetReference":
          ValueSetReference = new fhirCsR2.Models.Reference();
          ValueSetReference.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.binding.strength field
  /// </summary>
  public static class ElementDefinitionBindingStrengthCodes {
    public const string REQUIRED = "required";
    public const string EXTENSIBLE = "extensible";
    public const string PREFERRED = "preferred";
    public const string EXAMPLE = "example";
  }
  /// <summary>
  /// Provides guidance to implementers familiar with or converting content from other specifications.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinitionMapping>))]
  public class ElementDefinitionMapping : Element,  IFhirJsonSerializable {
    /// <summary>
    /// An internal reference to the definition of a mapping.
    /// </summary>
    public string Identity { get; set; }
    /// <summary>
    /// Extension container element for Identity
    /// </summary>
    public Element _Identity { get; set; }
    /// <summary>
    /// Identifies the computable language in which mapping.map is expressed.
    /// </summary>
    public string Language { get; set; }
    /// <summary>
    /// Extension container element for Language
    /// </summary>
    public Element _Language { get; set; }
    /// <summary>
    /// Expresses what part of the target specification corresponds to this element.
    /// </summary>
    public string Map { get; set; }
    /// <summary>
    /// Extension container element for Map
    /// </summary>
    public Element _Map { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Identity))
      {
        writer.WriteString("identity", (string)Identity!);
      }

      if (_Identity != null)
      {
        writer.WritePropertyName("_identity");
        _Identity.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Language))
      {
        writer.WriteString("language", (string)Language!);
      }

      if (_Language != null)
      {
        writer.WritePropertyName("_language");
        _Language.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Map))
      {
        writer.WriteString("map", (string)Map!);
      }

      if (_Map != null)
      {
        writer.WritePropertyName("_map");
        _Map.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "identity":
          Identity = reader.GetString();
          break;

        case "_identity":
          _Identity = new fhirCsR2.Models.Element();
          _Identity.DeserializeJson(ref reader, options);
          break;

        case "language":
          Language = reader.GetString();
          break;

        case "_language":
          _Language = new fhirCsR2.Models.Element();
          _Language.DeserializeJson(ref reader, options);
          break;

        case "map":
          Map = reader.GetString();
          break;

        case "_map":
          _Map = new fhirCsR2.Models.Element();
          _Map.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Captures constraints on each element within the resource, profile, or extension.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ElementDefinition>))]
  public class ElementDefinition : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Allows for better easier recognition of the element by multiple communities, including international communities.
    /// </summary>
    public List<string> Alias { get; set; }
    /// <summary>
    /// Extension container element for Alias
    /// </summary>
    public List<Element> _Alias { get; set; }
    /// <summary>
    /// Information about the base definition of the element, provided to make it unncessary for tools to trace the deviation of the element through the derived and related profiles. This information is only provided where the element definition represents a constraint on another element definition, and must be present if there is a base element definition.
    /// </summary>
    public ElementDefinitionBase Base { get; set; }
    /// <summary>
    /// Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    /// </summary>
    public ElementDefinitionBinding Binding { get; set; }
    /// <summary>
    /// Links the meaning of an element to an external terminology.
    /// </summary>
    public List<Coding> Code { get; set; }
    /// <summary>
    /// Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc.
    /// </summary>
    public string Comments { get; set; }
    /// <summary>
    /// Extension container element for Comments
    /// </summary>
    public Element _Comments { get; set; }
    /// <summary>
    /// A reference to an invariant that may make additional statements about the cardinality or value in the instance.
    /// </summary>
    public List<string> Condition { get; set; }
    /// <summary>
    /// Extension container element for Condition
    /// </summary>
    public List<Element> _Condition { get; set; }
    /// <summary>
    /// Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    /// </summary>
    public List<ElementDefinitionConstraint> Constraint { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public bool? DefaultValueBoolean { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueBoolean
    /// </summary>
    public Element _DefaultValueBoolean { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public int? DefaultValueInteger { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueInteger
    /// </summary>
    public Element _DefaultValueInteger { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public decimal? DefaultValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueDecimal
    /// </summary>
    public Element _DefaultValueDecimal { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public byte[] DefaultValueBase64Binary { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueInstant { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueInstant
    /// </summary>
    public Element _DefaultValueInstant { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueString { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueString
    /// </summary>
    public Element _DefaultValueString { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueUri { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueUri
    /// </summary>
    public Element _DefaultValueUri { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueDate { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueDate
    /// </summary>
    public Element _DefaultValueDate { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueDateTime
    /// </summary>
    public Element _DefaultValueDateTime { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueTime { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueTime
    /// </summary>
    public Element _DefaultValueTime { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueCode { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueCode
    /// </summary>
    public Element _DefaultValueCode { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueOid { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueOid
    /// </summary>
    public Element _DefaultValueOid { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueId { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueId
    /// </summary>
    public Element _DefaultValueId { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public uint? DefaultValueUnsignedInt { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public uint? DefaultValuePositiveInt { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public string DefaultValueMarkdown { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueMarkdown
    /// </summary>
    public Element _DefaultValueMarkdown { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Annotation DefaultValueAnnotation { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Attachment DefaultValueAttachment { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Identifier DefaultValueIdentifier { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public CodeableConcept DefaultValueCodeableConcept { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Coding DefaultValueCoding { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Quantity DefaultValueQuantity { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Range DefaultValueRange { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Period DefaultValuePeriod { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Ratio DefaultValueRatio { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public SampledData DefaultValueSampledData { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Signature DefaultValueSignature { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public HumanName DefaultValueHumanName { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Address DefaultValueAddress { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public ContactPoint DefaultValueContactPoint { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Timing DefaultValueTiming { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Reference DefaultValueReference { get; set; }
    /// <summary>
    /// The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    /// </summary>
    public Meta DefaultValueMeta { get; set; }
    /// <summary>
    /// To allow a user to state the usage of an element in a particular context.
    /// </summary>
    public string Definition { get; set; }
    /// <summary>
    /// Extension container element for Definition
    /// </summary>
    public Element _Definition { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public bool? ExampleBoolean { get; set; }
    /// <summary>
    /// Extension container element for ExampleBoolean
    /// </summary>
    public Element _ExampleBoolean { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public int? ExampleInteger { get; set; }
    /// <summary>
    /// Extension container element for ExampleInteger
    /// </summary>
    public Element _ExampleInteger { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public decimal? ExampleDecimal { get; set; }
    /// <summary>
    /// Extension container element for ExampleDecimal
    /// </summary>
    public Element _ExampleDecimal { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public byte[] ExampleBase64Binary { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleInstant { get; set; }
    /// <summary>
    /// Extension container element for ExampleInstant
    /// </summary>
    public Element _ExampleInstant { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleString { get; set; }
    /// <summary>
    /// Extension container element for ExampleString
    /// </summary>
    public Element _ExampleString { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleUri { get; set; }
    /// <summary>
    /// Extension container element for ExampleUri
    /// </summary>
    public Element _ExampleUri { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleDate { get; set; }
    /// <summary>
    /// Extension container element for ExampleDate
    /// </summary>
    public Element _ExampleDate { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleDateTime { get; set; }
    /// <summary>
    /// Extension container element for ExampleDateTime
    /// </summary>
    public Element _ExampleDateTime { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleTime { get; set; }
    /// <summary>
    /// Extension container element for ExampleTime
    /// </summary>
    public Element _ExampleTime { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleCode { get; set; }
    /// <summary>
    /// Extension container element for ExampleCode
    /// </summary>
    public Element _ExampleCode { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleOid { get; set; }
    /// <summary>
    /// Extension container element for ExampleOid
    /// </summary>
    public Element _ExampleOid { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleId { get; set; }
    /// <summary>
    /// Extension container element for ExampleId
    /// </summary>
    public Element _ExampleId { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public uint? ExampleUnsignedInt { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public uint? ExamplePositiveInt { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public string ExampleMarkdown { get; set; }
    /// <summary>
    /// Extension container element for ExampleMarkdown
    /// </summary>
    public Element _ExampleMarkdown { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Annotation ExampleAnnotation { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Attachment ExampleAttachment { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Identifier ExampleIdentifier { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public CodeableConcept ExampleCodeableConcept { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Coding ExampleCoding { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Quantity ExampleQuantity { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Range ExampleRange { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Period ExamplePeriod { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Ratio ExampleRatio { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public SampledData ExampleSampledData { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Signature ExampleSignature { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public HumanName ExampleHumanName { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Address ExampleAddress { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public ContactPoint ExampleContactPoint { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Timing ExampleTiming { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Reference ExampleReference { get; set; }
    /// <summary>
    /// A sample value for this element demonstrating the type of information that would typically be captured.
    /// </summary>
    public Meta ExampleMeta { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public bool? FixedBoolean { get; set; }
    /// <summary>
    /// Extension container element for FixedBoolean
    /// </summary>
    public Element _FixedBoolean { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public int? FixedInteger { get; set; }
    /// <summary>
    /// Extension container element for FixedInteger
    /// </summary>
    public Element _FixedInteger { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public decimal? FixedDecimal { get; set; }
    /// <summary>
    /// Extension container element for FixedDecimal
    /// </summary>
    public Element _FixedDecimal { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public byte[] FixedBase64Binary { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedInstant { get; set; }
    /// <summary>
    /// Extension container element for FixedInstant
    /// </summary>
    public Element _FixedInstant { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedString { get; set; }
    /// <summary>
    /// Extension container element for FixedString
    /// </summary>
    public Element _FixedString { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedUri { get; set; }
    /// <summary>
    /// Extension container element for FixedUri
    /// </summary>
    public Element _FixedUri { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedDate { get; set; }
    /// <summary>
    /// Extension container element for FixedDate
    /// </summary>
    public Element _FixedDate { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedDateTime { get; set; }
    /// <summary>
    /// Extension container element for FixedDateTime
    /// </summary>
    public Element _FixedDateTime { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedTime { get; set; }
    /// <summary>
    /// Extension container element for FixedTime
    /// </summary>
    public Element _FixedTime { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedCode { get; set; }
    /// <summary>
    /// Extension container element for FixedCode
    /// </summary>
    public Element _FixedCode { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedOid { get; set; }
    /// <summary>
    /// Extension container element for FixedOid
    /// </summary>
    public Element _FixedOid { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedId { get; set; }
    /// <summary>
    /// Extension container element for FixedId
    /// </summary>
    public Element _FixedId { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public uint? FixedUnsignedInt { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public uint? FixedPositiveInt { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public string FixedMarkdown { get; set; }
    /// <summary>
    /// Extension container element for FixedMarkdown
    /// </summary>
    public Element _FixedMarkdown { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Annotation FixedAnnotation { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Attachment FixedAttachment { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Identifier FixedIdentifier { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public CodeableConcept FixedCodeableConcept { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Coding FixedCoding { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Quantity FixedQuantity { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Range FixedRange { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Period FixedPeriod { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Ratio FixedRatio { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public SampledData FixedSampledData { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Signature FixedSignature { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public HumanName FixedHumanName { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Address FixedAddress { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public ContactPoint FixedContactPoint { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Timing FixedTiming { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Reference FixedReference { get; set; }
    /// <summary>
    /// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    /// </summary>
    public Meta FixedMeta { get; set; }
    /// <summary>
    /// Allows elements to be introduced into a specification that can't safely be ignored by applications that don't recognize them.
    /// </summary>
    public bool? IsModifier { get; set; }
    /// <summary>
    /// Extension container element for IsModifier
    /// </summary>
    public Element _IsModifier { get; set; }
    /// <summary>
    /// Allow clients to search through large resources quickly.
    /// </summary>
    public bool? IsSummary { get; set; }
    /// <summary>
    /// Extension container element for IsSummary
    /// </summary>
    public Element _IsSummary { get; set; }
    /// <summary>
    /// The text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
    /// </summary>
    public string Label { get; set; }
    /// <summary>
    /// Extension container element for Label
    /// </summary>
    public Element _Label { get; set; }
    /// <summary>
    /// Provides guidance to implementers familiar with or converting content from other specifications.
    /// </summary>
    public List<ElementDefinitionMapping> Mapping { get; set; }
    /// <summary>
    /// The maximum number of times this element is permitted to appear in the instance.
    /// </summary>
    public string Max { get; set; }
    /// <summary>
    /// Extension container element for Max
    /// </summary>
    public Element _Max { get; set; }
    /// <summary>
    /// Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
    /// </summary>
    public int? MaxLength { get; set; }
    /// <summary>
    /// Extension container element for MaxLength
    /// </summary>
    public Element _MaxLength { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public bool? MaxValueBoolean { get; set; }
    /// <summary>
    /// Extension container element for MaxValueBoolean
    /// </summary>
    public Element _MaxValueBoolean { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public int? MaxValueInteger { get; set; }
    /// <summary>
    /// Extension container element for MaxValueInteger
    /// </summary>
    public Element _MaxValueInteger { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public decimal? MaxValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for MaxValueDecimal
    /// </summary>
    public Element _MaxValueDecimal { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public byte[] MaxValueBase64Binary { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueInstant { get; set; }
    /// <summary>
    /// Extension container element for MaxValueInstant
    /// </summary>
    public Element _MaxValueInstant { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueString { get; set; }
    /// <summary>
    /// Extension container element for MaxValueString
    /// </summary>
    public Element _MaxValueString { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueUri { get; set; }
    /// <summary>
    /// Extension container element for MaxValueUri
    /// </summary>
    public Element _MaxValueUri { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueDate { get; set; }
    /// <summary>
    /// Extension container element for MaxValueDate
    /// </summary>
    public Element _MaxValueDate { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for MaxValueDateTime
    /// </summary>
    public Element _MaxValueDateTime { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueTime { get; set; }
    /// <summary>
    /// Extension container element for MaxValueTime
    /// </summary>
    public Element _MaxValueTime { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueCode { get; set; }
    /// <summary>
    /// Extension container element for MaxValueCode
    /// </summary>
    public Element _MaxValueCode { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueOid { get; set; }
    /// <summary>
    /// Extension container element for MaxValueOid
    /// </summary>
    public Element _MaxValueOid { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueId { get; set; }
    /// <summary>
    /// Extension container element for MaxValueId
    /// </summary>
    public Element _MaxValueId { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public uint? MaxValueUnsignedInt { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public uint? MaxValuePositiveInt { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MaxValueMarkdown { get; set; }
    /// <summary>
    /// Extension container element for MaxValueMarkdown
    /// </summary>
    public Element _MaxValueMarkdown { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Annotation MaxValueAnnotation { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Attachment MaxValueAttachment { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Identifier MaxValueIdentifier { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public CodeableConcept MaxValueCodeableConcept { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Coding MaxValueCoding { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Quantity MaxValueQuantity { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Range MaxValueRange { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Period MaxValuePeriod { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Ratio MaxValueRatio { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public SampledData MaxValueSampledData { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Signature MaxValueSignature { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public HumanName MaxValueHumanName { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Address MaxValueAddress { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public ContactPoint MaxValueContactPoint { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Timing MaxValueTiming { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Reference MaxValueReference { get; set; }
    /// <summary>
    /// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Meta MaxValueMeta { get; set; }
    /// <summary>
    /// The Implicit meaning that is to be understood when this element is missing (e.g. 'when this element is missing, the period is ongoing'.
    /// </summary>
    public string MeaningWhenMissing { get; set; }
    /// <summary>
    /// Extension container element for MeaningWhenMissing
    /// </summary>
    public Element _MeaningWhenMissing { get; set; }
    /// <summary>
    /// The minimum number of times this element SHALL appear in the instance.
    /// </summary>
    public int? Min { get; set; }
    /// <summary>
    /// Extension container element for Min
    /// </summary>
    public Element _Min { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public bool? MinValueBoolean { get; set; }
    /// <summary>
    /// Extension container element for MinValueBoolean
    /// </summary>
    public Element _MinValueBoolean { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public int? MinValueInteger { get; set; }
    /// <summary>
    /// Extension container element for MinValueInteger
    /// </summary>
    public Element _MinValueInteger { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public decimal? MinValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for MinValueDecimal
    /// </summary>
    public Element _MinValueDecimal { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public byte[] MinValueBase64Binary { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueInstant { get; set; }
    /// <summary>
    /// Extension container element for MinValueInstant
    /// </summary>
    public Element _MinValueInstant { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueString { get; set; }
    /// <summary>
    /// Extension container element for MinValueString
    /// </summary>
    public Element _MinValueString { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueUri { get; set; }
    /// <summary>
    /// Extension container element for MinValueUri
    /// </summary>
    public Element _MinValueUri { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueDate { get; set; }
    /// <summary>
    /// Extension container element for MinValueDate
    /// </summary>
    public Element _MinValueDate { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for MinValueDateTime
    /// </summary>
    public Element _MinValueDateTime { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueTime { get; set; }
    /// <summary>
    /// Extension container element for MinValueTime
    /// </summary>
    public Element _MinValueTime { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueCode { get; set; }
    /// <summary>
    /// Extension container element for MinValueCode
    /// </summary>
    public Element _MinValueCode { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueOid { get; set; }
    /// <summary>
    /// Extension container element for MinValueOid
    /// </summary>
    public Element _MinValueOid { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueId { get; set; }
    /// <summary>
    /// Extension container element for MinValueId
    /// </summary>
    public Element _MinValueId { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public uint? MinValueUnsignedInt { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public uint? MinValuePositiveInt { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public string MinValueMarkdown { get; set; }
    /// <summary>
    /// Extension container element for MinValueMarkdown
    /// </summary>
    public Element _MinValueMarkdown { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Annotation MinValueAnnotation { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Attachment MinValueAttachment { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Identifier MinValueIdentifier { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public CodeableConcept MinValueCodeableConcept { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Coding MinValueCoding { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Quantity MinValueQuantity { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Range MinValueRange { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Period MinValuePeriod { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Ratio MinValueRatio { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public SampledData MinValueSampledData { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Signature MinValueSignature { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public HumanName MinValueHumanName { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Address MinValueAddress { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public ContactPoint MinValueContactPoint { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Timing MinValueTiming { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Reference MinValueReference { get; set; }
    /// <summary>
    /// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    /// </summary>
    public Meta MinValueMeta { get; set; }
    /// <summary>
    /// Allows a profile to set expectations for system capabilities beyond merely respecting cardinality constraints.
    /// </summary>
    public bool? MustSupport { get; set; }
    /// <summary>
    /// Extension container element for MustSupport
    /// </summary>
    public Element _MustSupport { get; set; }
    /// <summary>
    /// Allows referencing a defined element.  May also be used for code generation purposes.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    /// </summary>
    public string NameReference { get; set; }
    /// <summary>
    /// Extension container element for NameReference
    /// </summary>
    public Element _NameReference { get; set; }
    /// <summary>
    /// The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
    /// </summary>
    public string Path { get; set; }
    /// <summary>
    /// Extension container element for Path
    /// </summary>
    public Element _Path { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public bool? PatternBoolean { get; set; }
    /// <summary>
    /// Extension container element for PatternBoolean
    /// </summary>
    public Element _PatternBoolean { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public int? PatternInteger { get; set; }
    /// <summary>
    /// Extension container element for PatternInteger
    /// </summary>
    public Element _PatternInteger { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public decimal? PatternDecimal { get; set; }
    /// <summary>
    /// Extension container element for PatternDecimal
    /// </summary>
    public Element _PatternDecimal { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public byte[] PatternBase64Binary { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternInstant { get; set; }
    /// <summary>
    /// Extension container element for PatternInstant
    /// </summary>
    public Element _PatternInstant { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternString { get; set; }
    /// <summary>
    /// Extension container element for PatternString
    /// </summary>
    public Element _PatternString { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternUri { get; set; }
    /// <summary>
    /// Extension container element for PatternUri
    /// </summary>
    public Element _PatternUri { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternDate { get; set; }
    /// <summary>
    /// Extension container element for PatternDate
    /// </summary>
    public Element _PatternDate { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternDateTime { get; set; }
    /// <summary>
    /// Extension container element for PatternDateTime
    /// </summary>
    public Element _PatternDateTime { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternTime { get; set; }
    /// <summary>
    /// Extension container element for PatternTime
    /// </summary>
    public Element _PatternTime { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternCode { get; set; }
    /// <summary>
    /// Extension container element for PatternCode
    /// </summary>
    public Element _PatternCode { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternOid { get; set; }
    /// <summary>
    /// Extension container element for PatternOid
    /// </summary>
    public Element _PatternOid { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternId { get; set; }
    /// <summary>
    /// Extension container element for PatternId
    /// </summary>
    public Element _PatternId { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public uint? PatternUnsignedInt { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public uint? PatternPositiveInt { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public string PatternMarkdown { get; set; }
    /// <summary>
    /// Extension container element for PatternMarkdown
    /// </summary>
    public Element _PatternMarkdown { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Annotation PatternAnnotation { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Attachment PatternAttachment { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Identifier PatternIdentifier { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public CodeableConcept PatternCodeableConcept { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Coding PatternCoding { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Quantity PatternQuantity { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Range PatternRange { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Period PatternPeriod { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Ratio PatternRatio { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public SampledData PatternSampledData { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Signature PatternSignature { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public HumanName PatternHumanName { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Address PatternAddress { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public ContactPoint PatternContactPoint { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Timing PatternTiming { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Reference PatternReference { get; set; }
    /// <summary>
    /// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
    /// </summary>
    public Meta PatternMeta { get; set; }
    /// <summary>
    /// Codes that define how this element is represented in instances, when the deviation varies from the normal case.
    /// </summary>
    public List<string> Representation { get; set; }
    /// <summary>
    /// Extension container element for Representation
    /// </summary>
    public List<Element> _Representation { get; set; }
    /// <summary>
    /// This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
    /// </summary>
    public string Requirements { get; set; }
    /// <summary>
    /// Extension container element for Requirements
    /// </summary>
    public Element _Requirements { get; set; }
    /// <summary>
    /// A concise description of what this element means (e.g. for use in autogenerated summaries).
    /// </summary>
    public string Short { get; set; }
    /// <summary>
    /// Extension container element for Short
    /// </summary>
    public Element _Short { get; set; }
    /// <summary>
    /// Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    /// </summary>
    public ElementDefinitionSlicing Slicing { get; set; }
    /// <summary>
    /// The data type or resource that the value of this element is permitted to be.
    /// </summary>
    public List<ElementDefinitionType> Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Path))
      {
        writer.WriteString("path", (string)Path!);
      }

      if (_Path != null)
      {
        writer.WritePropertyName("_path");
        _Path.SerializeJson(writer, options);
      }

      if ((Representation != null) && (Representation.Count != 0))
      {
        writer.WritePropertyName("representation");
        writer.WriteStartArray();

        foreach (string valRepresentation in Representation)
        {
          writer.WriteStringValue(valRepresentation);
        }

        writer.WriteEndArray();
      }

      if ((_Representation != null) && (_Representation.Count != 0))
      {
        writer.WritePropertyName("_representation");
        writer.WriteStartArray();

        foreach (Element val_Representation in _Representation)
        {
          val_Representation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Label))
      {
        writer.WriteString("label", (string)Label!);
      }

      if (_Label != null)
      {
        writer.WritePropertyName("_label");
        _Label.SerializeJson(writer, options);
      }

      if ((Code != null) && (Code.Count != 0))
      {
        writer.WritePropertyName("code");
        writer.WriteStartArray();

        foreach (Coding valCode in Code)
        {
          valCode.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Slicing != null)
      {
        writer.WritePropertyName("slicing");
        Slicing.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Short))
      {
        writer.WriteString("short", (string)Short!);
      }

      if (_Short != null)
      {
        writer.WritePropertyName("_short");
        _Short.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Definition))
      {
        writer.WriteString("definition", (string)Definition!);
      }

      if (_Definition != null)
      {
        writer.WritePropertyName("_definition");
        _Definition.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comments))
      {
        writer.WriteString("comments", (string)Comments!);
      }

      if (_Comments != null)
      {
        writer.WritePropertyName("_comments");
        _Comments.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Requirements))
      {
        writer.WriteString("requirements", (string)Requirements!);
      }

      if (_Requirements != null)
      {
        writer.WritePropertyName("_requirements");
        _Requirements.SerializeJson(writer, options);
      }

      if ((Alias != null) && (Alias.Count != 0))
      {
        writer.WritePropertyName("alias");
        writer.WriteStartArray();

        foreach (string valAlias in Alias)
        {
          writer.WriteStringValue(valAlias);
        }

        writer.WriteEndArray();
      }

      if ((_Alias != null) && (_Alias.Count != 0))
      {
        writer.WritePropertyName("_alias");
        writer.WriteStartArray();

        foreach (Element val_Alias in _Alias)
        {
          val_Alias.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Min != null)
      {
        writer.WriteNumber("min", (int)Min!);
      }

      if (_Min != null)
      {
        writer.WritePropertyName("_min");
        _Min.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Max))
      {
        writer.WriteString("max", (string)Max!);
      }

      if (_Max != null)
      {
        writer.WritePropertyName("_max");
        _Max.SerializeJson(writer, options);
      }

      if (Base != null)
      {
        writer.WritePropertyName("base");
        Base.SerializeJson(writer, options);
      }

      if ((Type != null) && (Type.Count != 0))
      {
        writer.WritePropertyName("type");
        writer.WriteStartArray();

        foreach (ElementDefinitionType valType in Type)
        {
          valType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(NameReference))
      {
        writer.WriteString("nameReference", (string)NameReference!);
      }

      if (_NameReference != null)
      {
        writer.WritePropertyName("_nameReference");
        _NameReference.SerializeJson(writer, options);
      }

      if (DefaultValueBoolean != null)
      {
        writer.WriteBoolean("defaultValueBoolean", (bool)DefaultValueBoolean!);
      }

      if (_DefaultValueBoolean != null)
      {
        writer.WritePropertyName("_defaultValueBoolean");
        _DefaultValueBoolean.SerializeJson(writer, options);
      }

      if (DefaultValueInteger != null)
      {
        writer.WriteNumber("defaultValueInteger", (int)DefaultValueInteger!);
      }

      if (_DefaultValueInteger != null)
      {
        writer.WritePropertyName("_defaultValueInteger");
        _DefaultValueInteger.SerializeJson(writer, options);
      }

      if (DefaultValueDecimal != null)
      {
        writer.WriteNumber("defaultValueDecimal", (decimal)DefaultValueDecimal!);
      }

      if (_DefaultValueDecimal != null)
      {
        writer.WritePropertyName("_defaultValueDecimal");
        _DefaultValueDecimal.SerializeJson(writer, options);
      }

      if (DefaultValueBase64Binary != null)
      {
        writer.WriteString("defaultValueBase64Binary", System.Convert.ToBase64String(DefaultValueBase64Binary));
      }

      if (!string.IsNullOrEmpty(DefaultValueInstant))
      {
        writer.WriteString("defaultValueInstant", (string)DefaultValueInstant!);
      }

      if (_DefaultValueInstant != null)
      {
        writer.WritePropertyName("_defaultValueInstant");
        _DefaultValueInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueString))
      {
        writer.WriteString("defaultValueString", (string)DefaultValueString!);
      }

      if (_DefaultValueString != null)
      {
        writer.WritePropertyName("_defaultValueString");
        _DefaultValueString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueUri))
      {
        writer.WriteString("defaultValueUri", (string)DefaultValueUri!);
      }

      if (_DefaultValueUri != null)
      {
        writer.WritePropertyName("_defaultValueUri");
        _DefaultValueUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueDate))
      {
        writer.WriteString("defaultValueDate", (string)DefaultValueDate!);
      }

      if (_DefaultValueDate != null)
      {
        writer.WritePropertyName("_defaultValueDate");
        _DefaultValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueDateTime))
      {
        writer.WriteString("defaultValueDateTime", (string)DefaultValueDateTime!);
      }

      if (_DefaultValueDateTime != null)
      {
        writer.WritePropertyName("_defaultValueDateTime");
        _DefaultValueDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueTime))
      {
        writer.WriteString("defaultValueTime", (string)DefaultValueTime!);
      }

      if (_DefaultValueTime != null)
      {
        writer.WritePropertyName("_defaultValueTime");
        _DefaultValueTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueCode))
      {
        writer.WriteString("defaultValueCode", (string)DefaultValueCode!);
      }

      if (_DefaultValueCode != null)
      {
        writer.WritePropertyName("_defaultValueCode");
        _DefaultValueCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueOid))
      {
        writer.WriteString("defaultValueOid", (string)DefaultValueOid!);
      }

      if (_DefaultValueOid != null)
      {
        writer.WritePropertyName("_defaultValueOid");
        _DefaultValueOid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueId))
      {
        writer.WriteString("defaultValueId", (string)DefaultValueId!);
      }

      if (_DefaultValueId != null)
      {
        writer.WritePropertyName("_defaultValueId");
        _DefaultValueId.SerializeJson(writer, options);
      }

      if (DefaultValueUnsignedInt != null)
      {
        writer.WriteNumber("defaultValueUnsignedInt", (uint)DefaultValueUnsignedInt!);
      }

      if (DefaultValuePositiveInt != null)
      {
        writer.WriteNumber("defaultValuePositiveInt", (uint)DefaultValuePositiveInt!);
      }

      if (!string.IsNullOrEmpty(DefaultValueMarkdown))
      {
        writer.WriteString("defaultValueMarkdown", (string)DefaultValueMarkdown!);
      }

      if (_DefaultValueMarkdown != null)
      {
        writer.WritePropertyName("_defaultValueMarkdown");
        _DefaultValueMarkdown.SerializeJson(writer, options);
      }

      if (DefaultValueAnnotation != null)
      {
        writer.WritePropertyName("defaultValueAnnotation");
        DefaultValueAnnotation.SerializeJson(writer, options);
      }

      if (DefaultValueAttachment != null)
      {
        writer.WritePropertyName("defaultValueAttachment");
        DefaultValueAttachment.SerializeJson(writer, options);
      }

      if (DefaultValueIdentifier != null)
      {
        writer.WritePropertyName("defaultValueIdentifier");
        DefaultValueIdentifier.SerializeJson(writer, options);
      }

      if (DefaultValueCodeableConcept != null)
      {
        writer.WritePropertyName("defaultValueCodeableConcept");
        DefaultValueCodeableConcept.SerializeJson(writer, options);
      }

      if (DefaultValueCoding != null)
      {
        writer.WritePropertyName("defaultValueCoding");
        DefaultValueCoding.SerializeJson(writer, options);
      }

      if (DefaultValueQuantity != null)
      {
        writer.WritePropertyName("defaultValueQuantity");
        DefaultValueQuantity.SerializeJson(writer, options);
      }

      if (DefaultValueRange != null)
      {
        writer.WritePropertyName("defaultValueRange");
        DefaultValueRange.SerializeJson(writer, options);
      }

      if (DefaultValuePeriod != null)
      {
        writer.WritePropertyName("defaultValuePeriod");
        DefaultValuePeriod.SerializeJson(writer, options);
      }

      if (DefaultValueRatio != null)
      {
        writer.WritePropertyName("defaultValueRatio");
        DefaultValueRatio.SerializeJson(writer, options);
      }

      if (DefaultValueSampledData != null)
      {
        writer.WritePropertyName("defaultValueSampledData");
        DefaultValueSampledData.SerializeJson(writer, options);
      }

      if (DefaultValueSignature != null)
      {
        writer.WritePropertyName("defaultValueSignature");
        DefaultValueSignature.SerializeJson(writer, options);
      }

      if (DefaultValueHumanName != null)
      {
        writer.WritePropertyName("defaultValueHumanName");
        DefaultValueHumanName.SerializeJson(writer, options);
      }

      if (DefaultValueAddress != null)
      {
        writer.WritePropertyName("defaultValueAddress");
        DefaultValueAddress.SerializeJson(writer, options);
      }

      if (DefaultValueContactPoint != null)
      {
        writer.WritePropertyName("defaultValueContactPoint");
        DefaultValueContactPoint.SerializeJson(writer, options);
      }

      if (DefaultValueTiming != null)
      {
        writer.WritePropertyName("defaultValueTiming");
        DefaultValueTiming.SerializeJson(writer, options);
      }

      if (DefaultValueReference != null)
      {
        writer.WritePropertyName("defaultValueReference");
        DefaultValueReference.SerializeJson(writer, options);
      }

      if (DefaultValueMeta != null)
      {
        writer.WritePropertyName("defaultValueMeta");
        DefaultValueMeta.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MeaningWhenMissing))
      {
        writer.WriteString("meaningWhenMissing", (string)MeaningWhenMissing!);
      }

      if (_MeaningWhenMissing != null)
      {
        writer.WritePropertyName("_meaningWhenMissing");
        _MeaningWhenMissing.SerializeJson(writer, options);
      }

      if (FixedBoolean != null)
      {
        writer.WriteBoolean("fixedBoolean", (bool)FixedBoolean!);
      }

      if (_FixedBoolean != null)
      {
        writer.WritePropertyName("_fixedBoolean");
        _FixedBoolean.SerializeJson(writer, options);
      }

      if (FixedInteger != null)
      {
        writer.WriteNumber("fixedInteger", (int)FixedInteger!);
      }

      if (_FixedInteger != null)
      {
        writer.WritePropertyName("_fixedInteger");
        _FixedInteger.SerializeJson(writer, options);
      }

      if (FixedDecimal != null)
      {
        writer.WriteNumber("fixedDecimal", (decimal)FixedDecimal!);
      }

      if (_FixedDecimal != null)
      {
        writer.WritePropertyName("_fixedDecimal");
        _FixedDecimal.SerializeJson(writer, options);
      }

      if (FixedBase64Binary != null)
      {
        writer.WriteString("fixedBase64Binary", System.Convert.ToBase64String(FixedBase64Binary));
      }

      if (!string.IsNullOrEmpty(FixedInstant))
      {
        writer.WriteString("fixedInstant", (string)FixedInstant!);
      }

      if (_FixedInstant != null)
      {
        writer.WritePropertyName("_fixedInstant");
        _FixedInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedString))
      {
        writer.WriteString("fixedString", (string)FixedString!);
      }

      if (_FixedString != null)
      {
        writer.WritePropertyName("_fixedString");
        _FixedString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedUri))
      {
        writer.WriteString("fixedUri", (string)FixedUri!);
      }

      if (_FixedUri != null)
      {
        writer.WritePropertyName("_fixedUri");
        _FixedUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedDate))
      {
        writer.WriteString("fixedDate", (string)FixedDate!);
      }

      if (_FixedDate != null)
      {
        writer.WritePropertyName("_fixedDate");
        _FixedDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedDateTime))
      {
        writer.WriteString("fixedDateTime", (string)FixedDateTime!);
      }

      if (_FixedDateTime != null)
      {
        writer.WritePropertyName("_fixedDateTime");
        _FixedDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedTime))
      {
        writer.WriteString("fixedTime", (string)FixedTime!);
      }

      if (_FixedTime != null)
      {
        writer.WritePropertyName("_fixedTime");
        _FixedTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedCode))
      {
        writer.WriteString("fixedCode", (string)FixedCode!);
      }

      if (_FixedCode != null)
      {
        writer.WritePropertyName("_fixedCode");
        _FixedCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedOid))
      {
        writer.WriteString("fixedOid", (string)FixedOid!);
      }

      if (_FixedOid != null)
      {
        writer.WritePropertyName("_fixedOid");
        _FixedOid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedId))
      {
        writer.WriteString("fixedId", (string)FixedId!);
      }

      if (_FixedId != null)
      {
        writer.WritePropertyName("_fixedId");
        _FixedId.SerializeJson(writer, options);
      }

      if (FixedUnsignedInt != null)
      {
        writer.WriteNumber("fixedUnsignedInt", (uint)FixedUnsignedInt!);
      }

      if (FixedPositiveInt != null)
      {
        writer.WriteNumber("fixedPositiveInt", (uint)FixedPositiveInt!);
      }

      if (!string.IsNullOrEmpty(FixedMarkdown))
      {
        writer.WriteString("fixedMarkdown", (string)FixedMarkdown!);
      }

      if (_FixedMarkdown != null)
      {
        writer.WritePropertyName("_fixedMarkdown");
        _FixedMarkdown.SerializeJson(writer, options);
      }

      if (FixedAnnotation != null)
      {
        writer.WritePropertyName("fixedAnnotation");
        FixedAnnotation.SerializeJson(writer, options);
      }

      if (FixedAttachment != null)
      {
        writer.WritePropertyName("fixedAttachment");
        FixedAttachment.SerializeJson(writer, options);
      }

      if (FixedIdentifier != null)
      {
        writer.WritePropertyName("fixedIdentifier");
        FixedIdentifier.SerializeJson(writer, options);
      }

      if (FixedCodeableConcept != null)
      {
        writer.WritePropertyName("fixedCodeableConcept");
        FixedCodeableConcept.SerializeJson(writer, options);
      }

      if (FixedCoding != null)
      {
        writer.WritePropertyName("fixedCoding");
        FixedCoding.SerializeJson(writer, options);
      }

      if (FixedQuantity != null)
      {
        writer.WritePropertyName("fixedQuantity");
        FixedQuantity.SerializeJson(writer, options);
      }

      if (FixedRange != null)
      {
        writer.WritePropertyName("fixedRange");
        FixedRange.SerializeJson(writer, options);
      }

      if (FixedPeriod != null)
      {
        writer.WritePropertyName("fixedPeriod");
        FixedPeriod.SerializeJson(writer, options);
      }

      if (FixedRatio != null)
      {
        writer.WritePropertyName("fixedRatio");
        FixedRatio.SerializeJson(writer, options);
      }

      if (FixedSampledData != null)
      {
        writer.WritePropertyName("fixedSampledData");
        FixedSampledData.SerializeJson(writer, options);
      }

      if (FixedSignature != null)
      {
        writer.WritePropertyName("fixedSignature");
        FixedSignature.SerializeJson(writer, options);
      }

      if (FixedHumanName != null)
      {
        writer.WritePropertyName("fixedHumanName");
        FixedHumanName.SerializeJson(writer, options);
      }

      if (FixedAddress != null)
      {
        writer.WritePropertyName("fixedAddress");
        FixedAddress.SerializeJson(writer, options);
      }

      if (FixedContactPoint != null)
      {
        writer.WritePropertyName("fixedContactPoint");
        FixedContactPoint.SerializeJson(writer, options);
      }

      if (FixedTiming != null)
      {
        writer.WritePropertyName("fixedTiming");
        FixedTiming.SerializeJson(writer, options);
      }

      if (FixedReference != null)
      {
        writer.WritePropertyName("fixedReference");
        FixedReference.SerializeJson(writer, options);
      }

      if (FixedMeta != null)
      {
        writer.WritePropertyName("fixedMeta");
        FixedMeta.SerializeJson(writer, options);
      }

      if (PatternBoolean != null)
      {
        writer.WriteBoolean("patternBoolean", (bool)PatternBoolean!);
      }

      if (_PatternBoolean != null)
      {
        writer.WritePropertyName("_patternBoolean");
        _PatternBoolean.SerializeJson(writer, options);
      }

      if (PatternInteger != null)
      {
        writer.WriteNumber("patternInteger", (int)PatternInteger!);
      }

      if (_PatternInteger != null)
      {
        writer.WritePropertyName("_patternInteger");
        _PatternInteger.SerializeJson(writer, options);
      }

      if (PatternDecimal != null)
      {
        writer.WriteNumber("patternDecimal", (decimal)PatternDecimal!);
      }

      if (_PatternDecimal != null)
      {
        writer.WritePropertyName("_patternDecimal");
        _PatternDecimal.SerializeJson(writer, options);
      }

      if (PatternBase64Binary != null)
      {
        writer.WriteString("patternBase64Binary", System.Convert.ToBase64String(PatternBase64Binary));
      }

      if (!string.IsNullOrEmpty(PatternInstant))
      {
        writer.WriteString("patternInstant", (string)PatternInstant!);
      }

      if (_PatternInstant != null)
      {
        writer.WritePropertyName("_patternInstant");
        _PatternInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternString))
      {
        writer.WriteString("patternString", (string)PatternString!);
      }

      if (_PatternString != null)
      {
        writer.WritePropertyName("_patternString");
        _PatternString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternUri))
      {
        writer.WriteString("patternUri", (string)PatternUri!);
      }

      if (_PatternUri != null)
      {
        writer.WritePropertyName("_patternUri");
        _PatternUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternDate))
      {
        writer.WriteString("patternDate", (string)PatternDate!);
      }

      if (_PatternDate != null)
      {
        writer.WritePropertyName("_patternDate");
        _PatternDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternDateTime))
      {
        writer.WriteString("patternDateTime", (string)PatternDateTime!);
      }

      if (_PatternDateTime != null)
      {
        writer.WritePropertyName("_patternDateTime");
        _PatternDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternTime))
      {
        writer.WriteString("patternTime", (string)PatternTime!);
      }

      if (_PatternTime != null)
      {
        writer.WritePropertyName("_patternTime");
        _PatternTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternCode))
      {
        writer.WriteString("patternCode", (string)PatternCode!);
      }

      if (_PatternCode != null)
      {
        writer.WritePropertyName("_patternCode");
        _PatternCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternOid))
      {
        writer.WriteString("patternOid", (string)PatternOid!);
      }

      if (_PatternOid != null)
      {
        writer.WritePropertyName("_patternOid");
        _PatternOid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternId))
      {
        writer.WriteString("patternId", (string)PatternId!);
      }

      if (_PatternId != null)
      {
        writer.WritePropertyName("_patternId");
        _PatternId.SerializeJson(writer, options);
      }

      if (PatternUnsignedInt != null)
      {
        writer.WriteNumber("patternUnsignedInt", (uint)PatternUnsignedInt!);
      }

      if (PatternPositiveInt != null)
      {
        writer.WriteNumber("patternPositiveInt", (uint)PatternPositiveInt!);
      }

      if (!string.IsNullOrEmpty(PatternMarkdown))
      {
        writer.WriteString("patternMarkdown", (string)PatternMarkdown!);
      }

      if (_PatternMarkdown != null)
      {
        writer.WritePropertyName("_patternMarkdown");
        _PatternMarkdown.SerializeJson(writer, options);
      }

      if (PatternAnnotation != null)
      {
        writer.WritePropertyName("patternAnnotation");
        PatternAnnotation.SerializeJson(writer, options);
      }

      if (PatternAttachment != null)
      {
        writer.WritePropertyName("patternAttachment");
        PatternAttachment.SerializeJson(writer, options);
      }

      if (PatternIdentifier != null)
      {
        writer.WritePropertyName("patternIdentifier");
        PatternIdentifier.SerializeJson(writer, options);
      }

      if (PatternCodeableConcept != null)
      {
        writer.WritePropertyName("patternCodeableConcept");
        PatternCodeableConcept.SerializeJson(writer, options);
      }

      if (PatternCoding != null)
      {
        writer.WritePropertyName("patternCoding");
        PatternCoding.SerializeJson(writer, options);
      }

      if (PatternQuantity != null)
      {
        writer.WritePropertyName("patternQuantity");
        PatternQuantity.SerializeJson(writer, options);
      }

      if (PatternRange != null)
      {
        writer.WritePropertyName("patternRange");
        PatternRange.SerializeJson(writer, options);
      }

      if (PatternPeriod != null)
      {
        writer.WritePropertyName("patternPeriod");
        PatternPeriod.SerializeJson(writer, options);
      }

      if (PatternRatio != null)
      {
        writer.WritePropertyName("patternRatio");
        PatternRatio.SerializeJson(writer, options);
      }

      if (PatternSampledData != null)
      {
        writer.WritePropertyName("patternSampledData");
        PatternSampledData.SerializeJson(writer, options);
      }

      if (PatternSignature != null)
      {
        writer.WritePropertyName("patternSignature");
        PatternSignature.SerializeJson(writer, options);
      }

      if (PatternHumanName != null)
      {
        writer.WritePropertyName("patternHumanName");
        PatternHumanName.SerializeJson(writer, options);
      }

      if (PatternAddress != null)
      {
        writer.WritePropertyName("patternAddress");
        PatternAddress.SerializeJson(writer, options);
      }

      if (PatternContactPoint != null)
      {
        writer.WritePropertyName("patternContactPoint");
        PatternContactPoint.SerializeJson(writer, options);
      }

      if (PatternTiming != null)
      {
        writer.WritePropertyName("patternTiming");
        PatternTiming.SerializeJson(writer, options);
      }

      if (PatternReference != null)
      {
        writer.WritePropertyName("patternReference");
        PatternReference.SerializeJson(writer, options);
      }

      if (PatternMeta != null)
      {
        writer.WritePropertyName("patternMeta");
        PatternMeta.SerializeJson(writer, options);
      }

      if (ExampleBoolean != null)
      {
        writer.WriteBoolean("exampleBoolean", (bool)ExampleBoolean!);
      }

      if (_ExampleBoolean != null)
      {
        writer.WritePropertyName("_exampleBoolean");
        _ExampleBoolean.SerializeJson(writer, options);
      }

      if (ExampleInteger != null)
      {
        writer.WriteNumber("exampleInteger", (int)ExampleInteger!);
      }

      if (_ExampleInteger != null)
      {
        writer.WritePropertyName("_exampleInteger");
        _ExampleInteger.SerializeJson(writer, options);
      }

      if (ExampleDecimal != null)
      {
        writer.WriteNumber("exampleDecimal", (decimal)ExampleDecimal!);
      }

      if (_ExampleDecimal != null)
      {
        writer.WritePropertyName("_exampleDecimal");
        _ExampleDecimal.SerializeJson(writer, options);
      }

      if (ExampleBase64Binary != null)
      {
        writer.WriteString("exampleBase64Binary", System.Convert.ToBase64String(ExampleBase64Binary));
      }

      if (!string.IsNullOrEmpty(ExampleInstant))
      {
        writer.WriteString("exampleInstant", (string)ExampleInstant!);
      }

      if (_ExampleInstant != null)
      {
        writer.WritePropertyName("_exampleInstant");
        _ExampleInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleString))
      {
        writer.WriteString("exampleString", (string)ExampleString!);
      }

      if (_ExampleString != null)
      {
        writer.WritePropertyName("_exampleString");
        _ExampleString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleUri))
      {
        writer.WriteString("exampleUri", (string)ExampleUri!);
      }

      if (_ExampleUri != null)
      {
        writer.WritePropertyName("_exampleUri");
        _ExampleUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleDate))
      {
        writer.WriteString("exampleDate", (string)ExampleDate!);
      }

      if (_ExampleDate != null)
      {
        writer.WritePropertyName("_exampleDate");
        _ExampleDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleDateTime))
      {
        writer.WriteString("exampleDateTime", (string)ExampleDateTime!);
      }

      if (_ExampleDateTime != null)
      {
        writer.WritePropertyName("_exampleDateTime");
        _ExampleDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleTime))
      {
        writer.WriteString("exampleTime", (string)ExampleTime!);
      }

      if (_ExampleTime != null)
      {
        writer.WritePropertyName("_exampleTime");
        _ExampleTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleCode))
      {
        writer.WriteString("exampleCode", (string)ExampleCode!);
      }

      if (_ExampleCode != null)
      {
        writer.WritePropertyName("_exampleCode");
        _ExampleCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleOid))
      {
        writer.WriteString("exampleOid", (string)ExampleOid!);
      }

      if (_ExampleOid != null)
      {
        writer.WritePropertyName("_exampleOid");
        _ExampleOid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExampleId))
      {
        writer.WriteString("exampleId", (string)ExampleId!);
      }

      if (_ExampleId != null)
      {
        writer.WritePropertyName("_exampleId");
        _ExampleId.SerializeJson(writer, options);
      }

      if (ExampleUnsignedInt != null)
      {
        writer.WriteNumber("exampleUnsignedInt", (uint)ExampleUnsignedInt!);
      }

      if (ExamplePositiveInt != null)
      {
        writer.WriteNumber("examplePositiveInt", (uint)ExamplePositiveInt!);
      }

      if (!string.IsNullOrEmpty(ExampleMarkdown))
      {
        writer.WriteString("exampleMarkdown", (string)ExampleMarkdown!);
      }

      if (_ExampleMarkdown != null)
      {
        writer.WritePropertyName("_exampleMarkdown");
        _ExampleMarkdown.SerializeJson(writer, options);
      }

      if (ExampleAnnotation != null)
      {
        writer.WritePropertyName("exampleAnnotation");
        ExampleAnnotation.SerializeJson(writer, options);
      }

      if (ExampleAttachment != null)
      {
        writer.WritePropertyName("exampleAttachment");
        ExampleAttachment.SerializeJson(writer, options);
      }

      if (ExampleIdentifier != null)
      {
        writer.WritePropertyName("exampleIdentifier");
        ExampleIdentifier.SerializeJson(writer, options);
      }

      if (ExampleCodeableConcept != null)
      {
        writer.WritePropertyName("exampleCodeableConcept");
        ExampleCodeableConcept.SerializeJson(writer, options);
      }

      if (ExampleCoding != null)
      {
        writer.WritePropertyName("exampleCoding");
        ExampleCoding.SerializeJson(writer, options);
      }

      if (ExampleQuantity != null)
      {
        writer.WritePropertyName("exampleQuantity");
        ExampleQuantity.SerializeJson(writer, options);
      }

      if (ExampleRange != null)
      {
        writer.WritePropertyName("exampleRange");
        ExampleRange.SerializeJson(writer, options);
      }

      if (ExamplePeriod != null)
      {
        writer.WritePropertyName("examplePeriod");
        ExamplePeriod.SerializeJson(writer, options);
      }

      if (ExampleRatio != null)
      {
        writer.WritePropertyName("exampleRatio");
        ExampleRatio.SerializeJson(writer, options);
      }

      if (ExampleSampledData != null)
      {
        writer.WritePropertyName("exampleSampledData");
        ExampleSampledData.SerializeJson(writer, options);
      }

      if (ExampleSignature != null)
      {
        writer.WritePropertyName("exampleSignature");
        ExampleSignature.SerializeJson(writer, options);
      }

      if (ExampleHumanName != null)
      {
        writer.WritePropertyName("exampleHumanName");
        ExampleHumanName.SerializeJson(writer, options);
      }

      if (ExampleAddress != null)
      {
        writer.WritePropertyName("exampleAddress");
        ExampleAddress.SerializeJson(writer, options);
      }

      if (ExampleContactPoint != null)
      {
        writer.WritePropertyName("exampleContactPoint");
        ExampleContactPoint.SerializeJson(writer, options);
      }

      if (ExampleTiming != null)
      {
        writer.WritePropertyName("exampleTiming");
        ExampleTiming.SerializeJson(writer, options);
      }

      if (ExampleReference != null)
      {
        writer.WritePropertyName("exampleReference");
        ExampleReference.SerializeJson(writer, options);
      }

      if (ExampleMeta != null)
      {
        writer.WritePropertyName("exampleMeta");
        ExampleMeta.SerializeJson(writer, options);
      }

      if (MinValueBoolean != null)
      {
        writer.WriteBoolean("minValueBoolean", (bool)MinValueBoolean!);
      }

      if (_MinValueBoolean != null)
      {
        writer.WritePropertyName("_minValueBoolean");
        _MinValueBoolean.SerializeJson(writer, options);
      }

      if (MinValueInteger != null)
      {
        writer.WriteNumber("minValueInteger", (int)MinValueInteger!);
      }

      if (_MinValueInteger != null)
      {
        writer.WritePropertyName("_minValueInteger");
        _MinValueInteger.SerializeJson(writer, options);
      }

      if (MinValueDecimal != null)
      {
        writer.WriteNumber("minValueDecimal", (decimal)MinValueDecimal!);
      }

      if (_MinValueDecimal != null)
      {
        writer.WritePropertyName("_minValueDecimal");
        _MinValueDecimal.SerializeJson(writer, options);
      }

      if (MinValueBase64Binary != null)
      {
        writer.WriteString("minValueBase64Binary", System.Convert.ToBase64String(MinValueBase64Binary));
      }

      if (!string.IsNullOrEmpty(MinValueInstant))
      {
        writer.WriteString("minValueInstant", (string)MinValueInstant!);
      }

      if (_MinValueInstant != null)
      {
        writer.WritePropertyName("_minValueInstant");
        _MinValueInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueString))
      {
        writer.WriteString("minValueString", (string)MinValueString!);
      }

      if (_MinValueString != null)
      {
        writer.WritePropertyName("_minValueString");
        _MinValueString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueUri))
      {
        writer.WriteString("minValueUri", (string)MinValueUri!);
      }

      if (_MinValueUri != null)
      {
        writer.WritePropertyName("_minValueUri");
        _MinValueUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueDate))
      {
        writer.WriteString("minValueDate", (string)MinValueDate!);
      }

      if (_MinValueDate != null)
      {
        writer.WritePropertyName("_minValueDate");
        _MinValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueDateTime))
      {
        writer.WriteString("minValueDateTime", (string)MinValueDateTime!);
      }

      if (_MinValueDateTime != null)
      {
        writer.WritePropertyName("_minValueDateTime");
        _MinValueDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueTime))
      {
        writer.WriteString("minValueTime", (string)MinValueTime!);
      }

      if (_MinValueTime != null)
      {
        writer.WritePropertyName("_minValueTime");
        _MinValueTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueCode))
      {
        writer.WriteString("minValueCode", (string)MinValueCode!);
      }

      if (_MinValueCode != null)
      {
        writer.WritePropertyName("_minValueCode");
        _MinValueCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueOid))
      {
        writer.WriteString("minValueOid", (string)MinValueOid!);
      }

      if (_MinValueOid != null)
      {
        writer.WritePropertyName("_minValueOid");
        _MinValueOid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueId))
      {
        writer.WriteString("minValueId", (string)MinValueId!);
      }

      if (_MinValueId != null)
      {
        writer.WritePropertyName("_minValueId");
        _MinValueId.SerializeJson(writer, options);
      }

      if (MinValueUnsignedInt != null)
      {
        writer.WriteNumber("minValueUnsignedInt", (uint)MinValueUnsignedInt!);
      }

      if (MinValuePositiveInt != null)
      {
        writer.WriteNumber("minValuePositiveInt", (uint)MinValuePositiveInt!);
      }

      if (!string.IsNullOrEmpty(MinValueMarkdown))
      {
        writer.WriteString("minValueMarkdown", (string)MinValueMarkdown!);
      }

      if (_MinValueMarkdown != null)
      {
        writer.WritePropertyName("_minValueMarkdown");
        _MinValueMarkdown.SerializeJson(writer, options);
      }

      if (MinValueAnnotation != null)
      {
        writer.WritePropertyName("minValueAnnotation");
        MinValueAnnotation.SerializeJson(writer, options);
      }

      if (MinValueAttachment != null)
      {
        writer.WritePropertyName("minValueAttachment");
        MinValueAttachment.SerializeJson(writer, options);
      }

      if (MinValueIdentifier != null)
      {
        writer.WritePropertyName("minValueIdentifier");
        MinValueIdentifier.SerializeJson(writer, options);
      }

      if (MinValueCodeableConcept != null)
      {
        writer.WritePropertyName("minValueCodeableConcept");
        MinValueCodeableConcept.SerializeJson(writer, options);
      }

      if (MinValueCoding != null)
      {
        writer.WritePropertyName("minValueCoding");
        MinValueCoding.SerializeJson(writer, options);
      }

      if (MinValueQuantity != null)
      {
        writer.WritePropertyName("minValueQuantity");
        MinValueQuantity.SerializeJson(writer, options);
      }

      if (MinValueRange != null)
      {
        writer.WritePropertyName("minValueRange");
        MinValueRange.SerializeJson(writer, options);
      }

      if (MinValuePeriod != null)
      {
        writer.WritePropertyName("minValuePeriod");
        MinValuePeriod.SerializeJson(writer, options);
      }

      if (MinValueRatio != null)
      {
        writer.WritePropertyName("minValueRatio");
        MinValueRatio.SerializeJson(writer, options);
      }

      if (MinValueSampledData != null)
      {
        writer.WritePropertyName("minValueSampledData");
        MinValueSampledData.SerializeJson(writer, options);
      }

      if (MinValueSignature != null)
      {
        writer.WritePropertyName("minValueSignature");
        MinValueSignature.SerializeJson(writer, options);
      }

      if (MinValueHumanName != null)
      {
        writer.WritePropertyName("minValueHumanName");
        MinValueHumanName.SerializeJson(writer, options);
      }

      if (MinValueAddress != null)
      {
        writer.WritePropertyName("minValueAddress");
        MinValueAddress.SerializeJson(writer, options);
      }

      if (MinValueContactPoint != null)
      {
        writer.WritePropertyName("minValueContactPoint");
        MinValueContactPoint.SerializeJson(writer, options);
      }

      if (MinValueTiming != null)
      {
        writer.WritePropertyName("minValueTiming");
        MinValueTiming.SerializeJson(writer, options);
      }

      if (MinValueReference != null)
      {
        writer.WritePropertyName("minValueReference");
        MinValueReference.SerializeJson(writer, options);
      }

      if (MinValueMeta != null)
      {
        writer.WritePropertyName("minValueMeta");
        MinValueMeta.SerializeJson(writer, options);
      }

      if (MaxValueBoolean != null)
      {
        writer.WriteBoolean("maxValueBoolean", (bool)MaxValueBoolean!);
      }

      if (_MaxValueBoolean != null)
      {
        writer.WritePropertyName("_maxValueBoolean");
        _MaxValueBoolean.SerializeJson(writer, options);
      }

      if (MaxValueInteger != null)
      {
        writer.WriteNumber("maxValueInteger", (int)MaxValueInteger!);
      }

      if (_MaxValueInteger != null)
      {
        writer.WritePropertyName("_maxValueInteger");
        _MaxValueInteger.SerializeJson(writer, options);
      }

      if (MaxValueDecimal != null)
      {
        writer.WriteNumber("maxValueDecimal", (decimal)MaxValueDecimal!);
      }

      if (_MaxValueDecimal != null)
      {
        writer.WritePropertyName("_maxValueDecimal");
        _MaxValueDecimal.SerializeJson(writer, options);
      }

      if (MaxValueBase64Binary != null)
      {
        writer.WriteString("maxValueBase64Binary", System.Convert.ToBase64String(MaxValueBase64Binary));
      }

      if (!string.IsNullOrEmpty(MaxValueInstant))
      {
        writer.WriteString("maxValueInstant", (string)MaxValueInstant!);
      }

      if (_MaxValueInstant != null)
      {
        writer.WritePropertyName("_maxValueInstant");
        _MaxValueInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueString))
      {
        writer.WriteString("maxValueString", (string)MaxValueString!);
      }

      if (_MaxValueString != null)
      {
        writer.WritePropertyName("_maxValueString");
        _MaxValueString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueUri))
      {
        writer.WriteString("maxValueUri", (string)MaxValueUri!);
      }

      if (_MaxValueUri != null)
      {
        writer.WritePropertyName("_maxValueUri");
        _MaxValueUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueDate))
      {
        writer.WriteString("maxValueDate", (string)MaxValueDate!);
      }

      if (_MaxValueDate != null)
      {
        writer.WritePropertyName("_maxValueDate");
        _MaxValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueDateTime))
      {
        writer.WriteString("maxValueDateTime", (string)MaxValueDateTime!);
      }

      if (_MaxValueDateTime != null)
      {
        writer.WritePropertyName("_maxValueDateTime");
        _MaxValueDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueTime))
      {
        writer.WriteString("maxValueTime", (string)MaxValueTime!);
      }

      if (_MaxValueTime != null)
      {
        writer.WritePropertyName("_maxValueTime");
        _MaxValueTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueCode))
      {
        writer.WriteString("maxValueCode", (string)MaxValueCode!);
      }

      if (_MaxValueCode != null)
      {
        writer.WritePropertyName("_maxValueCode");
        _MaxValueCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueOid))
      {
        writer.WriteString("maxValueOid", (string)MaxValueOid!);
      }

      if (_MaxValueOid != null)
      {
        writer.WritePropertyName("_maxValueOid");
        _MaxValueOid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueId))
      {
        writer.WriteString("maxValueId", (string)MaxValueId!);
      }

      if (_MaxValueId != null)
      {
        writer.WritePropertyName("_maxValueId");
        _MaxValueId.SerializeJson(writer, options);
      }

      if (MaxValueUnsignedInt != null)
      {
        writer.WriteNumber("maxValueUnsignedInt", (uint)MaxValueUnsignedInt!);
      }

      if (MaxValuePositiveInt != null)
      {
        writer.WriteNumber("maxValuePositiveInt", (uint)MaxValuePositiveInt!);
      }

      if (!string.IsNullOrEmpty(MaxValueMarkdown))
      {
        writer.WriteString("maxValueMarkdown", (string)MaxValueMarkdown!);
      }

      if (_MaxValueMarkdown != null)
      {
        writer.WritePropertyName("_maxValueMarkdown");
        _MaxValueMarkdown.SerializeJson(writer, options);
      }

      if (MaxValueAnnotation != null)
      {
        writer.WritePropertyName("maxValueAnnotation");
        MaxValueAnnotation.SerializeJson(writer, options);
      }

      if (MaxValueAttachment != null)
      {
        writer.WritePropertyName("maxValueAttachment");
        MaxValueAttachment.SerializeJson(writer, options);
      }

      if (MaxValueIdentifier != null)
      {
        writer.WritePropertyName("maxValueIdentifier");
        MaxValueIdentifier.SerializeJson(writer, options);
      }

      if (MaxValueCodeableConcept != null)
      {
        writer.WritePropertyName("maxValueCodeableConcept");
        MaxValueCodeableConcept.SerializeJson(writer, options);
      }

      if (MaxValueCoding != null)
      {
        writer.WritePropertyName("maxValueCoding");
        MaxValueCoding.SerializeJson(writer, options);
      }

      if (MaxValueQuantity != null)
      {
        writer.WritePropertyName("maxValueQuantity");
        MaxValueQuantity.SerializeJson(writer, options);
      }

      if (MaxValueRange != null)
      {
        writer.WritePropertyName("maxValueRange");
        MaxValueRange.SerializeJson(writer, options);
      }

      if (MaxValuePeriod != null)
      {
        writer.WritePropertyName("maxValuePeriod");
        MaxValuePeriod.SerializeJson(writer, options);
      }

      if (MaxValueRatio != null)
      {
        writer.WritePropertyName("maxValueRatio");
        MaxValueRatio.SerializeJson(writer, options);
      }

      if (MaxValueSampledData != null)
      {
        writer.WritePropertyName("maxValueSampledData");
        MaxValueSampledData.SerializeJson(writer, options);
      }

      if (MaxValueSignature != null)
      {
        writer.WritePropertyName("maxValueSignature");
        MaxValueSignature.SerializeJson(writer, options);
      }

      if (MaxValueHumanName != null)
      {
        writer.WritePropertyName("maxValueHumanName");
        MaxValueHumanName.SerializeJson(writer, options);
      }

      if (MaxValueAddress != null)
      {
        writer.WritePropertyName("maxValueAddress");
        MaxValueAddress.SerializeJson(writer, options);
      }

      if (MaxValueContactPoint != null)
      {
        writer.WritePropertyName("maxValueContactPoint");
        MaxValueContactPoint.SerializeJson(writer, options);
      }

      if (MaxValueTiming != null)
      {
        writer.WritePropertyName("maxValueTiming");
        MaxValueTiming.SerializeJson(writer, options);
      }

      if (MaxValueReference != null)
      {
        writer.WritePropertyName("maxValueReference");
        MaxValueReference.SerializeJson(writer, options);
      }

      if (MaxValueMeta != null)
      {
        writer.WritePropertyName("maxValueMeta");
        MaxValueMeta.SerializeJson(writer, options);
      }

      if (MaxLength != null)
      {
        writer.WriteNumber("maxLength", (int)MaxLength!);
      }

      if (_MaxLength != null)
      {
        writer.WritePropertyName("_maxLength");
        _MaxLength.SerializeJson(writer, options);
      }

      if ((Condition != null) && (Condition.Count != 0))
      {
        writer.WritePropertyName("condition");
        writer.WriteStartArray();

        foreach (string valCondition in Condition)
        {
          writer.WriteStringValue(valCondition);
        }

        writer.WriteEndArray();
      }

      if ((_Condition != null) && (_Condition.Count != 0))
      {
        writer.WritePropertyName("_condition");
        writer.WriteStartArray();

        foreach (Element val_Condition in _Condition)
        {
          val_Condition.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Constraint != null) && (Constraint.Count != 0))
      {
        writer.WritePropertyName("constraint");
        writer.WriteStartArray();

        foreach (ElementDefinitionConstraint valConstraint in Constraint)
        {
          valConstraint.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (MustSupport != null)
      {
        writer.WriteBoolean("mustSupport", (bool)MustSupport!);
      }

      if (_MustSupport != null)
      {
        writer.WritePropertyName("_mustSupport");
        _MustSupport.SerializeJson(writer, options);
      }

      if (IsModifier != null)
      {
        writer.WriteBoolean("isModifier", (bool)IsModifier!);
      }

      if (_IsModifier != null)
      {
        writer.WritePropertyName("_isModifier");
        _IsModifier.SerializeJson(writer, options);
      }

      if (IsSummary != null)
      {
        writer.WriteBoolean("isSummary", (bool)IsSummary!);
      }

      if (_IsSummary != null)
      {
        writer.WritePropertyName("_isSummary");
        _IsSummary.SerializeJson(writer, options);
      }

      if (Binding != null)
      {
        writer.WritePropertyName("binding");
        Binding.SerializeJson(writer, options);
      }

      if ((Mapping != null) && (Mapping.Count != 0))
      {
        writer.WritePropertyName("mapping");
        writer.WriteStartArray();

        foreach (ElementDefinitionMapping valMapping in Mapping)
        {
          valMapping.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "alias":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Alias = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Alias.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Alias.Count == 0)
          {
            Alias = null;
          }

          break;

        case "_alias":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Alias = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Alias = new fhirCsR2.Models.Element();
            obj_Alias.DeserializeJson(ref reader, options);
            _Alias.Add(obj_Alias);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Alias.Count == 0)
          {
            _Alias = null;
          }

          break;

        case "base":
          Base = new fhirCsR2.Models.ElementDefinitionBase();
          Base.DeserializeJson(ref reader, options);
          break;

        case "binding":
          Binding = new fhirCsR2.Models.ElementDefinitionBinding();
          Binding.DeserializeJson(ref reader, options);
          break;

        case "code":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Code = new List<Coding>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Coding objCode = new fhirCsR2.Models.Coding();
            objCode.DeserializeJson(ref reader, options);
            Code.Add(objCode);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Code.Count == 0)
          {
            Code = null;
          }

          break;

        case "comments":
          Comments = reader.GetString();
          break;

        case "_comments":
          _Comments = new fhirCsR2.Models.Element();
          _Comments.DeserializeJson(ref reader, options);
          break;

        case "condition":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Condition = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Condition.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Condition.Count == 0)
          {
            Condition = null;
          }

          break;

        case "_condition":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Condition = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Condition = new fhirCsR2.Models.Element();
            obj_Condition.DeserializeJson(ref reader, options);
            _Condition.Add(obj_Condition);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Condition.Count == 0)
          {
            _Condition = null;
          }

          break;

        case "constraint":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Constraint = new List<ElementDefinitionConstraint>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ElementDefinitionConstraint objConstraint = new fhirCsR2.Models.ElementDefinitionConstraint();
            objConstraint.DeserializeJson(ref reader, options);
            Constraint.Add(objConstraint);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Constraint.Count == 0)
          {
            Constraint = null;
          }

          break;

        case "defaultValueBoolean":
          DefaultValueBoolean = reader.GetBoolean();
          break;

        case "_defaultValueBoolean":
          _DefaultValueBoolean = new fhirCsR2.Models.Element();
          _DefaultValueBoolean.DeserializeJson(ref reader, options);
          break;

        case "defaultValueInteger":
          DefaultValueInteger = reader.GetInt32();
          break;

        case "_defaultValueInteger":
          _DefaultValueInteger = new fhirCsR2.Models.Element();
          _DefaultValueInteger.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDecimal":
          DefaultValueDecimal = reader.GetDecimal();
          break;

        case "_defaultValueDecimal":
          _DefaultValueDecimal = new fhirCsR2.Models.Element();
          _DefaultValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "defaultValueBase64Binary":
          DefaultValueBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "defaultValueInstant":
          DefaultValueInstant = reader.GetString();
          break;

        case "_defaultValueInstant":
          _DefaultValueInstant = new fhirCsR2.Models.Element();
          _DefaultValueInstant.DeserializeJson(ref reader, options);
          break;

        case "defaultValueString":
          DefaultValueString = reader.GetString();
          break;

        case "_defaultValueString":
          _DefaultValueString = new fhirCsR2.Models.Element();
          _DefaultValueString.DeserializeJson(ref reader, options);
          break;

        case "defaultValueUri":
          DefaultValueUri = reader.GetString();
          break;

        case "_defaultValueUri":
          _DefaultValueUri = new fhirCsR2.Models.Element();
          _DefaultValueUri.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDate":
          DefaultValueDate = reader.GetString();
          break;

        case "_defaultValueDate":
          _DefaultValueDate = new fhirCsR2.Models.Element();
          _DefaultValueDate.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDateTime":
          DefaultValueDateTime = reader.GetString();
          break;

        case "_defaultValueDateTime":
          _DefaultValueDateTime = new fhirCsR2.Models.Element();
          _DefaultValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "defaultValueTime":
          DefaultValueTime = reader.GetString();
          break;

        case "_defaultValueTime":
          _DefaultValueTime = new fhirCsR2.Models.Element();
          _DefaultValueTime.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCode":
          DefaultValueCode = reader.GetString();
          break;

        case "_defaultValueCode":
          _DefaultValueCode = new fhirCsR2.Models.Element();
          _DefaultValueCode.DeserializeJson(ref reader, options);
          break;

        case "defaultValueOid":
          DefaultValueOid = reader.GetString();
          break;

        case "_defaultValueOid":
          _DefaultValueOid = new fhirCsR2.Models.Element();
          _DefaultValueOid.DeserializeJson(ref reader, options);
          break;

        case "defaultValueId":
          DefaultValueId = reader.GetString();
          break;

        case "_defaultValueId":
          _DefaultValueId = new fhirCsR2.Models.Element();
          _DefaultValueId.DeserializeJson(ref reader, options);
          break;

        case "defaultValueUnsignedInt":
          DefaultValueUnsignedInt = reader.GetUInt32();
          break;

        case "defaultValuePositiveInt":
          DefaultValuePositiveInt = reader.GetUInt32();
          break;

        case "defaultValueMarkdown":
          DefaultValueMarkdown = reader.GetString();
          break;

        case "_defaultValueMarkdown":
          _DefaultValueMarkdown = new fhirCsR2.Models.Element();
          _DefaultValueMarkdown.DeserializeJson(ref reader, options);
          break;

        case "defaultValueAnnotation":
          DefaultValueAnnotation = new fhirCsR2.Models.Annotation();
          DefaultValueAnnotation.DeserializeJson(ref reader, options);
          break;

        case "defaultValueAttachment":
          DefaultValueAttachment = new fhirCsR2.Models.Attachment();
          DefaultValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "defaultValueIdentifier":
          DefaultValueIdentifier = new fhirCsR2.Models.Identifier();
          DefaultValueIdentifier.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCodeableConcept":
          DefaultValueCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          DefaultValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCoding":
          DefaultValueCoding = new fhirCsR2.Models.Coding();
          DefaultValueCoding.DeserializeJson(ref reader, options);
          break;

        case "defaultValueQuantity":
          DefaultValueQuantity = new fhirCsR2.Models.Quantity();
          DefaultValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "defaultValueRange":
          DefaultValueRange = new fhirCsR2.Models.Range();
          DefaultValueRange.DeserializeJson(ref reader, options);
          break;

        case "defaultValuePeriod":
          DefaultValuePeriod = new fhirCsR2.Models.Period();
          DefaultValuePeriod.DeserializeJson(ref reader, options);
          break;

        case "defaultValueRatio":
          DefaultValueRatio = new fhirCsR2.Models.Ratio();
          DefaultValueRatio.DeserializeJson(ref reader, options);
          break;

        case "defaultValueSampledData":
          DefaultValueSampledData = new fhirCsR2.Models.SampledData();
          DefaultValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "defaultValueSignature":
          DefaultValueSignature = new fhirCsR2.Models.Signature();
          DefaultValueSignature.DeserializeJson(ref reader, options);
          break;

        case "defaultValueHumanName":
          DefaultValueHumanName = new fhirCsR2.Models.HumanName();
          DefaultValueHumanName.DeserializeJson(ref reader, options);
          break;

        case "defaultValueAddress":
          DefaultValueAddress = new fhirCsR2.Models.Address();
          DefaultValueAddress.DeserializeJson(ref reader, options);
          break;

        case "defaultValueContactPoint":
          DefaultValueContactPoint = new fhirCsR2.Models.ContactPoint();
          DefaultValueContactPoint.DeserializeJson(ref reader, options);
          break;

        case "defaultValueTiming":
          DefaultValueTiming = new fhirCsR2.Models.Timing();
          DefaultValueTiming.DeserializeJson(ref reader, options);
          break;

        case "defaultValueReference":
          DefaultValueReference = new fhirCsR2.Models.Reference();
          DefaultValueReference.DeserializeJson(ref reader, options);
          break;

        case "defaultValueMeta":
          DefaultValueMeta = new fhirCsR2.Models.Meta();
          DefaultValueMeta.DeserializeJson(ref reader, options);
          break;

        case "definition":
          Definition = reader.GetString();
          break;

        case "_definition":
          _Definition = new fhirCsR2.Models.Element();
          _Definition.DeserializeJson(ref reader, options);
          break;

        case "exampleBoolean":
          ExampleBoolean = reader.GetBoolean();
          break;

        case "_exampleBoolean":
          _ExampleBoolean = new fhirCsR2.Models.Element();
          _ExampleBoolean.DeserializeJson(ref reader, options);
          break;

        case "exampleInteger":
          ExampleInteger = reader.GetInt32();
          break;

        case "_exampleInteger":
          _ExampleInteger = new fhirCsR2.Models.Element();
          _ExampleInteger.DeserializeJson(ref reader, options);
          break;

        case "exampleDecimal":
          ExampleDecimal = reader.GetDecimal();
          break;

        case "_exampleDecimal":
          _ExampleDecimal = new fhirCsR2.Models.Element();
          _ExampleDecimal.DeserializeJson(ref reader, options);
          break;

        case "exampleBase64Binary":
          ExampleBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "exampleInstant":
          ExampleInstant = reader.GetString();
          break;

        case "_exampleInstant":
          _ExampleInstant = new fhirCsR2.Models.Element();
          _ExampleInstant.DeserializeJson(ref reader, options);
          break;

        case "exampleString":
          ExampleString = reader.GetString();
          break;

        case "_exampleString":
          _ExampleString = new fhirCsR2.Models.Element();
          _ExampleString.DeserializeJson(ref reader, options);
          break;

        case "exampleUri":
          ExampleUri = reader.GetString();
          break;

        case "_exampleUri":
          _ExampleUri = new fhirCsR2.Models.Element();
          _ExampleUri.DeserializeJson(ref reader, options);
          break;

        case "exampleDate":
          ExampleDate = reader.GetString();
          break;

        case "_exampleDate":
          _ExampleDate = new fhirCsR2.Models.Element();
          _ExampleDate.DeserializeJson(ref reader, options);
          break;

        case "exampleDateTime":
          ExampleDateTime = reader.GetString();
          break;

        case "_exampleDateTime":
          _ExampleDateTime = new fhirCsR2.Models.Element();
          _ExampleDateTime.DeserializeJson(ref reader, options);
          break;

        case "exampleTime":
          ExampleTime = reader.GetString();
          break;

        case "_exampleTime":
          _ExampleTime = new fhirCsR2.Models.Element();
          _ExampleTime.DeserializeJson(ref reader, options);
          break;

        case "exampleCode":
          ExampleCode = reader.GetString();
          break;

        case "_exampleCode":
          _ExampleCode = new fhirCsR2.Models.Element();
          _ExampleCode.DeserializeJson(ref reader, options);
          break;

        case "exampleOid":
          ExampleOid = reader.GetString();
          break;

        case "_exampleOid":
          _ExampleOid = new fhirCsR2.Models.Element();
          _ExampleOid.DeserializeJson(ref reader, options);
          break;

        case "exampleId":
          ExampleId = reader.GetString();
          break;

        case "_exampleId":
          _ExampleId = new fhirCsR2.Models.Element();
          _ExampleId.DeserializeJson(ref reader, options);
          break;

        case "exampleUnsignedInt":
          ExampleUnsignedInt = reader.GetUInt32();
          break;

        case "examplePositiveInt":
          ExamplePositiveInt = reader.GetUInt32();
          break;

        case "exampleMarkdown":
          ExampleMarkdown = reader.GetString();
          break;

        case "_exampleMarkdown":
          _ExampleMarkdown = new fhirCsR2.Models.Element();
          _ExampleMarkdown.DeserializeJson(ref reader, options);
          break;

        case "exampleAnnotation":
          ExampleAnnotation = new fhirCsR2.Models.Annotation();
          ExampleAnnotation.DeserializeJson(ref reader, options);
          break;

        case "exampleAttachment":
          ExampleAttachment = new fhirCsR2.Models.Attachment();
          ExampleAttachment.DeserializeJson(ref reader, options);
          break;

        case "exampleIdentifier":
          ExampleIdentifier = new fhirCsR2.Models.Identifier();
          ExampleIdentifier.DeserializeJson(ref reader, options);
          break;

        case "exampleCodeableConcept":
          ExampleCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          ExampleCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "exampleCoding":
          ExampleCoding = new fhirCsR2.Models.Coding();
          ExampleCoding.DeserializeJson(ref reader, options);
          break;

        case "exampleQuantity":
          ExampleQuantity = new fhirCsR2.Models.Quantity();
          ExampleQuantity.DeserializeJson(ref reader, options);
          break;

        case "exampleRange":
          ExampleRange = new fhirCsR2.Models.Range();
          ExampleRange.DeserializeJson(ref reader, options);
          break;

        case "examplePeriod":
          ExamplePeriod = new fhirCsR2.Models.Period();
          ExamplePeriod.DeserializeJson(ref reader, options);
          break;

        case "exampleRatio":
          ExampleRatio = new fhirCsR2.Models.Ratio();
          ExampleRatio.DeserializeJson(ref reader, options);
          break;

        case "exampleSampledData":
          ExampleSampledData = new fhirCsR2.Models.SampledData();
          ExampleSampledData.DeserializeJson(ref reader, options);
          break;

        case "exampleSignature":
          ExampleSignature = new fhirCsR2.Models.Signature();
          ExampleSignature.DeserializeJson(ref reader, options);
          break;

        case "exampleHumanName":
          ExampleHumanName = new fhirCsR2.Models.HumanName();
          ExampleHumanName.DeserializeJson(ref reader, options);
          break;

        case "exampleAddress":
          ExampleAddress = new fhirCsR2.Models.Address();
          ExampleAddress.DeserializeJson(ref reader, options);
          break;

        case "exampleContactPoint":
          ExampleContactPoint = new fhirCsR2.Models.ContactPoint();
          ExampleContactPoint.DeserializeJson(ref reader, options);
          break;

        case "exampleTiming":
          ExampleTiming = new fhirCsR2.Models.Timing();
          ExampleTiming.DeserializeJson(ref reader, options);
          break;

        case "exampleReference":
          ExampleReference = new fhirCsR2.Models.Reference();
          ExampleReference.DeserializeJson(ref reader, options);
          break;

        case "exampleMeta":
          ExampleMeta = new fhirCsR2.Models.Meta();
          ExampleMeta.DeserializeJson(ref reader, options);
          break;

        case "fixedBoolean":
          FixedBoolean = reader.GetBoolean();
          break;

        case "_fixedBoolean":
          _FixedBoolean = new fhirCsR2.Models.Element();
          _FixedBoolean.DeserializeJson(ref reader, options);
          break;

        case "fixedInteger":
          FixedInteger = reader.GetInt32();
          break;

        case "_fixedInteger":
          _FixedInteger = new fhirCsR2.Models.Element();
          _FixedInteger.DeserializeJson(ref reader, options);
          break;

        case "fixedDecimal":
          FixedDecimal = reader.GetDecimal();
          break;

        case "_fixedDecimal":
          _FixedDecimal = new fhirCsR2.Models.Element();
          _FixedDecimal.DeserializeJson(ref reader, options);
          break;

        case "fixedBase64Binary":
          FixedBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "fixedInstant":
          FixedInstant = reader.GetString();
          break;

        case "_fixedInstant":
          _FixedInstant = new fhirCsR2.Models.Element();
          _FixedInstant.DeserializeJson(ref reader, options);
          break;

        case "fixedString":
          FixedString = reader.GetString();
          break;

        case "_fixedString":
          _FixedString = new fhirCsR2.Models.Element();
          _FixedString.DeserializeJson(ref reader, options);
          break;

        case "fixedUri":
          FixedUri = reader.GetString();
          break;

        case "_fixedUri":
          _FixedUri = new fhirCsR2.Models.Element();
          _FixedUri.DeserializeJson(ref reader, options);
          break;

        case "fixedDate":
          FixedDate = reader.GetString();
          break;

        case "_fixedDate":
          _FixedDate = new fhirCsR2.Models.Element();
          _FixedDate.DeserializeJson(ref reader, options);
          break;

        case "fixedDateTime":
          FixedDateTime = reader.GetString();
          break;

        case "_fixedDateTime":
          _FixedDateTime = new fhirCsR2.Models.Element();
          _FixedDateTime.DeserializeJson(ref reader, options);
          break;

        case "fixedTime":
          FixedTime = reader.GetString();
          break;

        case "_fixedTime":
          _FixedTime = new fhirCsR2.Models.Element();
          _FixedTime.DeserializeJson(ref reader, options);
          break;

        case "fixedCode":
          FixedCode = reader.GetString();
          break;

        case "_fixedCode":
          _FixedCode = new fhirCsR2.Models.Element();
          _FixedCode.DeserializeJson(ref reader, options);
          break;

        case "fixedOid":
          FixedOid = reader.GetString();
          break;

        case "_fixedOid":
          _FixedOid = new fhirCsR2.Models.Element();
          _FixedOid.DeserializeJson(ref reader, options);
          break;

        case "fixedId":
          FixedId = reader.GetString();
          break;

        case "_fixedId":
          _FixedId = new fhirCsR2.Models.Element();
          _FixedId.DeserializeJson(ref reader, options);
          break;

        case "fixedUnsignedInt":
          FixedUnsignedInt = reader.GetUInt32();
          break;

        case "fixedPositiveInt":
          FixedPositiveInt = reader.GetUInt32();
          break;

        case "fixedMarkdown":
          FixedMarkdown = reader.GetString();
          break;

        case "_fixedMarkdown":
          _FixedMarkdown = new fhirCsR2.Models.Element();
          _FixedMarkdown.DeserializeJson(ref reader, options);
          break;

        case "fixedAnnotation":
          FixedAnnotation = new fhirCsR2.Models.Annotation();
          FixedAnnotation.DeserializeJson(ref reader, options);
          break;

        case "fixedAttachment":
          FixedAttachment = new fhirCsR2.Models.Attachment();
          FixedAttachment.DeserializeJson(ref reader, options);
          break;

        case "fixedIdentifier":
          FixedIdentifier = new fhirCsR2.Models.Identifier();
          FixedIdentifier.DeserializeJson(ref reader, options);
          break;

        case "fixedCodeableConcept":
          FixedCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          FixedCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "fixedCoding":
          FixedCoding = new fhirCsR2.Models.Coding();
          FixedCoding.DeserializeJson(ref reader, options);
          break;

        case "fixedQuantity":
          FixedQuantity = new fhirCsR2.Models.Quantity();
          FixedQuantity.DeserializeJson(ref reader, options);
          break;

        case "fixedRange":
          FixedRange = new fhirCsR2.Models.Range();
          FixedRange.DeserializeJson(ref reader, options);
          break;

        case "fixedPeriod":
          FixedPeriod = new fhirCsR2.Models.Period();
          FixedPeriod.DeserializeJson(ref reader, options);
          break;

        case "fixedRatio":
          FixedRatio = new fhirCsR2.Models.Ratio();
          FixedRatio.DeserializeJson(ref reader, options);
          break;

        case "fixedSampledData":
          FixedSampledData = new fhirCsR2.Models.SampledData();
          FixedSampledData.DeserializeJson(ref reader, options);
          break;

        case "fixedSignature":
          FixedSignature = new fhirCsR2.Models.Signature();
          FixedSignature.DeserializeJson(ref reader, options);
          break;

        case "fixedHumanName":
          FixedHumanName = new fhirCsR2.Models.HumanName();
          FixedHumanName.DeserializeJson(ref reader, options);
          break;

        case "fixedAddress":
          FixedAddress = new fhirCsR2.Models.Address();
          FixedAddress.DeserializeJson(ref reader, options);
          break;

        case "fixedContactPoint":
          FixedContactPoint = new fhirCsR2.Models.ContactPoint();
          FixedContactPoint.DeserializeJson(ref reader, options);
          break;

        case "fixedTiming":
          FixedTiming = new fhirCsR2.Models.Timing();
          FixedTiming.DeserializeJson(ref reader, options);
          break;

        case "fixedReference":
          FixedReference = new fhirCsR2.Models.Reference();
          FixedReference.DeserializeJson(ref reader, options);
          break;

        case "fixedMeta":
          FixedMeta = new fhirCsR2.Models.Meta();
          FixedMeta.DeserializeJson(ref reader, options);
          break;

        case "isModifier":
          IsModifier = reader.GetBoolean();
          break;

        case "_isModifier":
          _IsModifier = new fhirCsR2.Models.Element();
          _IsModifier.DeserializeJson(ref reader, options);
          break;

        case "isSummary":
          IsSummary = reader.GetBoolean();
          break;

        case "_isSummary":
          _IsSummary = new fhirCsR2.Models.Element();
          _IsSummary.DeserializeJson(ref reader, options);
          break;

        case "label":
          Label = reader.GetString();
          break;

        case "_label":
          _Label = new fhirCsR2.Models.Element();
          _Label.DeserializeJson(ref reader, options);
          break;

        case "mapping":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Mapping = new List<ElementDefinitionMapping>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ElementDefinitionMapping objMapping = new fhirCsR2.Models.ElementDefinitionMapping();
            objMapping.DeserializeJson(ref reader, options);
            Mapping.Add(objMapping);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Mapping.Count == 0)
          {
            Mapping = null;
          }

          break;

        case "max":
          Max = reader.GetString();
          break;

        case "_max":
          _Max = new fhirCsR2.Models.Element();
          _Max.DeserializeJson(ref reader, options);
          break;

        case "maxLength":
          MaxLength = reader.GetInt32();
          break;

        case "_maxLength":
          _MaxLength = new fhirCsR2.Models.Element();
          _MaxLength.DeserializeJson(ref reader, options);
          break;

        case "maxValueBoolean":
          MaxValueBoolean = reader.GetBoolean();
          break;

        case "_maxValueBoolean":
          _MaxValueBoolean = new fhirCsR2.Models.Element();
          _MaxValueBoolean.DeserializeJson(ref reader, options);
          break;

        case "maxValueInteger":
          MaxValueInteger = reader.GetInt32();
          break;

        case "_maxValueInteger":
          _MaxValueInteger = new fhirCsR2.Models.Element();
          _MaxValueInteger.DeserializeJson(ref reader, options);
          break;

        case "maxValueDecimal":
          MaxValueDecimal = reader.GetDecimal();
          break;

        case "_maxValueDecimal":
          _MaxValueDecimal = new fhirCsR2.Models.Element();
          _MaxValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "maxValueBase64Binary":
          MaxValueBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "maxValueInstant":
          MaxValueInstant = reader.GetString();
          break;

        case "_maxValueInstant":
          _MaxValueInstant = new fhirCsR2.Models.Element();
          _MaxValueInstant.DeserializeJson(ref reader, options);
          break;

        case "maxValueString":
          MaxValueString = reader.GetString();
          break;

        case "_maxValueString":
          _MaxValueString = new fhirCsR2.Models.Element();
          _MaxValueString.DeserializeJson(ref reader, options);
          break;

        case "maxValueUri":
          MaxValueUri = reader.GetString();
          break;

        case "_maxValueUri":
          _MaxValueUri = new fhirCsR2.Models.Element();
          _MaxValueUri.DeserializeJson(ref reader, options);
          break;

        case "maxValueDate":
          MaxValueDate = reader.GetString();
          break;

        case "_maxValueDate":
          _MaxValueDate = new fhirCsR2.Models.Element();
          _MaxValueDate.DeserializeJson(ref reader, options);
          break;

        case "maxValueDateTime":
          MaxValueDateTime = reader.GetString();
          break;

        case "_maxValueDateTime":
          _MaxValueDateTime = new fhirCsR2.Models.Element();
          _MaxValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "maxValueTime":
          MaxValueTime = reader.GetString();
          break;

        case "_maxValueTime":
          _MaxValueTime = new fhirCsR2.Models.Element();
          _MaxValueTime.DeserializeJson(ref reader, options);
          break;

        case "maxValueCode":
          MaxValueCode = reader.GetString();
          break;

        case "_maxValueCode":
          _MaxValueCode = new fhirCsR2.Models.Element();
          _MaxValueCode.DeserializeJson(ref reader, options);
          break;

        case "maxValueOid":
          MaxValueOid = reader.GetString();
          break;

        case "_maxValueOid":
          _MaxValueOid = new fhirCsR2.Models.Element();
          _MaxValueOid.DeserializeJson(ref reader, options);
          break;

        case "maxValueId":
          MaxValueId = reader.GetString();
          break;

        case "_maxValueId":
          _MaxValueId = new fhirCsR2.Models.Element();
          _MaxValueId.DeserializeJson(ref reader, options);
          break;

        case "maxValueUnsignedInt":
          MaxValueUnsignedInt = reader.GetUInt32();
          break;

        case "maxValuePositiveInt":
          MaxValuePositiveInt = reader.GetUInt32();
          break;

        case "maxValueMarkdown":
          MaxValueMarkdown = reader.GetString();
          break;

        case "_maxValueMarkdown":
          _MaxValueMarkdown = new fhirCsR2.Models.Element();
          _MaxValueMarkdown.DeserializeJson(ref reader, options);
          break;

        case "maxValueAnnotation":
          MaxValueAnnotation = new fhirCsR2.Models.Annotation();
          MaxValueAnnotation.DeserializeJson(ref reader, options);
          break;

        case "maxValueAttachment":
          MaxValueAttachment = new fhirCsR2.Models.Attachment();
          MaxValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "maxValueIdentifier":
          MaxValueIdentifier = new fhirCsR2.Models.Identifier();
          MaxValueIdentifier.DeserializeJson(ref reader, options);
          break;

        case "maxValueCodeableConcept":
          MaxValueCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          MaxValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "maxValueCoding":
          MaxValueCoding = new fhirCsR2.Models.Coding();
          MaxValueCoding.DeserializeJson(ref reader, options);
          break;

        case "maxValueQuantity":
          MaxValueQuantity = new fhirCsR2.Models.Quantity();
          MaxValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "maxValueRange":
          MaxValueRange = new fhirCsR2.Models.Range();
          MaxValueRange.DeserializeJson(ref reader, options);
          break;

        case "maxValuePeriod":
          MaxValuePeriod = new fhirCsR2.Models.Period();
          MaxValuePeriod.DeserializeJson(ref reader, options);
          break;

        case "maxValueRatio":
          MaxValueRatio = new fhirCsR2.Models.Ratio();
          MaxValueRatio.DeserializeJson(ref reader, options);
          break;

        case "maxValueSampledData":
          MaxValueSampledData = new fhirCsR2.Models.SampledData();
          MaxValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "maxValueSignature":
          MaxValueSignature = new fhirCsR2.Models.Signature();
          MaxValueSignature.DeserializeJson(ref reader, options);
          break;

        case "maxValueHumanName":
          MaxValueHumanName = new fhirCsR2.Models.HumanName();
          MaxValueHumanName.DeserializeJson(ref reader, options);
          break;

        case "maxValueAddress":
          MaxValueAddress = new fhirCsR2.Models.Address();
          MaxValueAddress.DeserializeJson(ref reader, options);
          break;

        case "maxValueContactPoint":
          MaxValueContactPoint = new fhirCsR2.Models.ContactPoint();
          MaxValueContactPoint.DeserializeJson(ref reader, options);
          break;

        case "maxValueTiming":
          MaxValueTiming = new fhirCsR2.Models.Timing();
          MaxValueTiming.DeserializeJson(ref reader, options);
          break;

        case "maxValueReference":
          MaxValueReference = new fhirCsR2.Models.Reference();
          MaxValueReference.DeserializeJson(ref reader, options);
          break;

        case "maxValueMeta":
          MaxValueMeta = new fhirCsR2.Models.Meta();
          MaxValueMeta.DeserializeJson(ref reader, options);
          break;

        case "meaningWhenMissing":
          MeaningWhenMissing = reader.GetString();
          break;

        case "_meaningWhenMissing":
          _MeaningWhenMissing = new fhirCsR2.Models.Element();
          _MeaningWhenMissing.DeserializeJson(ref reader, options);
          break;

        case "min":
          Min = reader.GetInt32();
          break;

        case "_min":
          _Min = new fhirCsR2.Models.Element();
          _Min.DeserializeJson(ref reader, options);
          break;

        case "minValueBoolean":
          MinValueBoolean = reader.GetBoolean();
          break;

        case "_minValueBoolean":
          _MinValueBoolean = new fhirCsR2.Models.Element();
          _MinValueBoolean.DeserializeJson(ref reader, options);
          break;

        case "minValueInteger":
          MinValueInteger = reader.GetInt32();
          break;

        case "_minValueInteger":
          _MinValueInteger = new fhirCsR2.Models.Element();
          _MinValueInteger.DeserializeJson(ref reader, options);
          break;

        case "minValueDecimal":
          MinValueDecimal = reader.GetDecimal();
          break;

        case "_minValueDecimal":
          _MinValueDecimal = new fhirCsR2.Models.Element();
          _MinValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "minValueBase64Binary":
          MinValueBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "minValueInstant":
          MinValueInstant = reader.GetString();
          break;

        case "_minValueInstant":
          _MinValueInstant = new fhirCsR2.Models.Element();
          _MinValueInstant.DeserializeJson(ref reader, options);
          break;

        case "minValueString":
          MinValueString = reader.GetString();
          break;

        case "_minValueString":
          _MinValueString = new fhirCsR2.Models.Element();
          _MinValueString.DeserializeJson(ref reader, options);
          break;

        case "minValueUri":
          MinValueUri = reader.GetString();
          break;

        case "_minValueUri":
          _MinValueUri = new fhirCsR2.Models.Element();
          _MinValueUri.DeserializeJson(ref reader, options);
          break;

        case "minValueDate":
          MinValueDate = reader.GetString();
          break;

        case "_minValueDate":
          _MinValueDate = new fhirCsR2.Models.Element();
          _MinValueDate.DeserializeJson(ref reader, options);
          break;

        case "minValueDateTime":
          MinValueDateTime = reader.GetString();
          break;

        case "_minValueDateTime":
          _MinValueDateTime = new fhirCsR2.Models.Element();
          _MinValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "minValueTime":
          MinValueTime = reader.GetString();
          break;

        case "_minValueTime":
          _MinValueTime = new fhirCsR2.Models.Element();
          _MinValueTime.DeserializeJson(ref reader, options);
          break;

        case "minValueCode":
          MinValueCode = reader.GetString();
          break;

        case "_minValueCode":
          _MinValueCode = new fhirCsR2.Models.Element();
          _MinValueCode.DeserializeJson(ref reader, options);
          break;

        case "minValueOid":
          MinValueOid = reader.GetString();
          break;

        case "_minValueOid":
          _MinValueOid = new fhirCsR2.Models.Element();
          _MinValueOid.DeserializeJson(ref reader, options);
          break;

        case "minValueId":
          MinValueId = reader.GetString();
          break;

        case "_minValueId":
          _MinValueId = new fhirCsR2.Models.Element();
          _MinValueId.DeserializeJson(ref reader, options);
          break;

        case "minValueUnsignedInt":
          MinValueUnsignedInt = reader.GetUInt32();
          break;

        case "minValuePositiveInt":
          MinValuePositiveInt = reader.GetUInt32();
          break;

        case "minValueMarkdown":
          MinValueMarkdown = reader.GetString();
          break;

        case "_minValueMarkdown":
          _MinValueMarkdown = new fhirCsR2.Models.Element();
          _MinValueMarkdown.DeserializeJson(ref reader, options);
          break;

        case "minValueAnnotation":
          MinValueAnnotation = new fhirCsR2.Models.Annotation();
          MinValueAnnotation.DeserializeJson(ref reader, options);
          break;

        case "minValueAttachment":
          MinValueAttachment = new fhirCsR2.Models.Attachment();
          MinValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "minValueIdentifier":
          MinValueIdentifier = new fhirCsR2.Models.Identifier();
          MinValueIdentifier.DeserializeJson(ref reader, options);
          break;

        case "minValueCodeableConcept":
          MinValueCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          MinValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "minValueCoding":
          MinValueCoding = new fhirCsR2.Models.Coding();
          MinValueCoding.DeserializeJson(ref reader, options);
          break;

        case "minValueQuantity":
          MinValueQuantity = new fhirCsR2.Models.Quantity();
          MinValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "minValueRange":
          MinValueRange = new fhirCsR2.Models.Range();
          MinValueRange.DeserializeJson(ref reader, options);
          break;

        case "minValuePeriod":
          MinValuePeriod = new fhirCsR2.Models.Period();
          MinValuePeriod.DeserializeJson(ref reader, options);
          break;

        case "minValueRatio":
          MinValueRatio = new fhirCsR2.Models.Ratio();
          MinValueRatio.DeserializeJson(ref reader, options);
          break;

        case "minValueSampledData":
          MinValueSampledData = new fhirCsR2.Models.SampledData();
          MinValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "minValueSignature":
          MinValueSignature = new fhirCsR2.Models.Signature();
          MinValueSignature.DeserializeJson(ref reader, options);
          break;

        case "minValueHumanName":
          MinValueHumanName = new fhirCsR2.Models.HumanName();
          MinValueHumanName.DeserializeJson(ref reader, options);
          break;

        case "minValueAddress":
          MinValueAddress = new fhirCsR2.Models.Address();
          MinValueAddress.DeserializeJson(ref reader, options);
          break;

        case "minValueContactPoint":
          MinValueContactPoint = new fhirCsR2.Models.ContactPoint();
          MinValueContactPoint.DeserializeJson(ref reader, options);
          break;

        case "minValueTiming":
          MinValueTiming = new fhirCsR2.Models.Timing();
          MinValueTiming.DeserializeJson(ref reader, options);
          break;

        case "minValueReference":
          MinValueReference = new fhirCsR2.Models.Reference();
          MinValueReference.DeserializeJson(ref reader, options);
          break;

        case "minValueMeta":
          MinValueMeta = new fhirCsR2.Models.Meta();
          MinValueMeta.DeserializeJson(ref reader, options);
          break;

        case "mustSupport":
          MustSupport = reader.GetBoolean();
          break;

        case "_mustSupport":
          _MustSupport = new fhirCsR2.Models.Element();
          _MustSupport.DeserializeJson(ref reader, options);
          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR2.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "nameReference":
          NameReference = reader.GetString();
          break;

        case "_nameReference":
          _NameReference = new fhirCsR2.Models.Element();
          _NameReference.DeserializeJson(ref reader, options);
          break;

        case "path":
          Path = reader.GetString();
          break;

        case "_path":
          _Path = new fhirCsR2.Models.Element();
          _Path.DeserializeJson(ref reader, options);
          break;

        case "patternBoolean":
          PatternBoolean = reader.GetBoolean();
          break;

        case "_patternBoolean":
          _PatternBoolean = new fhirCsR2.Models.Element();
          _PatternBoolean.DeserializeJson(ref reader, options);
          break;

        case "patternInteger":
          PatternInteger = reader.GetInt32();
          break;

        case "_patternInteger":
          _PatternInteger = new fhirCsR2.Models.Element();
          _PatternInteger.DeserializeJson(ref reader, options);
          break;

        case "patternDecimal":
          PatternDecimal = reader.GetDecimal();
          break;

        case "_patternDecimal":
          _PatternDecimal = new fhirCsR2.Models.Element();
          _PatternDecimal.DeserializeJson(ref reader, options);
          break;

        case "patternBase64Binary":
          PatternBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "patternInstant":
          PatternInstant = reader.GetString();
          break;

        case "_patternInstant":
          _PatternInstant = new fhirCsR2.Models.Element();
          _PatternInstant.DeserializeJson(ref reader, options);
          break;

        case "patternString":
          PatternString = reader.GetString();
          break;

        case "_patternString":
          _PatternString = new fhirCsR2.Models.Element();
          _PatternString.DeserializeJson(ref reader, options);
          break;

        case "patternUri":
          PatternUri = reader.GetString();
          break;

        case "_patternUri":
          _PatternUri = new fhirCsR2.Models.Element();
          _PatternUri.DeserializeJson(ref reader, options);
          break;

        case "patternDate":
          PatternDate = reader.GetString();
          break;

        case "_patternDate":
          _PatternDate = new fhirCsR2.Models.Element();
          _PatternDate.DeserializeJson(ref reader, options);
          break;

        case "patternDateTime":
          PatternDateTime = reader.GetString();
          break;

        case "_patternDateTime":
          _PatternDateTime = new fhirCsR2.Models.Element();
          _PatternDateTime.DeserializeJson(ref reader, options);
          break;

        case "patternTime":
          PatternTime = reader.GetString();
          break;

        case "_patternTime":
          _PatternTime = new fhirCsR2.Models.Element();
          _PatternTime.DeserializeJson(ref reader, options);
          break;

        case "patternCode":
          PatternCode = reader.GetString();
          break;

        case "_patternCode":
          _PatternCode = new fhirCsR2.Models.Element();
          _PatternCode.DeserializeJson(ref reader, options);
          break;

        case "patternOid":
          PatternOid = reader.GetString();
          break;

        case "_patternOid":
          _PatternOid = new fhirCsR2.Models.Element();
          _PatternOid.DeserializeJson(ref reader, options);
          break;

        case "patternId":
          PatternId = reader.GetString();
          break;

        case "_patternId":
          _PatternId = new fhirCsR2.Models.Element();
          _PatternId.DeserializeJson(ref reader, options);
          break;

        case "patternUnsignedInt":
          PatternUnsignedInt = reader.GetUInt32();
          break;

        case "patternPositiveInt":
          PatternPositiveInt = reader.GetUInt32();
          break;

        case "patternMarkdown":
          PatternMarkdown = reader.GetString();
          break;

        case "_patternMarkdown":
          _PatternMarkdown = new fhirCsR2.Models.Element();
          _PatternMarkdown.DeserializeJson(ref reader, options);
          break;

        case "patternAnnotation":
          PatternAnnotation = new fhirCsR2.Models.Annotation();
          PatternAnnotation.DeserializeJson(ref reader, options);
          break;

        case "patternAttachment":
          PatternAttachment = new fhirCsR2.Models.Attachment();
          PatternAttachment.DeserializeJson(ref reader, options);
          break;

        case "patternIdentifier":
          PatternIdentifier = new fhirCsR2.Models.Identifier();
          PatternIdentifier.DeserializeJson(ref reader, options);
          break;

        case "patternCodeableConcept":
          PatternCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          PatternCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "patternCoding":
          PatternCoding = new fhirCsR2.Models.Coding();
          PatternCoding.DeserializeJson(ref reader, options);
          break;

        case "patternQuantity":
          PatternQuantity = new fhirCsR2.Models.Quantity();
          PatternQuantity.DeserializeJson(ref reader, options);
          break;

        case "patternRange":
          PatternRange = new fhirCsR2.Models.Range();
          PatternRange.DeserializeJson(ref reader, options);
          break;

        case "patternPeriod":
          PatternPeriod = new fhirCsR2.Models.Period();
          PatternPeriod.DeserializeJson(ref reader, options);
          break;

        case "patternRatio":
          PatternRatio = new fhirCsR2.Models.Ratio();
          PatternRatio.DeserializeJson(ref reader, options);
          break;

        case "patternSampledData":
          PatternSampledData = new fhirCsR2.Models.SampledData();
          PatternSampledData.DeserializeJson(ref reader, options);
          break;

        case "patternSignature":
          PatternSignature = new fhirCsR2.Models.Signature();
          PatternSignature.DeserializeJson(ref reader, options);
          break;

        case "patternHumanName":
          PatternHumanName = new fhirCsR2.Models.HumanName();
          PatternHumanName.DeserializeJson(ref reader, options);
          break;

        case "patternAddress":
          PatternAddress = new fhirCsR2.Models.Address();
          PatternAddress.DeserializeJson(ref reader, options);
          break;

        case "patternContactPoint":
          PatternContactPoint = new fhirCsR2.Models.ContactPoint();
          PatternContactPoint.DeserializeJson(ref reader, options);
          break;

        case "patternTiming":
          PatternTiming = new fhirCsR2.Models.Timing();
          PatternTiming.DeserializeJson(ref reader, options);
          break;

        case "patternReference":
          PatternReference = new fhirCsR2.Models.Reference();
          PatternReference.DeserializeJson(ref reader, options);
          break;

        case "patternMeta":
          PatternMeta = new fhirCsR2.Models.Meta();
          PatternMeta.DeserializeJson(ref reader, options);
          break;

        case "representation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Representation = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Representation.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Representation.Count == 0)
          {
            Representation = null;
          }

          break;

        case "_representation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Representation = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Representation = new fhirCsR2.Models.Element();
            obj_Representation.DeserializeJson(ref reader, options);
            _Representation.Add(obj_Representation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Representation.Count == 0)
          {
            _Representation = null;
          }

          break;

        case "requirements":
          Requirements = reader.GetString();
          break;

        case "_requirements":
          _Requirements = new fhirCsR2.Models.Element();
          _Requirements.DeserializeJson(ref reader, options);
          break;

        case "short":
          Short = reader.GetString();
          break;

        case "_short":
          _Short = new fhirCsR2.Models.Element();
          _Short.DeserializeJson(ref reader, options);
          break;

        case "slicing":
          Slicing = new fhirCsR2.Models.ElementDefinitionSlicing();
          Slicing.DeserializeJson(ref reader, options);
          break;

        case "type":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Type = new List<ElementDefinitionType>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ElementDefinitionType objType = new fhirCsR2.Models.ElementDefinitionType();
            objType.DeserializeJson(ref reader, options);
            Type.Add(objType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Type.Count == 0)
          {
            Type = null;
          }

          break;

        default:
          ((fhirCsR2.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
}
