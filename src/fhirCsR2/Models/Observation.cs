// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ObservationReferenceRange>))]
  public class ObservationReferenceRange : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Some analytes vary greatly over age.
    /// </summary>
    public Range Age { get; set; }
    /// <summary>
    /// The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is &gt;=5 - &lt;=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is &gt;= 2.3).
    /// </summary>
    public Quantity High { get; set; }
    /// <summary>
    /// The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is &gt;=5 - &lt;=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is &lt;=2.3).
    /// </summary>
    public Quantity Low { get; set; }
    /// <summary>
    /// Need to be able to say what kind of reference range this is - normal, recommended, therapeutic, or perhaps what state this reference range applies to (i.e. age, hormonal cycles, etc.).
    /// </summary>
    public CodeableConcept Meaning { get; set; }
    /// <summary>
    /// Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    /// </summary>
    public string Text { get; set; }
    /// <summary>
    /// Extension container element for Text
    /// </summary>
    public Element _Text { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Low != null)
      {
        writer.WritePropertyName("low");
        Low.SerializeJson(writer, options);
      }

      if (High != null)
      {
        writer.WritePropertyName("high");
        High.SerializeJson(writer, options);
      }

      if (Meaning != null)
      {
        writer.WritePropertyName("meaning");
        Meaning.SerializeJson(writer, options);
      }

      if (Age != null)
      {
        writer.WritePropertyName("age");
        Age.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Text))
      {
        writer.WriteString("text", (string)Text!);
      }

      if (_Text != null)
      {
        writer.WritePropertyName("_text");
        _Text.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "age":
          Age = new fhirCsR2.Models.Range();
          Age.DeserializeJson(ref reader, options);
          break;

        case "high":
          High = new fhirCsR2.Models.Quantity();
          High.DeserializeJson(ref reader, options);
          break;

        case "low":
          Low = new fhirCsR2.Models.Quantity();
          Low.DeserializeJson(ref reader, options);
          break;

        case "meaning":
          Meaning = new fhirCsR2.Models.CodeableConcept();
          Meaning.DeserializeJson(ref reader, options);
          break;

        case "text":
          Text = reader.GetString();
          break;

        case "_text":
          _Text = new fhirCsR2.Models.Element();
          _Text.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Normally, an observation will have either a value or a set of related observations. A few observations (e.g. Apgar score) may have both a value and a set of related observations or sometimes QuestionnaireResponse  from which the measure is derived.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ObservationRelated>))]
  public class ObservationRelated : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation.
    /// </summary>
    public Reference Target { get; set; }
    /// <summary>
    /// A relationship type SHOULD be provided.
    /// </summary>
    public string Type { get; set; }
    /// <summary>
    /// Extension container element for Type
    /// </summary>
    public Element _Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Type))
      {
        writer.WriteString("type", (string)Type!);
      }

      if (_Type != null)
      {
        writer.WritePropertyName("_type");
        _Type.SerializeJson(writer, options);
      }

      if (Target != null)
      {
        writer.WritePropertyName("target");
        Target.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "target":
          Target = new fhirCsR2.Models.Reference();
          Target.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = reader.GetString();
          break;

        case "_type":
          _Type = new fhirCsR2.Models.Element();
          _Type.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Observation.related.type field
  /// </summary>
  public static class ObservationRelatedTypeCodes {
    public const string HAS_MEMBER = "has-member";
    public const string DERIVED_FROM = "derived-from";
    public const string SEQUEL_TO = "sequel-to";
    public const string REPLACES = "replaces";
    public const string QUALIFIED_BY = "qualified-by";
    public const string INTERFERED_BY = "interfered-by";
    public static HashSet<string> Values = new HashSet<string>() {
      "has-member",
      "derived-from",
      "sequel-to",
      "replaces",
      "qualified-by",
      "interfered-by",
    };
  }
  /// <summary>
  /// Component observations share the same attributes in the Observation resource as the primary observation and are always treated a part of a single observation (they are not separable).   However, the reference range for the primary observation value is not inherited by the component values and is required when appropriate for each component observation.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ObservationComponent>))]
  public class ObservationComponent : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Knowing what kind of observation is being made is essential to understanding the observation.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// For many results it is necessary to handle exceptional values in measurements.
    /// </summary>
    public CodeableConcept DataAbsentReason { get; set; }
    /// <summary>
    /// Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
    /// </summary>
    public List<ObservationReferenceRange> ReferenceRange { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public string ValueString { get; set; }
    /// <summary>
    /// Extension container element for ValueString
    /// </summary>
    public Element _ValueString { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Ratio ValueRatio { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public SampledData ValueSampledData { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Attachment ValueAttachment { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public string ValueTime { get; set; }
    /// <summary>
    /// Extension container element for ValueTime
    /// </summary>
    public Element _ValueTime { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public string ValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for ValueDateTime
    /// </summary>
    public Element _ValueDateTime { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Period ValuePeriod { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (ValueQuantity != null)
      {
        writer.WritePropertyName("valueQuantity");
        ValueQuantity.SerializeJson(writer, options);
      }

      if (ValueCodeableConcept != null)
      {
        writer.WritePropertyName("valueCodeableConcept");
        ValueCodeableConcept.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueString))
      {
        writer.WriteString("valueString", (string)ValueString!);
      }

      if (_ValueString != null)
      {
        writer.WritePropertyName("_valueString");
        _ValueString.SerializeJson(writer, options);
      }

      if (ValueRange != null)
      {
        writer.WritePropertyName("valueRange");
        ValueRange.SerializeJson(writer, options);
      }

      if (ValueRatio != null)
      {
        writer.WritePropertyName("valueRatio");
        ValueRatio.SerializeJson(writer, options);
      }

      if (ValueSampledData != null)
      {
        writer.WritePropertyName("valueSampledData");
        ValueSampledData.SerializeJson(writer, options);
      }

      if (ValueAttachment != null)
      {
        writer.WritePropertyName("valueAttachment");
        ValueAttachment.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueTime))
      {
        writer.WriteString("valueTime", (string)ValueTime!);
      }

      if (_ValueTime != null)
      {
        writer.WritePropertyName("_valueTime");
        _ValueTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueDateTime))
      {
        writer.WriteString("valueDateTime", (string)ValueDateTime!);
      }

      if (_ValueDateTime != null)
      {
        writer.WritePropertyName("_valueDateTime");
        _ValueDateTime.SerializeJson(writer, options);
      }

      if (ValuePeriod != null)
      {
        writer.WritePropertyName("valuePeriod");
        ValuePeriod.SerializeJson(writer, options);
      }

      if (DataAbsentReason != null)
      {
        writer.WritePropertyName("dataAbsentReason");
        DataAbsentReason.SerializeJson(writer, options);
      }

      if ((ReferenceRange != null) && (ReferenceRange.Count != 0))
      {
        writer.WritePropertyName("referenceRange");
        writer.WriteStartArray();

        foreach (ObservationReferenceRange valReferenceRange in ReferenceRange)
        {
          valReferenceRange.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "dataAbsentReason":
          DataAbsentReason = new fhirCsR2.Models.CodeableConcept();
          DataAbsentReason.DeserializeJson(ref reader, options);
          break;

        case "referenceRange":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ReferenceRange = new List<ObservationReferenceRange>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ObservationReferenceRange objReferenceRange = new fhirCsR2.Models.ObservationReferenceRange();
            objReferenceRange.DeserializeJson(ref reader, options);
            ReferenceRange.Add(objReferenceRange);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ReferenceRange.Count == 0)
          {
            ReferenceRange = null;
          }

          break;

        case "valueQuantity":
          ValueQuantity = new fhirCsR2.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueString":
          ValueString = reader.GetString();
          break;

        case "_valueString":
          _ValueString = new fhirCsR2.Models.Element();
          _ValueString.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new fhirCsR2.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        case "valueRatio":
          ValueRatio = new fhirCsR2.Models.Ratio();
          ValueRatio.DeserializeJson(ref reader, options);
          break;

        case "valueSampledData":
          ValueSampledData = new fhirCsR2.Models.SampledData();
          ValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "valueAttachment":
          ValueAttachment = new fhirCsR2.Models.Attachment();
          ValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "valueTime":
          ValueTime = reader.GetString();
          break;

        case "_valueTime":
          _ValueTime = new fhirCsR2.Models.Element();
          _ValueTime.DeserializeJson(ref reader, options);
          break;

        case "valueDateTime":
          ValueDateTime = reader.GetString();
          break;

        case "_valueDateTime":
          _ValueDateTime = new fhirCsR2.Models.Element();
          _ValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "valuePeriod":
          ValuePeriod = new fhirCsR2.Models.Period();
          ValuePeriod.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Measurements and simple assertions made about a patient, device or other subject.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<Observation>))]
  public class Observation : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Observation";
    /// <summary>
    /// Knowing where the observation is made is important for tracking if multiple sites are possible.
    /// </summary>
    public CodeableConcept BodySite { get; set; }
    /// <summary>
    /// A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes.
    /// </summary>
    public CodeableConcept Category { get; set; }
    /// <summary>
    /// Knowing what kind of observation is being made is essential to understanding the observation.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Need to be able to provide free text additional information.
    /// </summary>
    public string Comments { get; set; }
    /// <summary>
    /// Extension container element for Comments
    /// </summary>
    public Element _Comments { get; set; }
    /// <summary>
    /// Component observations share the same attributes in the Observation resource as the primary observation and are always treated a part of a single observation (they are not separable).   However, the reference range for the primary observation value is not inherited by the component values and is required when appropriate for each component observation.
    /// </summary>
    public List<ObservationComponent> Component { get; set; }
    /// <summary>
    /// For many results it is necessary to handle exceptional values in measurements.
    /// </summary>
    public CodeableConcept DataAbsentReason { get; set; }
    /// <summary>
    /// The device used to generate the observation data.
    /// </summary>
    public Reference Device { get; set; }
    /// <summary>
    /// Knowing when an observation was deemed true is important to its relevance as well as determining trends.
    /// </summary>
    public string EffectiveDateTime { get; set; }
    /// <summary>
    /// Extension container element for EffectiveDateTime
    /// </summary>
    public Element _EffectiveDateTime { get; set; }
    /// <summary>
    /// Knowing when an observation was deemed true is important to its relevance as well as determining trends.
    /// </summary>
    public Period EffectivePeriod { get; set; }
    /// <summary>
    /// For some observations it may be important to know the link between an observation and a particular encounter.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// Allows observations to be distinguished and referenced.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// For some results, particularly numeric results, an interpretation is necessary to fully understand the significance of a result.
    /// </summary>
    public CodeableConcept Interpretation { get; set; }
    /// <summary>
    /// The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
    /// </summary>
    public string Issued { get; set; }
    /// <summary>
    /// Extension container element for Issued
    /// </summary>
    public Element _Issued { get; set; }
    /// <summary>
    /// In some cases, method can impact results and is thus used for determining whether results can be compared or determining significance of results.
    /// </summary>
    public CodeableConcept Method { get; set; }
    /// <summary>
    /// May give a degree of confidence in the observation and also indicates where follow-up questions should be directed.
    /// </summary>
    public List<Reference> Performer { get; set; }
    /// <summary>
    /// Knowing what values are considered "normal" can help evaluate the significance of a particular result. Need to be able to provide multiple reference ranges for different contexts.
    /// </summary>
    public List<ObservationReferenceRange> ReferenceRange { get; set; }
    /// <summary>
    /// Normally, an observation will have either a value or a set of related observations. A few observations (e.g. Apgar score) may have both a value and a set of related observations or sometimes QuestionnaireResponse  from which the measure is derived.
    /// </summary>
    public List<ObservationRelated> Related { get; set; }
    /// <summary>
    /// The specimen that was used when this observation was made.
    /// </summary>
    public Reference Specimen { get; set; }
    /// <summary>
    /// Need to track the status of individual results. Some results are finalized before the whole report is finalized.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Observations have no value if you don't know who or what they're about.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public string ValueString { get; set; }
    /// <summary>
    /// Extension container element for ValueString
    /// </summary>
    public Element _ValueString { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Ratio ValueRatio { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public SampledData ValueSampledData { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Attachment ValueAttachment { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public string ValueTime { get; set; }
    /// <summary>
    /// Extension container element for ValueTime
    /// </summary>
    public Element _ValueTime { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public string ValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for ValueDateTime
    /// </summary>
    public Element _ValueDateTime { get; set; }
    /// <summary>
    /// An observation exists to have a value, though it may not if it is in error, or it represents a group of observations.
    /// </summary>
    public Period ValuePeriod { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Category != null)
      {
        writer.WritePropertyName("category");
        Category.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(EffectiveDateTime))
      {
        writer.WriteString("effectiveDateTime", (string)EffectiveDateTime!);
      }

      if (_EffectiveDateTime != null)
      {
        writer.WritePropertyName("_effectiveDateTime");
        _EffectiveDateTime.SerializeJson(writer, options);
      }

      if (EffectivePeriod != null)
      {
        writer.WritePropertyName("effectivePeriod");
        EffectivePeriod.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Issued))
      {
        writer.WriteString("issued", (string)Issued!);
      }

      if (_Issued != null)
      {
        writer.WritePropertyName("_issued");
        _Issued.SerializeJson(writer, options);
      }

      if ((Performer != null) && (Performer.Count != 0))
      {
        writer.WritePropertyName("performer");
        writer.WriteStartArray();

        foreach (Reference valPerformer in Performer)
        {
          valPerformer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (ValueQuantity != null)
      {
        writer.WritePropertyName("valueQuantity");
        ValueQuantity.SerializeJson(writer, options);
      }

      if (ValueCodeableConcept != null)
      {
        writer.WritePropertyName("valueCodeableConcept");
        ValueCodeableConcept.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueString))
      {
        writer.WriteString("valueString", (string)ValueString!);
      }

      if (_ValueString != null)
      {
        writer.WritePropertyName("_valueString");
        _ValueString.SerializeJson(writer, options);
      }

      if (ValueRange != null)
      {
        writer.WritePropertyName("valueRange");
        ValueRange.SerializeJson(writer, options);
      }

      if (ValueRatio != null)
      {
        writer.WritePropertyName("valueRatio");
        ValueRatio.SerializeJson(writer, options);
      }

      if (ValueSampledData != null)
      {
        writer.WritePropertyName("valueSampledData");
        ValueSampledData.SerializeJson(writer, options);
      }

      if (ValueAttachment != null)
      {
        writer.WritePropertyName("valueAttachment");
        ValueAttachment.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueTime))
      {
        writer.WriteString("valueTime", (string)ValueTime!);
      }

      if (_ValueTime != null)
      {
        writer.WritePropertyName("_valueTime");
        _ValueTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueDateTime))
      {
        writer.WriteString("valueDateTime", (string)ValueDateTime!);
      }

      if (_ValueDateTime != null)
      {
        writer.WritePropertyName("_valueDateTime");
        _ValueDateTime.SerializeJson(writer, options);
      }

      if (ValuePeriod != null)
      {
        writer.WritePropertyName("valuePeriod");
        ValuePeriod.SerializeJson(writer, options);
      }

      if (DataAbsentReason != null)
      {
        writer.WritePropertyName("dataAbsentReason");
        DataAbsentReason.SerializeJson(writer, options);
      }

      if (Interpretation != null)
      {
        writer.WritePropertyName("interpretation");
        Interpretation.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comments))
      {
        writer.WriteString("comments", (string)Comments!);
      }

      if (_Comments != null)
      {
        writer.WritePropertyName("_comments");
        _Comments.SerializeJson(writer, options);
      }

      if (BodySite != null)
      {
        writer.WritePropertyName("bodySite");
        BodySite.SerializeJson(writer, options);
      }

      if (Method != null)
      {
        writer.WritePropertyName("method");
        Method.SerializeJson(writer, options);
      }

      if (Specimen != null)
      {
        writer.WritePropertyName("specimen");
        Specimen.SerializeJson(writer, options);
      }

      if (Device != null)
      {
        writer.WritePropertyName("device");
        Device.SerializeJson(writer, options);
      }

      if ((ReferenceRange != null) && (ReferenceRange.Count != 0))
      {
        writer.WritePropertyName("referenceRange");
        writer.WriteStartArray();

        foreach (ObservationReferenceRange valReferenceRange in ReferenceRange)
        {
          valReferenceRange.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Related != null) && (Related.Count != 0))
      {
        writer.WritePropertyName("related");
        writer.WriteStartArray();

        foreach (ObservationRelated valRelated in Related)
        {
          valRelated.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Component != null) && (Component.Count != 0))
      {
        writer.WritePropertyName("component");
        writer.WriteStartArray();

        foreach (ObservationComponent valComponent in Component)
        {
          valComponent.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "bodySite":
          BodySite = new fhirCsR2.Models.CodeableConcept();
          BodySite.DeserializeJson(ref reader, options);
          break;

        case "category":
          Category = new fhirCsR2.Models.CodeableConcept();
          Category.DeserializeJson(ref reader, options);
          break;

        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "comments":
          Comments = reader.GetString();
          break;

        case "_comments":
          _Comments = new fhirCsR2.Models.Element();
          _Comments.DeserializeJson(ref reader, options);
          break;

        case "component":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Component = new List<ObservationComponent>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ObservationComponent objComponent = new fhirCsR2.Models.ObservationComponent();
            objComponent.DeserializeJson(ref reader, options);
            Component.Add(objComponent);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Component.Count == 0)
          {
            Component = null;
          }

          break;

        case "dataAbsentReason":
          DataAbsentReason = new fhirCsR2.Models.CodeableConcept();
          DataAbsentReason.DeserializeJson(ref reader, options);
          break;

        case "device":
          Device = new fhirCsR2.Models.Reference();
          Device.DeserializeJson(ref reader, options);
          break;

        case "effectiveDateTime":
          EffectiveDateTime = reader.GetString();
          break;

        case "_effectiveDateTime":
          _EffectiveDateTime = new fhirCsR2.Models.Element();
          _EffectiveDateTime.DeserializeJson(ref reader, options);
          break;

        case "effectivePeriod":
          EffectivePeriod = new fhirCsR2.Models.Period();
          EffectivePeriod.DeserializeJson(ref reader, options);
          break;

        case "encounter":
          Encounter = new fhirCsR2.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "interpretation":
          Interpretation = new fhirCsR2.Models.CodeableConcept();
          Interpretation.DeserializeJson(ref reader, options);
          break;

        case "issued":
          Issued = reader.GetString();
          break;

        case "_issued":
          _Issued = new fhirCsR2.Models.Element();
          _Issued.DeserializeJson(ref reader, options);
          break;

        case "method":
          Method = new fhirCsR2.Models.CodeableConcept();
          Method.DeserializeJson(ref reader, options);
          break;

        case "performer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Performer = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objPerformer = new fhirCsR2.Models.Reference();
            objPerformer.DeserializeJson(ref reader, options);
            Performer.Add(objPerformer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Performer.Count == 0)
          {
            Performer = null;
          }

          break;

        case "referenceRange":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ReferenceRange = new List<ObservationReferenceRange>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ObservationReferenceRange objReferenceRange = new fhirCsR2.Models.ObservationReferenceRange();
            objReferenceRange.DeserializeJson(ref reader, options);
            ReferenceRange.Add(objReferenceRange);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ReferenceRange.Count == 0)
          {
            ReferenceRange = null;
          }

          break;

        case "related":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Related = new List<ObservationRelated>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ObservationRelated objRelated = new fhirCsR2.Models.ObservationRelated();
            objRelated.DeserializeJson(ref reader, options);
            Related.Add(objRelated);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Related.Count == 0)
          {
            Related = null;
          }

          break;

        case "specimen":
          Specimen = new fhirCsR2.Models.Reference();
          Specimen.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR2.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR2.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "valueQuantity":
          ValueQuantity = new fhirCsR2.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueString":
          ValueString = reader.GetString();
          break;

        case "_valueString":
          _ValueString = new fhirCsR2.Models.Element();
          _ValueString.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new fhirCsR2.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        case "valueRatio":
          ValueRatio = new fhirCsR2.Models.Ratio();
          ValueRatio.DeserializeJson(ref reader, options);
          break;

        case "valueSampledData":
          ValueSampledData = new fhirCsR2.Models.SampledData();
          ValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "valueAttachment":
          ValueAttachment = new fhirCsR2.Models.Attachment();
          ValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "valueTime":
          ValueTime = reader.GetString();
          break;

        case "_valueTime":
          _ValueTime = new fhirCsR2.Models.Element();
          _ValueTime.DeserializeJson(ref reader, options);
          break;

        case "valueDateTime":
          ValueDateTime = reader.GetString();
          break;

        case "_valueDateTime":
          _ValueDateTime = new fhirCsR2.Models.Element();
          _ValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "valuePeriod":
          ValuePeriod = new fhirCsR2.Models.Period();
          ValuePeriod.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Observation.status field
  /// </summary>
  public static class ObservationStatusCodes {
    public const string REGISTERED = "registered";
    public const string PRELIMINARY = "preliminary";
    public const string FINAL = "final";
    public const string AMENDED = "amended";
    public const string CANCELLED = "cancelled";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "registered",
      "preliminary",
      "final",
      "amended",
      "cancelled",
      "entered-in-error",
      "unknown",
    };
  }
}
