// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Limited to 'real' people rather than equipment.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ProcedurePerformer>))]
  public class ProcedurePerformer : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The practitioner who was involved in the procedure.
    /// </summary>
    public Reference Actor { get; set; }
    /// <summary>
    /// For example: surgeon, anaethetist, endoscopist.
    /// </summary>
    public CodeableConcept Role { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Actor != null)
      {
        writer.WritePropertyName("actor");
        Actor.SerializeJson(writer, options);
      }

      if (Role != null)
      {
        writer.WritePropertyName("role");
        Role.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actor":
          Actor = new fhirCsR2.Models.Reference();
          Actor.DeserializeJson(ref reader, options);
          break;

        case "role":
          Role = new fhirCsR2.Models.CodeableConcept();
          Role.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ProcedureFocalDevice>))]
  public class ProcedureFocalDevice : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The kind of change that happened to the device during the procedure.
    /// </summary>
    public CodeableConcept Action { get; set; }
    /// <summary>
    /// The device that was manipulated (changed) during the procedure.
    /// </summary>
    public Reference Manipulated { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Action != null)
      {
        writer.WritePropertyName("action");
        Action.SerializeJson(writer, options);
      }

      if (Manipulated != null)
      {
        writer.WritePropertyName("manipulated");
        Manipulated.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "action":
          Action = new fhirCsR2.Models.CodeableConcept();
          Action.DeserializeJson(ref reader, options);
          break;

        case "manipulated":
          Manipulated = new fhirCsR2.Models.Reference();
          Manipulated.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<Procedure>))]
  public class Procedure : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Procedure";
    /// <summary>
    /// Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
    /// </summary>
    public List<CodeableConcept> BodySite { get; set; }
    /// <summary>
    /// A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    /// </summary>
    public CodeableConcept Category { get; set; }
    /// <summary>
    /// The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Any complications that occurred during the procedure, or in the immediate post-performance period. These are generally tracked separately from the notes, which will typically describe the procedure itself rather than any 'post procedure' issues.
    /// </summary>
    public List<CodeableConcept> Complication { get; set; }
    /// <summary>
    /// The encounter during which the procedure was performed.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
    /// </summary>
    public List<ProcedureFocalDevice> FocalDevice { get; set; }
    /// <summary>
    /// If the procedure required specific follow up - e.g. removal of sutures. The followup may be represented as a simple note, or could potentially be more complex in which case the CarePlan resource can be used.
    /// </summary>
    public List<CodeableConcept> FollowUp { get; set; }
    /// <summary>
    /// Need to allow connection to a wider workflow.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Ties a procedure to where the records are likely kept.
    /// </summary>
    public Reference Location { get; set; }
    /// <summary>
    /// Any other notes about the procedure.  E.g. the operative notes.
    /// </summary>
    public List<Annotation> Notes { get; set; }
    /// <summary>
    /// Set this to true if the record is saying that the procedure was NOT performed.
    /// </summary>
    public bool? NotPerformed { get; set; }
    /// <summary>
    /// Extension container element for NotPerformed
    /// </summary>
    public Element _NotPerformed { get; set; }
    /// <summary>
    /// The outcome of the procedure - did it resolve reasons for the procedure being performed?
    /// </summary>
    public CodeableConcept Outcome { get; set; }
    /// <summary>
    /// The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    /// </summary>
    public string PerformedDateTime { get; set; }
    /// <summary>
    /// Extension container element for PerformedDateTime
    /// </summary>
    public Element _PerformedDateTime { get; set; }
    /// <summary>
    /// The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    /// </summary>
    public Period PerformedPeriod { get; set; }
    /// <summary>
    /// Limited to 'real' people rather than equipment.
    /// </summary>
    public List<ProcedurePerformer> Performer { get; set; }
    /// <summary>
    /// The reason why the procedure was performed. This may be due to a Condition, may be coded entity of some type, or may simply be present as text.
    /// </summary>
    public CodeableConcept ReasonCodeableConcept { get; set; }
    /// <summary>
    /// The reason why the procedure was performed. This may be due to a Condition, may be coded entity of some type, or may simply be present as text.
    /// </summary>
    public Reference ReasonReference { get; set; }
    /// <summary>
    /// A code indicating why the procedure was not performed.
    /// </summary>
    public List<CodeableConcept> ReasonNotPerformed { get; set; }
    /// <summary>
    /// This could be a histology result, pathology report, surgical report, etc..
    /// </summary>
    public List<Reference> Report { get; set; }
    /// <summary>
    /// A reference to a resource that contains details of the request for this procedure.
    /// </summary>
    public Reference Request { get; set; }
    /// <summary>
    /// A code specifying the state of the procedure. Generally this will be in-progress or completed state.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// The person, animal or group on which the procedure was performed.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// Used for tracking contamination, etc.
    /// </summary>
    public List<Reference> Used { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Category != null)
      {
        writer.WritePropertyName("category");
        Category.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (NotPerformed != null)
      {
        writer.WriteBoolean("notPerformed", (bool)NotPerformed!);
      }

      if (_NotPerformed != null)
      {
        writer.WritePropertyName("_notPerformed");
        _NotPerformed.SerializeJson(writer, options);
      }

      if ((ReasonNotPerformed != null) && (ReasonNotPerformed.Count != 0))
      {
        writer.WritePropertyName("reasonNotPerformed");
        writer.WriteStartArray();

        foreach (CodeableConcept valReasonNotPerformed in ReasonNotPerformed)
        {
          valReasonNotPerformed.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BodySite != null) && (BodySite.Count != 0))
      {
        writer.WritePropertyName("bodySite");
        writer.WriteStartArray();

        foreach (CodeableConcept valBodySite in BodySite)
        {
          valBodySite.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (ReasonCodeableConcept != null)
      {
        writer.WritePropertyName("reasonCodeableConcept");
        ReasonCodeableConcept.SerializeJson(writer, options);
      }

      if (ReasonReference != null)
      {
        writer.WritePropertyName("reasonReference");
        ReasonReference.SerializeJson(writer, options);
      }

      if ((Performer != null) && (Performer.Count != 0))
      {
        writer.WritePropertyName("performer");
        writer.WriteStartArray();

        foreach (ProcedurePerformer valPerformer in Performer)
        {
          valPerformer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(PerformedDateTime))
      {
        writer.WriteString("performedDateTime", (string)PerformedDateTime!);
      }

      if (_PerformedDateTime != null)
      {
        writer.WritePropertyName("_performedDateTime");
        _PerformedDateTime.SerializeJson(writer, options);
      }

      if (PerformedPeriod != null)
      {
        writer.WritePropertyName("performedPeriod");
        PerformedPeriod.SerializeJson(writer, options);
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(writer, options);
      }

      if (Location != null)
      {
        writer.WritePropertyName("location");
        Location.SerializeJson(writer, options);
      }

      if (Outcome != null)
      {
        writer.WritePropertyName("outcome");
        Outcome.SerializeJson(writer, options);
      }

      if ((Report != null) && (Report.Count != 0))
      {
        writer.WritePropertyName("report");
        writer.WriteStartArray();

        foreach (Reference valReport in Report)
        {
          valReport.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Complication != null) && (Complication.Count != 0))
      {
        writer.WritePropertyName("complication");
        writer.WriteStartArray();

        foreach (CodeableConcept valComplication in Complication)
        {
          valComplication.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((FollowUp != null) && (FollowUp.Count != 0))
      {
        writer.WritePropertyName("followUp");
        writer.WriteStartArray();

        foreach (CodeableConcept valFollowUp in FollowUp)
        {
          valFollowUp.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Request != null)
      {
        writer.WritePropertyName("request");
        Request.SerializeJson(writer, options);
      }

      if ((Notes != null) && (Notes.Count != 0))
      {
        writer.WritePropertyName("notes");
        writer.WriteStartArray();

        foreach (Annotation valNotes in Notes)
        {
          valNotes.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((FocalDevice != null) && (FocalDevice.Count != 0))
      {
        writer.WritePropertyName("focalDevice");
        writer.WriteStartArray();

        foreach (ProcedureFocalDevice valFocalDevice in FocalDevice)
        {
          valFocalDevice.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Used != null) && (Used.Count != 0))
      {
        writer.WritePropertyName("used");
        writer.WriteStartArray();

        foreach (Reference valUsed in Used)
        {
          valUsed.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "bodySite":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BodySite = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objBodySite = new fhirCsR2.Models.CodeableConcept();
            objBodySite.DeserializeJson(ref reader, options);
            BodySite.Add(objBodySite);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BodySite.Count == 0)
          {
            BodySite = null;
          }

          break;

        case "category":
          Category = new fhirCsR2.Models.CodeableConcept();
          Category.DeserializeJson(ref reader, options);
          break;

        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "complication":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Complication = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objComplication = new fhirCsR2.Models.CodeableConcept();
            objComplication.DeserializeJson(ref reader, options);
            Complication.Add(objComplication);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Complication.Count == 0)
          {
            Complication = null;
          }

          break;

        case "encounter":
          Encounter = new fhirCsR2.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "focalDevice":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          FocalDevice = new List<ProcedureFocalDevice>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ProcedureFocalDevice objFocalDevice = new fhirCsR2.Models.ProcedureFocalDevice();
            objFocalDevice.DeserializeJson(ref reader, options);
            FocalDevice.Add(objFocalDevice);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (FocalDevice.Count == 0)
          {
            FocalDevice = null;
          }

          break;

        case "followUp":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          FollowUp = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objFollowUp = new fhirCsR2.Models.CodeableConcept();
            objFollowUp.DeserializeJson(ref reader, options);
            FollowUp.Add(objFollowUp);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (FollowUp.Count == 0)
          {
            FollowUp = null;
          }

          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "location":
          Location = new fhirCsR2.Models.Reference();
          Location.DeserializeJson(ref reader, options);
          break;

        case "notes":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Notes = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Annotation objNotes = new fhirCsR2.Models.Annotation();
            objNotes.DeserializeJson(ref reader, options);
            Notes.Add(objNotes);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Notes.Count == 0)
          {
            Notes = null;
          }

          break;

        case "notPerformed":
          NotPerformed = reader.GetBoolean();
          break;

        case "_notPerformed":
          _NotPerformed = new fhirCsR2.Models.Element();
          _NotPerformed.DeserializeJson(ref reader, options);
          break;

        case "outcome":
          Outcome = new fhirCsR2.Models.CodeableConcept();
          Outcome.DeserializeJson(ref reader, options);
          break;

        case "performedDateTime":
          PerformedDateTime = reader.GetString();
          break;

        case "_performedDateTime":
          _PerformedDateTime = new fhirCsR2.Models.Element();
          _PerformedDateTime.DeserializeJson(ref reader, options);
          break;

        case "performedPeriod":
          PerformedPeriod = new fhirCsR2.Models.Period();
          PerformedPeriod.DeserializeJson(ref reader, options);
          break;

        case "performer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Performer = new List<ProcedurePerformer>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ProcedurePerformer objPerformer = new fhirCsR2.Models.ProcedurePerformer();
            objPerformer.DeserializeJson(ref reader, options);
            Performer.Add(objPerformer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Performer.Count == 0)
          {
            Performer = null;
          }

          break;

        case "reasonCodeableConcept":
          ReasonCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          ReasonCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "reasonReference":
          ReasonReference = new fhirCsR2.Models.Reference();
          ReasonReference.DeserializeJson(ref reader, options);
          break;

        case "reasonNotPerformed":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ReasonNotPerformed = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objReasonNotPerformed = new fhirCsR2.Models.CodeableConcept();
            objReasonNotPerformed.DeserializeJson(ref reader, options);
            ReasonNotPerformed.Add(objReasonNotPerformed);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ReasonNotPerformed.Count == 0)
          {
            ReasonNotPerformed = null;
          }

          break;

        case "report":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Report = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objReport = new fhirCsR2.Models.Reference();
            objReport.DeserializeJson(ref reader, options);
            Report.Add(objReport);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Report.Count == 0)
          {
            Report = null;
          }

          break;

        case "request":
          Request = new fhirCsR2.Models.Reference();
          Request.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR2.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR2.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "used":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Used = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objUsed = new fhirCsR2.Models.Reference();
            objUsed.DeserializeJson(ref reader, options);
            Used.Add(objUsed);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Used.Count == 0)
          {
            Used = null;
          }

          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Procedure.status field
  /// </summary>
  public static class ProcedureStatusCodes {
    public const string IN_PROGRESS = "in-progress";
    public const string ABORTED = "aborted";
    public const string COMPLETED = "completed";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public static HashSet<string> Values = new HashSet<string>() {
      "in-progress",
      "aborted",
      "completed",
      "entered-in-error",
    };
  }
}
