// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Details concerning the specimen collection.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<SpecimenCollection>))]
  public class SpecimenCollection : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
    /// </summary>
    public CodeableConcept BodySite { get; set; }
    /// <summary>
    /// Time when specimen was collected from subject - the physiologically relevant time.
    /// </summary>
    public string CollectedDateTime { get; set; }
    /// <summary>
    /// Extension container element for CollectedDateTime
    /// </summary>
    public Element _CollectedDateTime { get; set; }
    /// <summary>
    /// Time when specimen was collected from subject - the physiologically relevant time.
    /// </summary>
    public Period CollectedPeriod { get; set; }
    /// <summary>
    /// Person who collected the specimen.
    /// </summary>
    public Reference Collector { get; set; }
    /// <summary>
    /// To communicate any details or issues encountered during the specimen collection procedure.
    /// </summary>
    public List<string> Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public List<Element> _Comment { get; set; }
    /// <summary>
    /// A coded value specifying the technique that is used to perform the procedure.
    /// </summary>
    public CodeableConcept Method { get; set; }
    /// <summary>
    /// The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    /// </summary>
    public Quantity Quantity { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Collector != null)
      {
        writer.WritePropertyName("collector");
        Collector.SerializeJson(writer, options);
      }

      if ((Comment != null) && (Comment.Count != 0))
      {
        writer.WritePropertyName("comment");
        writer.WriteStartArray();

        foreach (string valComment in Comment)
        {
          writer.WriteStringValue(valComment);
        }

        writer.WriteEndArray();
      }

      if ((_Comment != null) && (_Comment.Count != 0))
      {
        writer.WritePropertyName("_comment");
        writer.WriteStartArray();

        foreach (Element val_Comment in _Comment)
        {
          val_Comment.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(CollectedDateTime))
      {
        writer.WriteString("collectedDateTime", (string)CollectedDateTime!);
      }

      if (_CollectedDateTime != null)
      {
        writer.WritePropertyName("_collectedDateTime");
        _CollectedDateTime.SerializeJson(writer, options);
      }

      if (CollectedPeriod != null)
      {
        writer.WritePropertyName("collectedPeriod");
        CollectedPeriod.SerializeJson(writer, options);
      }

      if (Quantity != null)
      {
        writer.WritePropertyName("quantity");
        Quantity.SerializeJson(writer, options);
      }

      if (Method != null)
      {
        writer.WritePropertyName("method");
        Method.SerializeJson(writer, options);
      }

      if (BodySite != null)
      {
        writer.WritePropertyName("bodySite");
        BodySite.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "bodySite":
          BodySite = new fhirCsR2.Models.CodeableConcept();
          BodySite.DeserializeJson(ref reader, options);
          break;

        case "collectedDateTime":
          CollectedDateTime = reader.GetString();
          break;

        case "_collectedDateTime":
          _CollectedDateTime = new fhirCsR2.Models.Element();
          _CollectedDateTime.DeserializeJson(ref reader, options);
          break;

        case "collectedPeriod":
          CollectedPeriod = new fhirCsR2.Models.Period();
          CollectedPeriod.DeserializeJson(ref reader, options);
          break;

        case "collector":
          Collector = new fhirCsR2.Models.Reference();
          Collector.DeserializeJson(ref reader, options);
          break;

        case "comment":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Comment = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Comment.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Comment.Count == 0)
          {
            Comment = null;
          }

          break;

        case "_comment":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Comment = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Element obj_Comment = new fhirCsR2.Models.Element();
            obj_Comment.DeserializeJson(ref reader, options);
            _Comment.Add(obj_Comment);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Comment.Count == 0)
          {
            _Comment = null;
          }

          break;

        case "method":
          Method = new fhirCsR2.Models.CodeableConcept();
          Method.DeserializeJson(ref reader, options);
          break;

        case "quantity":
          Quantity = new fhirCsR2.Models.Quantity();
          Quantity.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Details concerning treatment and processing steps for the specimen.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<SpecimenTreatment>))]
  public class SpecimenTreatment : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Material used in the processing step.
    /// </summary>
    public List<Reference> Additive { get; set; }
    /// <summary>
    /// Textual description of procedure.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// A coded value specifying the procedure used to process the specimen.
    /// </summary>
    public CodeableConcept Procedure { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (Procedure != null)
      {
        writer.WritePropertyName("procedure");
        Procedure.SerializeJson(writer, options);
      }

      if ((Additive != null) && (Additive.Count != 0))
      {
        writer.WritePropertyName("additive");
        writer.WriteStartArray();

        foreach (Reference valAdditive in Additive)
        {
          valAdditive.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "additive":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Additive = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objAdditive = new fhirCsR2.Models.Reference();
            objAdditive.DeserializeJson(ref reader, options);
            Additive.Add(objAdditive);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Additive.Count == 0)
          {
            Additive = null;
          }

          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "procedure":
          Procedure = new fhirCsR2.Models.CodeableConcept();
          Procedure.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<SpecimenContainer>))]
  public class SpecimenContainer : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    /// </summary>
    public CodeableConcept AdditiveCodeableConcept { get; set; }
    /// <summary>
    /// Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    /// </summary>
    public Reference AdditiveReference { get; set; }
    /// <summary>
    /// The capacity (volume or other measure) the container may contain.
    /// </summary>
    public Quantity Capacity { get; set; }
    /// <summary>
    /// Textual description of the container.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    /// </summary>
    public Quantity SpecimenQuantity { get; set; }
    /// <summary>
    /// The type of container associated with the specimen (e.g. slide, aliquot, etc.).
    /// </summary>
    public CodeableConcept Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (Type != null)
      {
        writer.WritePropertyName("type");
        Type.SerializeJson(writer, options);
      }

      if (Capacity != null)
      {
        writer.WritePropertyName("capacity");
        Capacity.SerializeJson(writer, options);
      }

      if (SpecimenQuantity != null)
      {
        writer.WritePropertyName("specimenQuantity");
        SpecimenQuantity.SerializeJson(writer, options);
      }

      if (AdditiveCodeableConcept != null)
      {
        writer.WritePropertyName("additiveCodeableConcept");
        AdditiveCodeableConcept.SerializeJson(writer, options);
      }

      if (AdditiveReference != null)
      {
        writer.WritePropertyName("additiveReference");
        AdditiveReference.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "additiveCodeableConcept":
          AdditiveCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          AdditiveCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "additiveReference":
          AdditiveReference = new fhirCsR2.Models.Reference();
          AdditiveReference.DeserializeJson(ref reader, options);
          break;

        case "capacity":
          Capacity = new fhirCsR2.Models.Quantity();
          Capacity.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "specimenQuantity":
          SpecimenQuantity = new fhirCsR2.Models.Quantity();
          SpecimenQuantity.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = new fhirCsR2.Models.CodeableConcept();
          Type.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A sample to be used for analysis.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<Specimen>))]
  public class Specimen : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Specimen";
    /// <summary>
    /// The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
    /// </summary>
    public Identifier AccessionIdentifier { get; set; }
    /// <summary>
    /// Details concerning the specimen collection.
    /// </summary>
    public SpecimenCollection Collection { get; set; }
    /// <summary>
    /// The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
    /// </summary>
    public List<SpecimenContainer> Container { get; set; }
    /// <summary>
    /// Id for specimen.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
    /// </summary>
    public List<Reference> Parent { get; set; }
    /// <summary>
    /// Time when specimen was received for processing or testing.
    /// </summary>
    public string ReceivedTime { get; set; }
    /// <summary>
    /// Extension container element for ReceivedTime
    /// </summary>
    public Element _ReceivedTime { get; set; }
    /// <summary>
    /// The availability of the specimen.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Must know the subject context.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// Details concerning treatment and processing steps for the specimen.
    /// </summary>
    public List<SpecimenTreatment> Treatment { get; set; }
    /// <summary>
    /// The kind of material that forms the specimen.
    /// </summary>
    public CodeableConcept Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Type != null)
      {
        writer.WritePropertyName("type");
        Type.SerializeJson(writer, options);
      }

      if ((Parent != null) && (Parent.Count != 0))
      {
        writer.WritePropertyName("parent");
        writer.WriteStartArray();

        foreach (Reference valParent in Parent)
        {
          valParent.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (AccessionIdentifier != null)
      {
        writer.WritePropertyName("accessionIdentifier");
        AccessionIdentifier.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ReceivedTime))
      {
        writer.WriteString("receivedTime", (string)ReceivedTime!);
      }

      if (_ReceivedTime != null)
      {
        writer.WritePropertyName("_receivedTime");
        _ReceivedTime.SerializeJson(writer, options);
      }

      if (Collection != null)
      {
        writer.WritePropertyName("collection");
        Collection.SerializeJson(writer, options);
      }

      if ((Treatment != null) && (Treatment.Count != 0))
      {
        writer.WritePropertyName("treatment");
        writer.WriteStartArray();

        foreach (SpecimenTreatment valTreatment in Treatment)
        {
          valTreatment.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Container != null) && (Container.Count != 0))
      {
        writer.WritePropertyName("container");
        writer.WriteStartArray();

        foreach (SpecimenContainer valContainer in Container)
        {
          valContainer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "accessionIdentifier":
          AccessionIdentifier = new fhirCsR2.Models.Identifier();
          AccessionIdentifier.DeserializeJson(ref reader, options);
          break;

        case "collection":
          Collection = new fhirCsR2.Models.SpecimenCollection();
          Collection.DeserializeJson(ref reader, options);
          break;

        case "container":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Container = new List<SpecimenContainer>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.SpecimenContainer objContainer = new fhirCsR2.Models.SpecimenContainer();
            objContainer.DeserializeJson(ref reader, options);
            Container.Add(objContainer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Container.Count == 0)
          {
            Container = null;
          }

          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "parent":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Parent = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objParent = new fhirCsR2.Models.Reference();
            objParent.DeserializeJson(ref reader, options);
            Parent.Add(objParent);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Parent.Count == 0)
          {
            Parent = null;
          }

          break;

        case "receivedTime":
          ReceivedTime = reader.GetString();
          break;

        case "_receivedTime":
          _ReceivedTime = new fhirCsR2.Models.Element();
          _ReceivedTime.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR2.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR2.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "treatment":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Treatment = new List<SpecimenTreatment>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.SpecimenTreatment objTreatment = new fhirCsR2.Models.SpecimenTreatment();
            objTreatment.DeserializeJson(ref reader, options);
            Treatment.Add(objTreatment);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Treatment.Count == 0)
          {
            Treatment = null;
          }

          break;

        case "type":
          Type = new fhirCsR2.Models.CodeableConcept();
          Type.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Specimen.status field
  /// </summary>
  public static class SpecimenStatusCodes {
    public const string AVAILABLE = "available";
    public const string UNAVAILABLE = "unavailable";
    public const string UNSATISFACTORY = "unsatisfactory";
    public const string ENTERED_IN_ERROR = "entered-in-error";
  }
}
