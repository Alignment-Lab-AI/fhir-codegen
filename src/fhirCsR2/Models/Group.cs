// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Needs to be a generic mechanism for identifying what individuals can be part of a group.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<GroupCharacteristic>))]
  public class GroupCharacteristic : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Need a formal way of identifying the characteristic being described.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Sometimes group membership is determined by characteristics not possessed.
    /// </summary>
    public bool Exclude { get; set; }
    /// <summary>
    /// Extension container element for Exclude
    /// </summary>
    public Element _Exclude { get; set; }
    /// <summary>
    /// The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// The value of the characteristic is what determines group membership.
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// The value of the characteristic is what determines group membership.
    /// </summary>
    public bool? ValueBoolean { get; set; }
    /// <summary>
    /// Extension container element for ValueBoolean
    /// </summary>
    public Element _ValueBoolean { get; set; }
    /// <summary>
    /// The value of the characteristic is what determines group membership.
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// The value of the characteristic is what determines group membership.
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (ValueCodeableConcept != null)
      {
        writer.WritePropertyName("valueCodeableConcept");
        ValueCodeableConcept.SerializeJson(writer, options);
      }

      if (ValueBoolean != null)
      {
        writer.WriteBoolean("valueBoolean", (bool)ValueBoolean!);
      }

      if (_ValueBoolean != null)
      {
        writer.WritePropertyName("_valueBoolean");
        _ValueBoolean.SerializeJson(writer, options);
      }

      if (ValueQuantity != null)
      {
        writer.WritePropertyName("valueQuantity");
        ValueQuantity.SerializeJson(writer, options);
      }

      if (ValueRange != null)
      {
        writer.WritePropertyName("valueRange");
        ValueRange.SerializeJson(writer, options);
      }

      writer.WriteBoolean("exclude", Exclude);

      if (_Exclude != null)
      {
        writer.WritePropertyName("_exclude");
        _Exclude.SerializeJson(writer, options);
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "exclude":
          Exclude = reader.GetBoolean();
          break;

        case "_exclude":
          _Exclude = new fhirCsR2.Models.Element();
          _Exclude.DeserializeJson(ref reader, options);
          break;

        case "period":
          Period = new fhirCsR2.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueBoolean":
          ValueBoolean = reader.GetBoolean();
          break;

        case "_valueBoolean":
          _ValueBoolean = new fhirCsR2.Models.Element();
          _ValueBoolean.DeserializeJson(ref reader, options);
          break;

        case "valueQuantity":
          ValueQuantity = new fhirCsR2.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new fhirCsR2.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Often the only thing of interest about a group is "who's in it".
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<GroupMember>))]
  public class GroupMember : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A reference to the entity that is a member of the group. Must be consistent with Group.type.
    /// </summary>
    public Reference Entity { get; set; }
    /// <summary>
    /// Sometimes you don't know when someone stopped being in a group, but not when.
    /// </summary>
    public bool? Inactive { get; set; }
    /// <summary>
    /// Extension container element for Inactive
    /// </summary>
    public Element _Inactive { get; set; }
    /// <summary>
    /// Need to track who was in a group at a  particular time.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Entity != null)
      {
        writer.WritePropertyName("entity");
        Entity.SerializeJson(writer, options);
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (Inactive != null)
      {
        writer.WriteBoolean("inactive", (bool)Inactive!);
      }

      if (_Inactive != null)
      {
        writer.WritePropertyName("_inactive");
        _Inactive.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "entity":
          Entity = new fhirCsR2.Models.Reference();
          Entity.DeserializeJson(ref reader, options);
          break;

        case "inactive":
          Inactive = reader.GetBoolean();
          break;

        case "_inactive":
          _Inactive = new fhirCsR2.Models.Element();
          _Inactive.DeserializeJson(ref reader, options);
          break;

        case "period":
          Period = new fhirCsR2.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<Group>))]
  public class Group : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Group";
    /// <summary>
    /// There are use-cases for groups that define specific collections of individuals, and other groups that define "types" of intended individuals.  The requirements for both kinds of groups are similar, so we use a single resource, distinguished by this flag.
    /// </summary>
    public bool Actual { get; set; }
    /// <summary>
    /// Extension container element for Actual
    /// </summary>
    public Element _Actual { get; set; }
    /// <summary>
    /// Needs to be a generic mechanism for identifying what individuals can be part of a group.
    /// </summary>
    public List<GroupCharacteristic> Characteristic { get; set; }
    /// <summary>
    /// Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Allows the group to be referenced from external specifications.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Often the only thing of interest about a group is "who's in it".
    /// </summary>
    public List<GroupMember> Member { get; set; }
    /// <summary>
    /// Used to identify the group in human communication.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Group size is a common defining characteristic.
    /// </summary>
    public uint? Quantity { get; set; }
    /// <summary>
    /// Identifies what type of resources the group is made up of.
    /// </summary>
    public string Type { get; set; }
    /// <summary>
    /// Extension container element for Type
    /// </summary>
    public Element _Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Type))
      {
        writer.WriteString("type", (string)Type!);
      }

      if (_Type != null)
      {
        writer.WritePropertyName("_type");
        _Type.SerializeJson(writer, options);
      }

      writer.WriteBoolean("actual", Actual);

      if (_Actual != null)
      {
        writer.WritePropertyName("_actual");
        _Actual.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (Quantity != null)
      {
        writer.WriteNumber("quantity", (uint)Quantity!);
      }

      if ((Characteristic != null) && (Characteristic.Count != 0))
      {
        writer.WritePropertyName("characteristic");
        writer.WriteStartArray();

        foreach (GroupCharacteristic valCharacteristic in Characteristic)
        {
          valCharacteristic.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Member != null) && (Member.Count != 0))
      {
        writer.WritePropertyName("member");
        writer.WriteStartArray();

        foreach (GroupMember valMember in Member)
        {
          valMember.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actual":
          Actual = reader.GetBoolean();
          break;

        case "_actual":
          _Actual = new fhirCsR2.Models.Element();
          _Actual.DeserializeJson(ref reader, options);
          break;

        case "characteristic":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Characteristic = new List<GroupCharacteristic>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.GroupCharacteristic objCharacteristic = new fhirCsR2.Models.GroupCharacteristic();
            objCharacteristic.DeserializeJson(ref reader, options);
            Characteristic.Add(objCharacteristic);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Characteristic.Count == 0)
          {
            Characteristic = null;
          }

          break;

        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "member":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Member = new List<GroupMember>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.GroupMember objMember = new fhirCsR2.Models.GroupMember();
            objMember.DeserializeJson(ref reader, options);
            Member.Add(objMember);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Member.Count == 0)
          {
            Member = null;
          }

          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR2.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "quantity":
          Quantity = reader.GetUInt32();
          break;

        case "type":
          Type = reader.GetString();
          break;

        case "_type":
          _Type = new fhirCsR2.Models.Element();
          _Type.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Group.type field
  /// </summary>
  public static class GroupTypeCodes {
    public const string PERSON = "person";
    public const string ANIMAL = "animal";
    public const string PRACTITIONER = "practitioner";
    public const string DEVICE = "device";
    public const string MEDICATION = "medication";
    public const string SUBSTANCE = "substance";
    public static HashSet<string> Values = new HashSet<string>() {
      "person",
      "animal",
      "practitioner",
      "device",
      "medication",
      "substance",
    };
  }
}
