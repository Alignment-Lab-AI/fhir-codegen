// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// A single SOP Instance within the series, e.g. an image, or presentation state.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ImagingStudySeriesInstance>))]
  public class ImagingStudySeriesInstance : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Content of the instance or a rendering thereof (e.g. a JPEG of an image, or an XML of a structured report). May be represented for example by inline encoding; by a URL reference to a WADO-RS service that makes the instance available; or to a FHIR Resource (e.g. Media, Document, etc.). Multiple content attachments may be used for alternate representations of the instance.
    /// </summary>
    public List<Attachment> Content { get; set; }
    /// <summary>
    /// The number of instance in the series.
    /// </summary>
    public uint? Number { get; set; }
    /// <summary>
    /// DICOM instance  type.
    /// </summary>
    public string SopClass { get; set; }
    /// <summary>
    /// Extension container element for SopClass
    /// </summary>
    public Element _SopClass { get; set; }
    /// <summary>
    /// The description of the instance.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// A human-friendly SOP Class name.
    /// </summary>
    public string Type { get; set; }
    /// <summary>
    /// Extension container element for Type
    /// </summary>
    public Element _Type { get; set; }
    /// <summary>
    /// Formal identifier for this image or other content.
    /// </summary>
    public string Uid { get; set; }
    /// <summary>
    /// Extension container element for Uid
    /// </summary>
    public Element _Uid { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Number != null)
      {
        writer.WriteNumber("number", (uint)Number!);
      }

      if (!string.IsNullOrEmpty(Uid))
      {
        writer.WriteString("uid", (string)Uid!);
      }

      if (_Uid != null)
      {
        writer.WritePropertyName("_uid");
        _Uid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SopClass))
      {
        writer.WriteString("sopClass", (string)SopClass!);
      }

      if (_SopClass != null)
      {
        writer.WritePropertyName("_sopClass");
        _SopClass.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Type))
      {
        writer.WriteString("type", (string)Type!);
      }

      if (_Type != null)
      {
        writer.WritePropertyName("_type");
        _Type.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if ((Content != null) && (Content.Count != 0))
      {
        writer.WritePropertyName("content");
        writer.WriteStartArray();

        foreach (Attachment valContent in Content)
        {
          valContent.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "content":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Content = new List<Attachment>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Attachment objContent = new fhirCsR2.Models.Attachment();
            objContent.DeserializeJson(ref reader, options);
            Content.Add(objContent);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Content.Count == 0)
          {
            Content = null;
          }

          break;

        case "number":
          Number = reader.GetUInt32();
          break;

        case "sopClass":
          SopClass = reader.GetString();
          break;

        case "_sopClass":
          _SopClass = new fhirCsR2.Models.Element();
          _SopClass.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR2.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = reader.GetString();
          break;

        case "_type":
          _Type = new fhirCsR2.Models.Element();
          _Type.DeserializeJson(ref reader, options);
          break;

        case "uid":
          Uid = reader.GetString();
          break;

        case "_uid":
          _Uid = new fhirCsR2.Models.Element();
          _Uid.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Each study has one or more series of images or other content.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ImagingStudySeries>))]
  public class ImagingStudySeries : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Availability of series (online, offline or nearline).
    /// </summary>
    public string Availability { get; set; }
    /// <summary>
    /// Extension container element for Availability
    /// </summary>
    public Element _Availability { get; set; }
    /// <summary>
    /// Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed CT.
    /// </summary>
    public Coding BodySite { get; set; }
    /// <summary>
    /// A description of the series.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// A single SOP Instance within the series, e.g. an image, or presentation state.
    /// </summary>
    public List<ImagingStudySeriesInstance> Instance { get; set; }
    /// <summary>
    /// Laterality if body site is paired anatomic structure and laterality is not pre-coordinated in body site code.
    /// </summary>
    public Coding Laterality { get; set; }
    /// <summary>
    /// The modality of this series sequence.
    /// </summary>
    public Coding Modality { get; set; }
    /// <summary>
    /// The Numeric identifier of this series in the study.
    /// </summary>
    public uint? Number { get; set; }
    /// <summary>
    /// Number of SOP Instances in Series.
    /// </summary>
    public uint NumberOfInstances { get; set; }
    /// <summary>
    /// The date and time the series was started.
    /// </summary>
    public string Started { get; set; }
    /// <summary>
    /// Extension container element for Started
    /// </summary>
    public Element _Started { get; set; }
    /// <summary>
    /// Formal identifier for this series.
    /// </summary>
    public string Uid { get; set; }
    /// <summary>
    /// Extension container element for Uid
    /// </summary>
    public Element _Uid { get; set; }
    /// <summary>
    /// URI/URL specifying the location of the referenced series using WADO-RS.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Number != null)
      {
        writer.WriteNumber("number", (uint)Number!);
      }

      if (Modality != null)
      {
        writer.WritePropertyName("modality");
        Modality.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Uid))
      {
        writer.WriteString("uid", (string)Uid!);
      }

      if (_Uid != null)
      {
        writer.WritePropertyName("_uid");
        _Uid.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      writer.WriteNumber("numberOfInstances", NumberOfInstances);

      if (!string.IsNullOrEmpty(Availability))
      {
        writer.WriteString("availability", (string)Availability!);
      }

      if (_Availability != null)
      {
        writer.WritePropertyName("_availability");
        _Availability.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if (BodySite != null)
      {
        writer.WritePropertyName("bodySite");
        BodySite.SerializeJson(writer, options);
      }

      if (Laterality != null)
      {
        writer.WritePropertyName("laterality");
        Laterality.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Started))
      {
        writer.WriteString("started", (string)Started!);
      }

      if (_Started != null)
      {
        writer.WritePropertyName("_started");
        _Started.SerializeJson(writer, options);
      }

      if ((Instance != null) && (Instance.Count != 0))
      {
        writer.WritePropertyName("instance");
        writer.WriteStartArray();

        foreach (ImagingStudySeriesInstance valInstance in Instance)
        {
          valInstance.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "availability":
          Availability = reader.GetString();
          break;

        case "_availability":
          _Availability = new fhirCsR2.Models.Element();
          _Availability.DeserializeJson(ref reader, options);
          break;

        case "bodySite":
          BodySite = new fhirCsR2.Models.Coding();
          BodySite.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "instance":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Instance = new List<ImagingStudySeriesInstance>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ImagingStudySeriesInstance objInstance = new fhirCsR2.Models.ImagingStudySeriesInstance();
            objInstance.DeserializeJson(ref reader, options);
            Instance.Add(objInstance);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Instance.Count == 0)
          {
            Instance = null;
          }

          break;

        case "laterality":
          Laterality = new fhirCsR2.Models.Coding();
          Laterality.DeserializeJson(ref reader, options);
          break;

        case "modality":
          Modality = new fhirCsR2.Models.Coding();
          Modality.DeserializeJson(ref reader, options);
          break;

        case "number":
          Number = reader.GetUInt32();
          break;

        case "numberOfInstances":
          NumberOfInstances = reader.GetUInt32();
          break;

        case "started":
          Started = reader.GetString();
          break;

        case "_started":
          _Started = new fhirCsR2.Models.Element();
          _Started.DeserializeJson(ref reader, options);
          break;

        case "uid":
          Uid = reader.GetString();
          break;

        case "_uid":
          _Uid = new fhirCsR2.Models.Element();
          _Uid.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR2.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ImagingStudy.series.availability field
  /// </summary>
  public static class ImagingStudySeriesAvailabilityCodes {
    public const string ONLINE = "ONLINE";
    public const string OFFLINE = "OFFLINE";
    public const string NEARLINE = "NEARLINE";
    public const string UNAVAILABLE = "UNAVAILABLE";
  }
  /// <summary>
  /// Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ImagingStudy>))]
  public class ImagingStudy : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "ImagingStudy";
    /// <summary>
    /// Accession Number is an identifier related to some aspect of imaging workflow and data management. Usage may vary across different institutions.  See for instance [IHE Radiology Technical Framework Volume 1 Appendix A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf).
    /// </summary>
    public Identifier Accession { get; set; }
    /// <summary>
    /// Availability of study (online, offline or nearline).
    /// </summary>
    public string Availability { get; set; }
    /// <summary>
    /// Extension container element for Availability
    /// </summary>
    public Element _Availability { get; set; }
    /// <summary>
    /// Institution-generated description or classification of the Study performed.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Other identifiers for the study.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Who read the study and interpreted the images or other content.
    /// </summary>
    public Reference Interpreter { get; set; }
    /// <summary>
    /// A list of all the Series.ImageModality values that are actual acquisition modalities, i.e. those in the DICOM Context Group 29 (value set OID 1.2.840.10008.6.1.19).
    /// </summary>
    public List<Coding> ModalityList { get; set; }
    /// <summary>
    /// Number of SOP Instances in Study.
    /// </summary>
    public uint NumberOfInstances { get; set; }
    /// <summary>
    /// Number of Series in Study.
    /// </summary>
    public uint NumberOfSeries { get; set; }
    /// <summary>
    /// To support grouped procedures (one imaging study supporting multiple ordered procedures, e.g. chest/abdomen/pelvis CT).
    /// </summary>
    public List<Reference> Order { get; set; }
    /// <summary>
    /// The patient imaged in the study.
    /// </summary>
    public Reference Patient { get; set; }
    /// <summary>
    /// Type of procedure performed.
    /// </summary>
    public List<Reference> Procedure { get; set; }
    /// <summary>
    /// The requesting/referring physician.
    /// </summary>
    public Reference Referrer { get; set; }
    /// <summary>
    /// Each study has one or more series of images or other content.
    /// </summary>
    public List<ImagingStudySeries> Series { get; set; }
    /// <summary>
    /// Date and Time the study started.
    /// </summary>
    public string Started { get; set; }
    /// <summary>
    /// Extension container element for Started
    /// </summary>
    public Element _Started { get; set; }
    /// <summary>
    /// Formal identifier for the study.
    /// </summary>
    public string Uid { get; set; }
    /// <summary>
    /// Extension container element for Uid
    /// </summary>
    public Element _Uid { get; set; }
    /// <summary>
    /// WADO-RS resource where Study is available.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Started))
      {
        writer.WriteString("started", (string)Started!);
      }

      if (_Started != null)
      {
        writer.WritePropertyName("_started");
        _Started.SerializeJson(writer, options);
      }

      if (Patient != null)
      {
        writer.WritePropertyName("patient");
        Patient.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Uid))
      {
        writer.WriteString("uid", (string)Uid!);
      }

      if (_Uid != null)
      {
        writer.WritePropertyName("_uid");
        _Uid.SerializeJson(writer, options);
      }

      if (Accession != null)
      {
        writer.WritePropertyName("accession");
        Accession.SerializeJson(writer, options);
      }

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Order != null) && (Order.Count != 0))
      {
        writer.WritePropertyName("order");
        writer.WriteStartArray();

        foreach (Reference valOrder in Order)
        {
          valOrder.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ModalityList != null) && (ModalityList.Count != 0))
      {
        writer.WritePropertyName("modalityList");
        writer.WriteStartArray();

        foreach (Coding valModalityList in ModalityList)
        {
          valModalityList.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Referrer != null)
      {
        writer.WritePropertyName("referrer");
        Referrer.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Availability))
      {
        writer.WriteString("availability", (string)Availability!);
      }

      if (_Availability != null)
      {
        writer.WritePropertyName("_availability");
        _Availability.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      writer.WriteNumber("numberOfSeries", NumberOfSeries);

      writer.WriteNumber("numberOfInstances", NumberOfInstances);

      if ((Procedure != null) && (Procedure.Count != 0))
      {
        writer.WritePropertyName("procedure");
        writer.WriteStartArray();

        foreach (Reference valProcedure in Procedure)
        {
          valProcedure.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Interpreter != null)
      {
        writer.WritePropertyName("interpreter");
        Interpreter.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if ((Series != null) && (Series.Count != 0))
      {
        writer.WritePropertyName("series");
        writer.WriteStartArray();

        foreach (ImagingStudySeries valSeries in Series)
        {
          valSeries.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "accession":
          Accession = new fhirCsR2.Models.Identifier();
          Accession.DeserializeJson(ref reader, options);
          break;

        case "availability":
          Availability = reader.GetString();
          break;

        case "_availability":
          _Availability = new fhirCsR2.Models.Element();
          _Availability.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "interpreter":
          Interpreter = new fhirCsR2.Models.Reference();
          Interpreter.DeserializeJson(ref reader, options);
          break;

        case "modalityList":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ModalityList = new List<Coding>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Coding objModalityList = new fhirCsR2.Models.Coding();
            objModalityList.DeserializeJson(ref reader, options);
            ModalityList.Add(objModalityList);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ModalityList.Count == 0)
          {
            ModalityList = null;
          }

          break;

        case "numberOfInstances":
          NumberOfInstances = reader.GetUInt32();
          break;

        case "numberOfSeries":
          NumberOfSeries = reader.GetUInt32();
          break;

        case "order":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Order = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objOrder = new fhirCsR2.Models.Reference();
            objOrder.DeserializeJson(ref reader, options);
            Order.Add(objOrder);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Order.Count == 0)
          {
            Order = null;
          }

          break;

        case "patient":
          Patient = new fhirCsR2.Models.Reference();
          Patient.DeserializeJson(ref reader, options);
          break;

        case "procedure":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Procedure = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objProcedure = new fhirCsR2.Models.Reference();
            objProcedure.DeserializeJson(ref reader, options);
            Procedure.Add(objProcedure);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Procedure.Count == 0)
          {
            Procedure = null;
          }

          break;

        case "referrer":
          Referrer = new fhirCsR2.Models.Reference();
          Referrer.DeserializeJson(ref reader, options);
          break;

        case "series":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Series = new List<ImagingStudySeries>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ImagingStudySeries objSeries = new fhirCsR2.Models.ImagingStudySeries();
            objSeries.DeserializeJson(ref reader, options);
            Series.Add(objSeries);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Series.Count == 0)
          {
            Series = null;
          }

          break;

        case "started":
          Started = reader.GetString();
          break;

        case "_started":
          _Started = new fhirCsR2.Models.Element();
          _Started.DeserializeJson(ref reader, options);
          break;

        case "uid":
          Uid = reader.GetString();
          break;

        case "_uid":
          _Uid = new fhirCsR2.Models.Element();
          _Uid.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR2.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ImagingStudy.availability field
  /// </summary>
  public static class ImagingStudyAvailabilityCodes {
    public const string ONLINE = "ONLINE";
    public const string OFFLINE = "OFFLINE";
    public const string NEARLINE = "NEARLINE";
    public const string UNAVAILABLE = "UNAVAILABLE";
  }
}
