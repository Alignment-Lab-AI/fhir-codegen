// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Clinical stage or grade of a condition. May include formal severity assessments.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ConditionStage>))]
  public class ConditionStage : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Reference to a formal record of the evidence on which the staging assessment is based.
    /// </summary>
    public List<Reference> Assessment { get; set; }
    /// <summary>
    /// A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    /// </summary>
    public CodeableConcept Summary { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Summary != null)
      {
        writer.WritePropertyName("summary");
        Summary.SerializeJson(writer, options);
      }

      if ((Assessment != null) && (Assessment.Count != 0))
      {
        writer.WritePropertyName("assessment");
        writer.WriteStartArray();

        foreach (Reference valAssessment in Assessment)
        {
          valAssessment.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "assessment":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Assessment = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objAssessment = new fhirCsR2.Models.Reference();
            objAssessment.DeserializeJson(ref reader, options);
            Assessment.Add(objAssessment);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Assessment.Count == 0)
          {
            Assessment = null;
          }

          break;

        case "summary":
          Summary = new fhirCsR2.Models.CodeableConcept();
          Summary.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ConditionEvidence>))]
  public class ConditionEvidence : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A manifestation or symptom that led to the recording of this condition.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Links to other relevant information, including pathology reports.
    /// </summary>
    public List<Reference> Detail { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if ((Detail != null) && (Detail.Count != 0))
      {
        writer.WritePropertyName("detail");
        writer.WriteStartArray();

        foreach (Reference valDetail in Detail)
        {
          valDetail.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "detail":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Detail = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objDetail = new fhirCsR2.Models.Reference();
            objDetail.DeserializeJson(ref reader, options);
            Detail.Add(objDetail);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Detail.Count == 0)
          {
            Detail = null;
          }

          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Use to record detailed information about conditions, problems or diagnoses recognized by a clinician. There are many uses including: recording a diagnosis during an encounter; populating a problem list or a summary statement, such as a discharge summary.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<Condition>))]
  public class Condition : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Condition";
    /// <summary>
    /// The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    /// </summary>
    public string AbatementDateTime { get; set; }
    /// <summary>
    /// Extension container element for AbatementDateTime
    /// </summary>
    public Element _AbatementDateTime { get; set; }
    /// <summary>
    /// The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    /// </summary>
    public Quantity AbatementQuantity { get; set; }
    /// <summary>
    /// The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    /// </summary>
    public bool? AbatementBoolean { get; set; }
    /// <summary>
    /// Extension container element for AbatementBoolean
    /// </summary>
    public Element _AbatementBoolean { get; set; }
    /// <summary>
    /// The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    /// </summary>
    public Period AbatementPeriod { get; set; }
    /// <summary>
    /// The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    /// </summary>
    public Range AbatementRange { get; set; }
    /// <summary>
    /// The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    /// </summary>
    public string AbatementString { get; set; }
    /// <summary>
    /// Extension container element for AbatementString
    /// </summary>
    public Element _AbatementString { get; set; }
    /// <summary>
    /// Individual who is making the condition statement.
    /// </summary>
    public Reference Asserter { get; set; }
    /// <summary>
    /// The anatomical location where this condition manifests itself.
    /// </summary>
    public List<CodeableConcept> BodySite { get; set; }
    /// <summary>
    /// A category assigned to the condition.
    /// </summary>
    public CodeableConcept Category { get; set; }
    /// <summary>
    /// The clinical status of the condition.
    /// </summary>
    public string ClinicalStatus { get; set; }
    /// <summary>
    /// Extension container element for ClinicalStatus
    /// </summary>
    public Element _ClinicalStatus { get; set; }
    /// <summary>
    /// Identification of the condition, problem or diagnosis.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// A date, when  the Condition statement was documented.
    /// </summary>
    public string DateRecorded { get; set; }
    /// <summary>
    /// Extension container element for DateRecorded
    /// </summary>
    public Element _DateRecorded { get; set; }
    /// <summary>
    /// Encounter during which the condition was first asserted.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
    /// </summary>
    public List<ConditionEvidence> Evidence { get; set; }
    /// <summary>
    /// Need to allow connection to a wider workflow.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    /// </summary>
    public string Notes { get; set; }
    /// <summary>
    /// Extension container element for Notes
    /// </summary>
    public Element _Notes { get; set; }
    /// <summary>
    /// Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    /// </summary>
    public string OnsetDateTime { get; set; }
    /// <summary>
    /// Extension container element for OnsetDateTime
    /// </summary>
    public Element _OnsetDateTime { get; set; }
    /// <summary>
    /// Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    /// </summary>
    public Quantity OnsetQuantity { get; set; }
    /// <summary>
    /// Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    /// </summary>
    public Period OnsetPeriod { get; set; }
    /// <summary>
    /// Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    /// </summary>
    public Range OnsetRange { get; set; }
    /// <summary>
    /// Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    /// </summary>
    public string OnsetString { get; set; }
    /// <summary>
    /// Extension container element for OnsetString
    /// </summary>
    public Element _OnsetString { get; set; }
    /// <summary>
    /// Indicates the patient who the condition record is associated with.
    /// </summary>
    public Reference Patient { get; set; }
    /// <summary>
    /// A subjective assessment of the severity of the condition as evaluated by the clinician.
    /// </summary>
    public CodeableConcept Severity { get; set; }
    /// <summary>
    /// Clinical stage or grade of a condition. May include formal severity assessments.
    /// </summary>
    public ConditionStage Stage { get; set; }
    /// <summary>
    /// The verification status to support the clinical status of the condition.
    /// </summary>
    public string VerificationStatus { get; set; }
    /// <summary>
    /// Extension container element for VerificationStatus
    /// </summary>
    public Element _VerificationStatus { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Patient != null)
      {
        writer.WritePropertyName("patient");
        Patient.SerializeJson(writer, options);
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(writer, options);
      }

      if (Asserter != null)
      {
        writer.WritePropertyName("asserter");
        Asserter.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DateRecorded))
      {
        writer.WriteString("dateRecorded", (string)DateRecorded!);
      }

      if (_DateRecorded != null)
      {
        writer.WritePropertyName("_dateRecorded");
        _DateRecorded.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (Category != null)
      {
        writer.WritePropertyName("category");
        Category.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ClinicalStatus))
      {
        writer.WriteString("clinicalStatus", (string)ClinicalStatus!);
      }

      if (_ClinicalStatus != null)
      {
        writer.WritePropertyName("_clinicalStatus");
        _ClinicalStatus.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(VerificationStatus))
      {
        writer.WriteString("verificationStatus", (string)VerificationStatus!);
      }

      if (_VerificationStatus != null)
      {
        writer.WritePropertyName("_verificationStatus");
        _VerificationStatus.SerializeJson(writer, options);
      }

      if (Severity != null)
      {
        writer.WritePropertyName("severity");
        Severity.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(OnsetDateTime))
      {
        writer.WriteString("onsetDateTime", (string)OnsetDateTime!);
      }

      if (_OnsetDateTime != null)
      {
        writer.WritePropertyName("_onsetDateTime");
        _OnsetDateTime.SerializeJson(writer, options);
      }

      if (OnsetQuantity != null)
      {
        writer.WritePropertyName("onsetQuantity");
        OnsetQuantity.SerializeJson(writer, options);
      }

      if (OnsetPeriod != null)
      {
        writer.WritePropertyName("onsetPeriod");
        OnsetPeriod.SerializeJson(writer, options);
      }

      if (OnsetRange != null)
      {
        writer.WritePropertyName("onsetRange");
        OnsetRange.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(OnsetString))
      {
        writer.WriteString("onsetString", (string)OnsetString!);
      }

      if (_OnsetString != null)
      {
        writer.WritePropertyName("_onsetString");
        _OnsetString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(AbatementDateTime))
      {
        writer.WriteString("abatementDateTime", (string)AbatementDateTime!);
      }

      if (_AbatementDateTime != null)
      {
        writer.WritePropertyName("_abatementDateTime");
        _AbatementDateTime.SerializeJson(writer, options);
      }

      if (AbatementQuantity != null)
      {
        writer.WritePropertyName("abatementQuantity");
        AbatementQuantity.SerializeJson(writer, options);
      }

      if (AbatementBoolean != null)
      {
        writer.WriteBoolean("abatementBoolean", (bool)AbatementBoolean!);
      }

      if (_AbatementBoolean != null)
      {
        writer.WritePropertyName("_abatementBoolean");
        _AbatementBoolean.SerializeJson(writer, options);
      }

      if (AbatementPeriod != null)
      {
        writer.WritePropertyName("abatementPeriod");
        AbatementPeriod.SerializeJson(writer, options);
      }

      if (AbatementRange != null)
      {
        writer.WritePropertyName("abatementRange");
        AbatementRange.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(AbatementString))
      {
        writer.WriteString("abatementString", (string)AbatementString!);
      }

      if (_AbatementString != null)
      {
        writer.WritePropertyName("_abatementString");
        _AbatementString.SerializeJson(writer, options);
      }

      if (Stage != null)
      {
        writer.WritePropertyName("stage");
        Stage.SerializeJson(writer, options);
      }

      if ((Evidence != null) && (Evidence.Count != 0))
      {
        writer.WritePropertyName("evidence");
        writer.WriteStartArray();

        foreach (ConditionEvidence valEvidence in Evidence)
        {
          valEvidence.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BodySite != null) && (BodySite.Count != 0))
      {
        writer.WritePropertyName("bodySite");
        writer.WriteStartArray();

        foreach (CodeableConcept valBodySite in BodySite)
        {
          valBodySite.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Notes))
      {
        writer.WriteString("notes", (string)Notes!);
      }

      if (_Notes != null)
      {
        writer.WritePropertyName("_notes");
        _Notes.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "abatementDateTime":
          AbatementDateTime = reader.GetString();
          break;

        case "_abatementDateTime":
          _AbatementDateTime = new fhirCsR2.Models.Element();
          _AbatementDateTime.DeserializeJson(ref reader, options);
          break;

        case "abatementQuantity":
          AbatementQuantity = new fhirCsR2.Models.Quantity();
          AbatementQuantity.DeserializeJson(ref reader, options);
          break;

        case "abatementBoolean":
          AbatementBoolean = reader.GetBoolean();
          break;

        case "_abatementBoolean":
          _AbatementBoolean = new fhirCsR2.Models.Element();
          _AbatementBoolean.DeserializeJson(ref reader, options);
          break;

        case "abatementPeriod":
          AbatementPeriod = new fhirCsR2.Models.Period();
          AbatementPeriod.DeserializeJson(ref reader, options);
          break;

        case "abatementRange":
          AbatementRange = new fhirCsR2.Models.Range();
          AbatementRange.DeserializeJson(ref reader, options);
          break;

        case "abatementString":
          AbatementString = reader.GetString();
          break;

        case "_abatementString":
          _AbatementString = new fhirCsR2.Models.Element();
          _AbatementString.DeserializeJson(ref reader, options);
          break;

        case "asserter":
          Asserter = new fhirCsR2.Models.Reference();
          Asserter.DeserializeJson(ref reader, options);
          break;

        case "bodySite":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BodySite = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objBodySite = new fhirCsR2.Models.CodeableConcept();
            objBodySite.DeserializeJson(ref reader, options);
            BodySite.Add(objBodySite);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BodySite.Count == 0)
          {
            BodySite = null;
          }

          break;

        case "category":
          Category = new fhirCsR2.Models.CodeableConcept();
          Category.DeserializeJson(ref reader, options);
          break;

        case "clinicalStatus":
          ClinicalStatus = reader.GetString();
          break;

        case "_clinicalStatus":
          _ClinicalStatus = new fhirCsR2.Models.Element();
          _ClinicalStatus.DeserializeJson(ref reader, options);
          break;

        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "dateRecorded":
          DateRecorded = reader.GetString();
          break;

        case "_dateRecorded":
          _DateRecorded = new fhirCsR2.Models.Element();
          _DateRecorded.DeserializeJson(ref reader, options);
          break;

        case "encounter":
          Encounter = new fhirCsR2.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "evidence":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Evidence = new List<ConditionEvidence>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ConditionEvidence objEvidence = new fhirCsR2.Models.ConditionEvidence();
            objEvidence.DeserializeJson(ref reader, options);
            Evidence.Add(objEvidence);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Evidence.Count == 0)
          {
            Evidence = null;
          }

          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "notes":
          Notes = reader.GetString();
          break;

        case "_notes":
          _Notes = new fhirCsR2.Models.Element();
          _Notes.DeserializeJson(ref reader, options);
          break;

        case "onsetDateTime":
          OnsetDateTime = reader.GetString();
          break;

        case "_onsetDateTime":
          _OnsetDateTime = new fhirCsR2.Models.Element();
          _OnsetDateTime.DeserializeJson(ref reader, options);
          break;

        case "onsetQuantity":
          OnsetQuantity = new fhirCsR2.Models.Quantity();
          OnsetQuantity.DeserializeJson(ref reader, options);
          break;

        case "onsetPeriod":
          OnsetPeriod = new fhirCsR2.Models.Period();
          OnsetPeriod.DeserializeJson(ref reader, options);
          break;

        case "onsetRange":
          OnsetRange = new fhirCsR2.Models.Range();
          OnsetRange.DeserializeJson(ref reader, options);
          break;

        case "onsetString":
          OnsetString = reader.GetString();
          break;

        case "_onsetString":
          _OnsetString = new fhirCsR2.Models.Element();
          _OnsetString.DeserializeJson(ref reader, options);
          break;

        case "patient":
          Patient = new fhirCsR2.Models.Reference();
          Patient.DeserializeJson(ref reader, options);
          break;

        case "severity":
          Severity = new fhirCsR2.Models.CodeableConcept();
          Severity.DeserializeJson(ref reader, options);
          break;

        case "stage":
          Stage = new fhirCsR2.Models.ConditionStage();
          Stage.DeserializeJson(ref reader, options);
          break;

        case "verificationStatus":
          VerificationStatus = reader.GetString();
          break;

        case "_verificationStatus":
          _VerificationStatus = new fhirCsR2.Models.Element();
          _VerificationStatus.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Condition.clinicalStatus field
  /// </summary>
  public static class ConditionClinicalStatusCodes {
    public const string ACTIVE = "active";
    public const string RELAPSE = "relapse";
    public const string REMISSION = "remission";
    public const string RESOLVED = "resolved";
  }
  /// <summary>
  /// Code Values for the Condition.verificationStatus field
  /// </summary>
  public static class ConditionVerificationStatusCodes {
    public const string PROVISIONAL = "provisional";
    public const string DIFFERENTIAL = "differential";
    public const string CONFIRMED = "confirmed";
    public const string REFUTED = "refuted";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string UNKNOWN = "unknown";
  }
}
