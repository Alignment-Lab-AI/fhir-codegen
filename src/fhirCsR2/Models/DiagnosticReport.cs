// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// Many diagnostic services include images in the report as part of their service.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<DiagnosticReportImage>))]
  public class DiagnosticReportImage : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The provider of the report should make a comment about each image included in the report.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// Reference to the image source.
    /// </summary>
    public Reference Link { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if (Link != null)
      {
        writer.WritePropertyName("link");
        Link.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR2.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "link":
          Link = new fhirCsR2.Models.Reference();
          Link.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<DiagnosticReport>))]
  public class DiagnosticReport : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "DiagnosticReport";
    /// <summary>
    /// A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes.
    /// </summary>
    public CodeableConcept Category { get; set; }
    /// <summary>
    /// A code or name that describes this diagnostic report.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Codes for the conclusion.
    /// </summary>
    public List<CodeableConcept> CodedDiagnosis { get; set; }
    /// <summary>
    /// Need to be able to provide a conclusion that is not lost among the basic result data.
    /// </summary>
    public string Conclusion { get; set; }
    /// <summary>
    /// Extension container element for Conclusion
    /// </summary>
    public Element _Conclusion { get; set; }
    /// <summary>
    /// Need to know where in the patient history to file/present this report.
    /// </summary>
    public string EffectiveDateTime { get; set; }
    /// <summary>
    /// Extension container element for EffectiveDateTime
    /// </summary>
    public Element _EffectiveDateTime { get; set; }
    /// <summary>
    /// Need to know where in the patient history to file/present this report.
    /// </summary>
    public Period EffectivePeriod { get; set; }
    /// <summary>
    /// The link to the health care event (encounter) when the order was made.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// Need to know what identifier to use when making queries about this report from the source laboratory, and for linking to the report outside FHIR context.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Many diagnostic services include images in the report as part of their service.
    /// </summary>
    public List<DiagnosticReportImage> Image { get; set; }
    /// <summary>
    /// One or more links to full details of any imaging performed during the diagnostic investigation. Typically, this is imaging performed by DICOM enabled modalities, but this is not required. A fully enabled PACS viewer can use this information to provide views of the source images.
    /// </summary>
    public List<Reference> ImagingStudy { get; set; }
    /// <summary>
    /// Clinicians need to be able to check the date that the report was released.
    /// </summary>
    public string Issued { get; set; }
    /// <summary>
    /// Extension container element for Issued
    /// </summary>
    public Element _Issued { get; set; }
    /// <summary>
    /// Need to know whom to contact if there are queries about the results. Also may need to track the source of reports for secondary data analysis.
    /// </summary>
    public Reference Performer { get; set; }
    /// <summary>
    /// Gives Laboratory the ability to provide its own fully formatted report for clinical fidelity.
    /// </summary>
    public List<Attachment> PresentedForm { get; set; }
    /// <summary>
    /// Need to be able to track completion of requests based on reports issued and also to report what diagnostic tests were requested (not always the same as what is delivered).
    /// </summary>
    public List<Reference> Request { get; set; }
    /// <summary>
    /// Need to support individual results, or report groups of results, where the result grouping is arbitrary, but meaningful. This structure is recursive - observations can contain observations.
    /// </summary>
    public List<Reference> Result { get; set; }
    /// <summary>
    /// Need to be able to report information about the collected specimens on which the report is based.
    /// </summary>
    public List<Reference> Specimen { get; set; }
    /// <summary>
    /// Diagnostic services routinely issue provisional/incomplete reports, and sometimes withdraw previously released reports.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// SHALL know the subject context.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Category != null)
      {
        writer.WritePropertyName("category");
        Category.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(EffectiveDateTime))
      {
        writer.WriteString("effectiveDateTime", (string)EffectiveDateTime!);
      }

      if (_EffectiveDateTime != null)
      {
        writer.WritePropertyName("_effectiveDateTime");
        _EffectiveDateTime.SerializeJson(writer, options);
      }

      if (EffectivePeriod != null)
      {
        writer.WritePropertyName("effectivePeriod");
        EffectivePeriod.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Issued))
      {
        writer.WriteString("issued", (string)Issued!);
      }

      if (_Issued != null)
      {
        writer.WritePropertyName("_issued");
        _Issued.SerializeJson(writer, options);
      }

      if (Performer != null)
      {
        writer.WritePropertyName("performer");
        Performer.SerializeJson(writer, options);
      }

      if ((Request != null) && (Request.Count != 0))
      {
        writer.WritePropertyName("request");
        writer.WriteStartArray();

        foreach (Reference valRequest in Request)
        {
          valRequest.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Specimen != null) && (Specimen.Count != 0))
      {
        writer.WritePropertyName("specimen");
        writer.WriteStartArray();

        foreach (Reference valSpecimen in Specimen)
        {
          valSpecimen.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Result != null) && (Result.Count != 0))
      {
        writer.WritePropertyName("result");
        writer.WriteStartArray();

        foreach (Reference valResult in Result)
        {
          valResult.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ImagingStudy != null) && (ImagingStudy.Count != 0))
      {
        writer.WritePropertyName("imagingStudy");
        writer.WriteStartArray();

        foreach (Reference valImagingStudy in ImagingStudy)
        {
          valImagingStudy.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Image != null) && (Image.Count != 0))
      {
        writer.WritePropertyName("image");
        writer.WriteStartArray();

        foreach (DiagnosticReportImage valImage in Image)
        {
          valImage.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Conclusion))
      {
        writer.WriteString("conclusion", (string)Conclusion!);
      }

      if (_Conclusion != null)
      {
        writer.WritePropertyName("_conclusion");
        _Conclusion.SerializeJson(writer, options);
      }

      if ((CodedDiagnosis != null) && (CodedDiagnosis.Count != 0))
      {
        writer.WritePropertyName("codedDiagnosis");
        writer.WriteStartArray();

        foreach (CodeableConcept valCodedDiagnosis in CodedDiagnosis)
        {
          valCodedDiagnosis.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((PresentedForm != null) && (PresentedForm.Count != 0))
      {
        writer.WritePropertyName("presentedForm");
        writer.WriteStartArray();

        foreach (Attachment valPresentedForm in PresentedForm)
        {
          valPresentedForm.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "category":
          Category = new fhirCsR2.Models.CodeableConcept();
          Category.DeserializeJson(ref reader, options);
          break;

        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "codedDiagnosis":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          CodedDiagnosis = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objCodedDiagnosis = new fhirCsR2.Models.CodeableConcept();
            objCodedDiagnosis.DeserializeJson(ref reader, options);
            CodedDiagnosis.Add(objCodedDiagnosis);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (CodedDiagnosis.Count == 0)
          {
            CodedDiagnosis = null;
          }

          break;

        case "conclusion":
          Conclusion = reader.GetString();
          break;

        case "_conclusion":
          _Conclusion = new fhirCsR2.Models.Element();
          _Conclusion.DeserializeJson(ref reader, options);
          break;

        case "effectiveDateTime":
          EffectiveDateTime = reader.GetString();
          break;

        case "_effectiveDateTime":
          _EffectiveDateTime = new fhirCsR2.Models.Element();
          _EffectiveDateTime.DeserializeJson(ref reader, options);
          break;

        case "effectivePeriod":
          EffectivePeriod = new fhirCsR2.Models.Period();
          EffectivePeriod.DeserializeJson(ref reader, options);
          break;

        case "encounter":
          Encounter = new fhirCsR2.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Identifier objIdentifier = new fhirCsR2.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "image":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Image = new List<DiagnosticReportImage>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.DiagnosticReportImage objImage = new fhirCsR2.Models.DiagnosticReportImage();
            objImage.DeserializeJson(ref reader, options);
            Image.Add(objImage);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Image.Count == 0)
          {
            Image = null;
          }

          break;

        case "imagingStudy":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ImagingStudy = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objImagingStudy = new fhirCsR2.Models.Reference();
            objImagingStudy.DeserializeJson(ref reader, options);
            ImagingStudy.Add(objImagingStudy);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ImagingStudy.Count == 0)
          {
            ImagingStudy = null;
          }

          break;

        case "issued":
          Issued = reader.GetString();
          break;

        case "_issued":
          _Issued = new fhirCsR2.Models.Element();
          _Issued.DeserializeJson(ref reader, options);
          break;

        case "performer":
          Performer = new fhirCsR2.Models.Reference();
          Performer.DeserializeJson(ref reader, options);
          break;

        case "presentedForm":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          PresentedForm = new List<Attachment>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Attachment objPresentedForm = new fhirCsR2.Models.Attachment();
            objPresentedForm.DeserializeJson(ref reader, options);
            PresentedForm.Add(objPresentedForm);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (PresentedForm.Count == 0)
          {
            PresentedForm = null;
          }

          break;

        case "request":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Request = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objRequest = new fhirCsR2.Models.Reference();
            objRequest.DeserializeJson(ref reader, options);
            Request.Add(objRequest);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Request.Count == 0)
          {
            Request = null;
          }

          break;

        case "result":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Result = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objResult = new fhirCsR2.Models.Reference();
            objResult.DeserializeJson(ref reader, options);
            Result.Add(objResult);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Result.Count == 0)
          {
            Result = null;
          }

          break;

        case "specimen":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Specimen = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objSpecimen = new fhirCsR2.Models.Reference();
            objSpecimen.DeserializeJson(ref reader, options);
            Specimen.Add(objSpecimen);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Specimen.Count == 0)
          {
            Specimen = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR2.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR2.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the DiagnosticReport.status field
  /// </summary>
  public static class DiagnosticReportStatusCodes {
    public const string REGISTERED = "registered";
    public const string PARTIAL = "partial";
    public const string FINAL = "final";
    public const string CORRECTED = "corrected";
    public const string APPENDED = "appended";
    public const string CANCELLED = "cancelled";
    public const string ENTERED_IN_ERROR = "entered-in-error";
  }
}
