// <auto-generated />
// Built from: hl7.fhir.r2.core version: 1.0.2
  // Option: "NAMESPACE" = "fhirCsR2"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR2.Serialization;

namespace fhirCsR2.Models
{
  /// <summary>
  /// One or more sets of investigations (signs, symptions, etc.). The actual grouping of investigations vary greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ClinicalImpressionInvestigations>))]
  public class ClinicalImpressionInvestigations : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutitirional) history may be used.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// A record of a specific investigation that was undertaken.
    /// </summary>
    public List<Reference> Item { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if ((Item != null) && (Item.Count != 0))
      {
        writer.WritePropertyName("item");
        writer.WriteStartArray();

        foreach (Reference valItem in Item)
        {
          valItem.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = new fhirCsR2.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "item":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Item = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objItem = new fhirCsR2.Models.Reference();
            objItem.DeserializeJson(ref reader, options);
            Item.Add(objItem);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Item.Count == 0)
          {
            Item = null;
          }

          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Specific findings or diagnoses that was considered likely or relevant to ongoing treatment.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ClinicalImpressionFinding>))]
  public class ClinicalImpressionFinding : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Which investigations support finding or diagnosis.
    /// </summary>
    public string Cause { get; set; }
    /// <summary>
    /// Extension container element for Cause
    /// </summary>
    public Element _Cause { get; set; }
    /// <summary>
    /// Specific text of code for finding or diagnosis.
    /// </summary>
    public CodeableConcept Item { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Item != null)
      {
        writer.WritePropertyName("item");
        Item.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Cause))
      {
        writer.WriteString("cause", (string)Cause!);
      }

      if (_Cause != null)
      {
        writer.WritePropertyName("_cause");
        _Cause.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "cause":
          Cause = reader.GetString();
          break;

        case "_cause":
          _Cause = new fhirCsR2.Models.Element();
          _Cause.DeserializeJson(ref reader, options);
          break;

        case "item":
          Item = new fhirCsR2.Models.CodeableConcept();
          Item.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Diagnosis considered not possible.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ClinicalImpressionRuledOut>))]
  public class ClinicalImpressionRuledOut : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Specific text of code for diagnosis.
    /// </summary>
    public CodeableConcept Item { get; set; }
    /// <summary>
    /// Grounds for elimination.
    /// </summary>
    public string Reason { get; set; }
    /// <summary>
    /// Extension container element for Reason
    /// </summary>
    public Element _Reason { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR2.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Item != null)
      {
        writer.WritePropertyName("item");
        Item.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Reason))
      {
        writer.WriteString("reason", (string)Reason!);
      }

      if (_Reason != null)
      {
        writer.WritePropertyName("_reason");
        _Reason.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "item":
          Item = new fhirCsR2.Models.CodeableConcept();
          Item.DeserializeJson(ref reader, options);
          break;

        case "reason":
          Reason = reader.GetString();
          break;

        case "_reason":
          _Reason = new fhirCsR2.Models.Element();
          _Reason.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
  /// </summary>
  [JsonConverter(typeof(fhirCsR2.Serialization.JsonStreamComponentConverter<ClinicalImpression>))]
  public class ClinicalImpression : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "ClinicalImpression";
    /// <summary>
    /// Actions taken during assessment.
    /// </summary>
    public List<Reference> Action { get; set; }
    /// <summary>
    /// The clinician performing the assessment.
    /// </summary>
    public Reference Assessor { get; set; }
    /// <summary>
    /// The point in time at which the assessment was concluded (not when it was recorded).
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// A summary of the context and/or cause of the assessment - why / where was it peformed, and what patient events/sstatus prompted it.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Specific findings or diagnoses that was considered likely or relevant to ongoing treatment.
    /// </summary>
    public List<ClinicalImpressionFinding> Finding { get; set; }
    /// <summary>
    /// One or more sets of investigations (signs, symptions, etc.). The actual grouping of investigations vary greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
    /// </summary>
    public List<ClinicalImpressionInvestigations> Investigations { get; set; }
    /// <summary>
    /// The patient being assessed.
    /// </summary>
    public Reference Patient { get; set; }
    /// <summary>
    /// Plan of action after assessment.
    /// </summary>
    public List<Reference> Plan { get; set; }
    /// <summary>
    /// A reference to the last assesment that was conducted bon this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes.
    /// </summary>
    public Reference Previous { get; set; }
    /// <summary>
    /// This a list of the general problems/conditions for a patient.
    /// </summary>
    public List<Reference> Problem { get; set; }
    /// <summary>
    /// Estimate of likely outcome.
    /// </summary>
    public string Prognosis { get; set; }
    /// <summary>
    /// Extension container element for Prognosis
    /// </summary>
    public Element _Prognosis { get; set; }
    /// <summary>
    /// Reference to a specific published clinical protocol that was followed during this assessment, and/or that provides evidence in support of the diagnosis.
    /// </summary>
    public string Protocol { get; set; }
    /// <summary>
    /// Extension container element for Protocol
    /// </summary>
    public Element _Protocol { get; set; }
    /// <summary>
    /// Diagnoses/conditions resolved since the last assessment.
    /// </summary>
    public List<CodeableConcept> Resolved { get; set; }
    /// <summary>
    /// Diagnosis considered not possible.
    /// </summary>
    public List<ClinicalImpressionRuledOut> RuledOut { get; set; }
    /// <summary>
    /// Identifies the workflow status of the assessment.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// A text summary of the investigations and the diagnosis.
    /// </summary>
    public string Summary { get; set; }
    /// <summary>
    /// Extension container element for Summary
    /// </summary>
    public Element _Summary { get; set; }
    /// <summary>
    /// The request or event that necessitated this assessment. This may be a diagnosis, a Care Plan, a Request Referral, or some other resource.
    /// </summary>
    public CodeableConcept TriggerCodeableConcept { get; set; }
    /// <summary>
    /// The request or event that necessitated this assessment. This may be a diagnosis, a Care Plan, a Request Referral, or some other resource.
    /// </summary>
    public Reference TriggerReference { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR2.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (Patient != null)
      {
        writer.WritePropertyName("patient");
        Patient.SerializeJson(writer, options);
      }

      if (Assessor != null)
      {
        writer.WritePropertyName("assessor");
        Assessor.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (Previous != null)
      {
        writer.WritePropertyName("previous");
        Previous.SerializeJson(writer, options);
      }

      if ((Problem != null) && (Problem.Count != 0))
      {
        writer.WritePropertyName("problem");
        writer.WriteStartArray();

        foreach (Reference valProblem in Problem)
        {
          valProblem.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (TriggerCodeableConcept != null)
      {
        writer.WritePropertyName("triggerCodeableConcept");
        TriggerCodeableConcept.SerializeJson(writer, options);
      }

      if (TriggerReference != null)
      {
        writer.WritePropertyName("triggerReference");
        TriggerReference.SerializeJson(writer, options);
      }

      if ((Investigations != null) && (Investigations.Count != 0))
      {
        writer.WritePropertyName("investigations");
        writer.WriteStartArray();

        foreach (ClinicalImpressionInvestigations valInvestigations in Investigations)
        {
          valInvestigations.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Protocol))
      {
        writer.WriteString("protocol", (string)Protocol!);
      }

      if (_Protocol != null)
      {
        writer.WritePropertyName("_protocol");
        _Protocol.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Summary))
      {
        writer.WriteString("summary", (string)Summary!);
      }

      if (_Summary != null)
      {
        writer.WritePropertyName("_summary");
        _Summary.SerializeJson(writer, options);
      }

      if ((Finding != null) && (Finding.Count != 0))
      {
        writer.WritePropertyName("finding");
        writer.WriteStartArray();

        foreach (ClinicalImpressionFinding valFinding in Finding)
        {
          valFinding.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Resolved != null) && (Resolved.Count != 0))
      {
        writer.WritePropertyName("resolved");
        writer.WriteStartArray();

        foreach (CodeableConcept valResolved in Resolved)
        {
          valResolved.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((RuledOut != null) && (RuledOut.Count != 0))
      {
        writer.WritePropertyName("ruledOut");
        writer.WriteStartArray();

        foreach (ClinicalImpressionRuledOut valRuledOut in RuledOut)
        {
          valRuledOut.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Prognosis))
      {
        writer.WriteString("prognosis", (string)Prognosis!);
      }

      if (_Prognosis != null)
      {
        writer.WritePropertyName("_prognosis");
        _Prognosis.SerializeJson(writer, options);
      }

      if ((Plan != null) && (Plan.Count != 0))
      {
        writer.WritePropertyName("plan");
        writer.WriteStartArray();

        foreach (Reference valPlan in Plan)
        {
          valPlan.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Action != null) && (Action.Count != 0))
      {
        writer.WritePropertyName("action");
        writer.WriteStartArray();

        foreach (Reference valAction in Action)
        {
          valAction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "action":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Action = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objAction = new fhirCsR2.Models.Reference();
            objAction.DeserializeJson(ref reader, options);
            Action.Add(objAction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Action.Count == 0)
          {
            Action = null;
          }

          break;

        case "assessor":
          Assessor = new fhirCsR2.Models.Reference();
          Assessor.DeserializeJson(ref reader, options);
          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR2.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR2.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "finding":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Finding = new List<ClinicalImpressionFinding>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ClinicalImpressionFinding objFinding = new fhirCsR2.Models.ClinicalImpressionFinding();
            objFinding.DeserializeJson(ref reader, options);
            Finding.Add(objFinding);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Finding.Count == 0)
          {
            Finding = null;
          }

          break;

        case "investigations":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Investigations = new List<ClinicalImpressionInvestigations>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ClinicalImpressionInvestigations objInvestigations = new fhirCsR2.Models.ClinicalImpressionInvestigations();
            objInvestigations.DeserializeJson(ref reader, options);
            Investigations.Add(objInvestigations);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Investigations.Count == 0)
          {
            Investigations = null;
          }

          break;

        case "patient":
          Patient = new fhirCsR2.Models.Reference();
          Patient.DeserializeJson(ref reader, options);
          break;

        case "plan":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Plan = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objPlan = new fhirCsR2.Models.Reference();
            objPlan.DeserializeJson(ref reader, options);
            Plan.Add(objPlan);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Plan.Count == 0)
          {
            Plan = null;
          }

          break;

        case "previous":
          Previous = new fhirCsR2.Models.Reference();
          Previous.DeserializeJson(ref reader, options);
          break;

        case "problem":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Problem = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.Reference objProblem = new fhirCsR2.Models.Reference();
            objProblem.DeserializeJson(ref reader, options);
            Problem.Add(objProblem);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Problem.Count == 0)
          {
            Problem = null;
          }

          break;

        case "prognosis":
          Prognosis = reader.GetString();
          break;

        case "_prognosis":
          _Prognosis = new fhirCsR2.Models.Element();
          _Prognosis.DeserializeJson(ref reader, options);
          break;

        case "protocol":
          Protocol = reader.GetString();
          break;

        case "_protocol":
          _Protocol = new fhirCsR2.Models.Element();
          _Protocol.DeserializeJson(ref reader, options);
          break;

        case "resolved":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Resolved = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.CodeableConcept objResolved = new fhirCsR2.Models.CodeableConcept();
            objResolved.DeserializeJson(ref reader, options);
            Resolved.Add(objResolved);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Resolved.Count == 0)
          {
            Resolved = null;
          }

          break;

        case "ruledOut":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          RuledOut = new List<ClinicalImpressionRuledOut>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR2.Models.ClinicalImpressionRuledOut objRuledOut = new fhirCsR2.Models.ClinicalImpressionRuledOut();
            objRuledOut.DeserializeJson(ref reader, options);
            RuledOut.Add(objRuledOut);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (RuledOut.Count == 0)
          {
            RuledOut = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR2.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "summary":
          Summary = reader.GetString();
          break;

        case "_summary":
          _Summary = new fhirCsR2.Models.Element();
          _Summary.DeserializeJson(ref reader, options);
          break;

        case "triggerCodeableConcept":
          TriggerCodeableConcept = new fhirCsR2.Models.CodeableConcept();
          TriggerCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "triggerReference":
          TriggerReference = new fhirCsR2.Models.Reference();
          TriggerReference.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR2.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ClinicalImpression.status field
  /// </summary>
  public static class ClinicalImpressionStatusCodes {
    public const string IN_PROGRESS = "in-progress";
    public const string COMPLETED = "completed";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public static HashSet<string> Values = new HashSet<string>() {
      "in-progress",
      "completed",
      "entered-in-error",
    };
  }
}
