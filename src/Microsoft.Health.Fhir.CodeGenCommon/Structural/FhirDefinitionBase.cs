// <copyright file="FhirDefinitionBase.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
//     Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.
// </copyright>

using System.Diagnostics.CodeAnalysis;
using Microsoft.Health.Fhir.CodeGenCommon.Extensions;
using static Microsoft.Health.Fhir.CodeGenCommon.Extensions.FhirNameConventionExtensions;

namespace Microsoft.Health.Fhir.CodeGenCommon.Structural;

/// <summary>A FHIR definition base.</summary>
public abstract record class FhirDefinitionBase : ICloneable
{
    internal string _name = string.Empty;
    internal string _nameCapitalized = string.Empty;
    internal string _path = string.Empty;
    internal string _baseTypeName = string.Empty;
    internal string _baseTypeCanonical = string.Empty;

    /// <summary>Initializes a new instance of the FhirDefinitionBase class.</summary>
    public FhirDefinitionBase() { }

    /// <summary>Initializes a new instance of the FhirDefinitionBase class.</summary>
    /// <param name="other">The other.</param>
    [SetsRequiredMembers]
    protected FhirDefinitionBase(FhirDefinitionBase other)
    {
        Id = other.Id;
        Name = other.Name;
        Path = other.Path;
        Url = other.Url;
        BaseTypeName = other.BaseTypeName;
        BaseTypeCanonical = other.BaseTypeCanonical;
        ShortDescription = other.ShortDescription;
        Purpose = other.Purpose;
        Comment = other.Comment;
        ValidationRegEx = other.ValidationRegEx;
    }

    /// <summary>Gets the Id for this element/resource/datatype.</summary>
    /// <value>The Id for this element/resource/datatype.</value>
    public required string Id { get; init; }

    /// <summary>
    /// Gets a natural language name identifying the structure definition. This name should be usable as an
    /// identifier for the module by machine processing applications such as code generation.
    /// </summary>
    /// <value>The name.</value>
    public required string Name
    {
        get => _name;
        init
        {
            _name = value;
            _nameCapitalized = _name.ToPascalCase();
        }
    }

    /// <summary>
    /// Gets name field with the first letter capitalized, useful in various languages and PascalCase joining.
    /// </summary>
    /// <value>The name capitalized.</value>
    public string NameCapitalized => _nameCapitalized;

    /// <summary>Gets the dot-notation path to this element/resource/datatype.</summary>
    /// <value>The dot-notation path to this element/resource/datatype.</value>
    public required string Path { get => _path; init => _path = value; }

    /// <summary>Gets URL of the document.</summary>
    public required string Url { get; init; }

    /// <summary>Gets or sets the Name of the type this type inherits from (null if none).</summary>
    public required string BaseTypeName { get => _baseTypeName; init => _baseTypeName = value; }

    /// <summary>Gets or sets the Canonical of the type this type inherits from (null if none).</summary>
    /// <value>The name of the base type.</value>
    public string BaseTypeCanonical { get => _baseTypeCanonical; init => _baseTypeCanonical = value; }

    /// <summary>
    /// Gets a concise description of what this element means (e.g. for use in autogenerated summaries).
    /// </summary>
    /// <value>The description.</value>
    public string ShortDescription { get; init; } = string.Empty;

    /// <summary>
    /// Gets a complete explanation of the meaning of the data element for human readability.  For
    /// the case of elements derived from existing elements (e.g. constraints), the definition SHALL be
    /// consistent with the base definition, but convey the meaning of the element in the particular
    /// context of use of the resource. (Note: The text you are reading is specified in
    /// ElementDefinition.definition).
    /// </summary>
    /// <value>The definition.</value>
    public string Purpose { get; init; } = string.Empty;

    /// <summary>
    /// Gets explanatory notes and implementation guidance about the data element, including notes about how
    /// to use the data properly, exceptions to proper use, etc. (Note: The text you are reading is
    /// specified in ElementDefinition.comment).
    /// </summary>
    /// <value>The comment.</value>
    public string Comment { get; init; } = string.Empty;

    /// <summary>
    /// Gets a RegEx string used to validate values in this property.
    /// </summary>
    /// <value>The validation RegEx.</value>
    public string ValidationRegEx { get; init; } = string.Empty;

    /// <summary>Type for export.</summary>
    /// <param name="convention">            The convention.</param>
    /// <param name="primitiveTypeMap">      The base type map.</param>
    /// <param name="concatenatePath">       (Optional) True to concatenate path.</param>
    /// <param name="concatenationDelimiter">(Optional) The concatenation delimiter.</param>
    /// <param name="reservedWords">         (Optional) The reserved words.</param>
    /// <returns>A string.</returns>
    public string TypeForExport(
        NamingConvention convention,
        Dictionary<string, string> primitiveTypeMap,
        bool concatenatePath = false,
        string concatenationDelimiter = "",
        HashSet<string> reservedWords = null!)
    {
        if (primitiveTypeMap?.ContainsKey(_baseTypeName) ?? false)
        {
            return primitiveTypeMap[_baseTypeName];
        }

        // Resources cannot inherit patterns or interfaces, but they are listed that way today
        // see https://chat.fhir.org/#narrow/stream/179177-conformance/topic/Inheritance.20and.20Cardinality.20Changes
        string baseType = _baseTypeName switch
        {
            "CanonicalResource" or "MetadataResource" => "DomainResource",
            _ => _baseTypeName,
        };

        string type = Models.FhirUtils.ToConvention(
            baseType,
            _path,
            convention,
            concatenatePath,
            concatenationDelimiter,
            reservedWords);

        return type;
    }

    /// <summary>Converts this object to a requested naming convention.</summary>
    /// <exception cref="ArgumentException">Thrown when one or more arguments have unsupported or
    ///  illegal values.</exception>
    /// <param name="convention">            The convention.</param>
    /// <param name="concatenatePath">       (Optional) True to concatenate path.</param>
    /// <param name="delimiter">(Optional) The concatenation delimiter.</param>
    /// <param name="reservedWords">         (Optional) The reserved words.</param>
    /// <returns>A string.</returns>
    public string NameForExport(
        NamingConvention convention,
        bool concatenatePath = false,
        string delimiter = "",
        HashSet<string> reservedWords = null!)
    {
        if (string.IsNullOrEmpty(_name))
        {
            throw new ArgumentException($"Invalid Name: {_name}");
        }

        if (string.IsNullOrEmpty(_nameCapitalized))
        {
            throw new ArgumentException($"Invalid Name: {_nameCapitalized}");
        }

        if (string.IsNullOrEmpty(_path))
        {
            throw new ArgumentException($"Invalid Path: {_path}");
        }

        string value = convention switch
        {
            NamingConvention.FhirDotNotation => _path,
            NamingConvention.PascalDotNotation => _path.ToPascalDotCase(),
            NamingConvention.PascalCase => concatenatePath ? _path.ToPascalCase(true, delimiter) : _nameCapitalized,
            NamingConvention.CamelCase => concatenatePath ? _path.ToCamelCase(true, delimiter) : _name.ToCamelCase(false),
            NamingConvention.UpperCase => concatenatePath ? _path.ToUpperCase(true, delimiter) : _name.ToUpperInvariant(),
            NamingConvention.LowerCase => concatenatePath ? _path.ToLowerCase(true, delimiter) : _name.ToLowerInvariant(),
            NamingConvention.LowerKebab => concatenatePath ? _path.ToLowerKebabCase(true) : _name.ToLowerKebabCase(),
            //NamingConvention.None => throw new NotImplementedException(),
            //NamingConvention.LanguageControlled => throw new NotImplementedException(),
            _ => throw new ArgumentException($"Cannot convert to Naming Convention: {convention}"),
        };

        if (reservedWords?.Contains(value) ?? false)
        {
            value = convention switch
            {
                NamingConvention.FhirDotNotation => "Fhir" + value,
                NamingConvention.PascalDotNotation => "Fhir" + value,
                NamingConvention.PascalCase => "Fhir" + value,
                NamingConvention.CamelCase => "fhir" + value.ToPascalCase(false),
                NamingConvention.UpperCase => concatenatePath ? "FHIR_" + value : "FHIR" + value,
                NamingConvention.LowerCase => concatenatePath ? "fhir_" + value : "fhir" + value,
                NamingConvention.LowerKebab => concatenatePath ? "fhir_" + value : "fhir" + value,
                _ => throw new ArgumentException($"Cannot convert to Naming Convention: {convention}"),
            };
        }

        return value;
    }

    /// <summary>Makes a deep copy of this object.</summary>
    /// <returns>A copy of this object.</returns>
    object ICloneable.Clone() => this with { };
}
