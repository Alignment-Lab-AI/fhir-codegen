using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using Microsoft.Health.Fhir.CodeGenCommon.Extensions;
using static Microsoft.Health.Fhir.CodeGenCommon.Extensions.FhirNameConventionExtensions;

namespace Microsoft.Health.Fhir.CodeGenCommon.BaseModels;

public abstract record class FhirArtifactBase : FhirBase, ICloneable
{
    internal string _name = string.Empty;
    internal string _namePascal = string.Empty;
    internal string _baseTypeName = string.Empty;
    internal string _baseTypeCanonical = string.Empty;

    public FhirArtifactBase() : base() { }

    [SetsRequiredMembers]
    protected FhirArtifactBase(FhirArtifactBase other)
        : base(other)
    {
        Name = other.Name;
        Url = other.Url;
        BaseTypeName = other.BaseTypeName;
        BaseTypeCanonical = other.BaseTypeCanonical;
        ShortDescription = other.ShortDescription;
        Purpose = other.Purpose;
        Comment = other.Comment;
        ValidationRegEx = other.ValidationRegEx;
    }

    /// <summary>
    /// Gets a natural language name identifying the structure definition. This name should be usable as an
    /// identifier for the module by machine processing applications such as code generation.
    /// </summary>
    /// <value>The name.</value>
    public required string Name
    {
        get => _name;
        init
        {
            _name = value;
            _namePascal = _name.ToPascalCase();
        }
    }

    /// <summary>
    /// Gets name field with the first letter capitalized, useful in various languages and PascalCase joining.
    /// </summary>
    /// <value>The name capitalized.</value>
    public string NamePascal => _namePascal;

    /// <summary>Gets URL of the document.</summary>
    public required string Url { get; init; }


    /// <summary>Gets or sets the Name of the type this type inherits from (null if none).</summary>
    public required string BaseTypeName { get => _baseTypeName; init => _baseTypeName = value; }

    /// <summary>Gets or sets the Canonical of the type this type inherits from (null if none).</summary>
    /// <value>The name of the base type.</value>
    public string BaseTypeCanonical { get => _baseTypeCanonical; init => _baseTypeCanonical = value; }

    /// <summary>
    /// Gets a concise description of what this element means (e.g. for use in autogenerated summaries).
    /// </summary>
    /// <value>The description.</value>
    public string ShortDescription { get; init; } = string.Empty;

    /// <summary>
    /// Gets a complete explanation of the meaning of the data element for human readability.  For
    /// the case of elements derived from existing elements (e.g. constraints), the definition SHALL be
    /// consistent with the base definition, but convey the meaning of the element in the particular
    /// context of use of the resource. (Note: The text you are reading is specified in
    /// ElementDefinition.definition).
    /// </summary>
    /// <value>The definition.</value>
    public string Purpose { get; init; } = string.Empty;

    /// <summary>
    /// Gets explanatory notes and implementation guidance about the data element, including notes about how
    /// to use the data properly, exceptions to proper use, etc. (Note: The text you are reading is
    /// specified in ElementDefinition.comment).
    /// </summary>
    /// <value>The comment.</value>
    public string Comment { get; init; } = string.Empty;

    /// <summary>
    /// Gets a RegEx string used to validate values in this property.
    /// </summary>
    /// <value>The validation RegEx.</value>
    public string ValidationRegEx { get; init; } = string.Empty;

    /// <summary>Converts this object to a requested naming convention.</summary>
    /// <exception cref="ArgumentException">Thrown when one or more arguments have unsupported or
    ///  illegal values.</exception>
    /// <param name="convention">            The convention.</param>
    /// <param name="concatenatePath">       (Optional) True to concatenate path.</param>
    /// <param name="delimiter">(Optional) The concatenation delimiter.</param>
    /// <param name="reservedWords">         (Optional) The reserved words.</param>
    /// <returns>A string.</returns>
    public string NameForExport(
        NamingConvention convention,
        bool concatenatePath = false,
        string delimiter = "",
        HashSet<string> reservedWords = null!)
    {
        if (string.IsNullOrEmpty(_name))
        {
            throw new ArgumentException($"Invalid Name: {_name}");
        }

        if (string.IsNullOrEmpty(_namePascal))
        {
            throw new ArgumentException($"Invalid Name: {_namePascal}");
        }

        string value = convention switch
        {
            NamingConvention.FhirDotNotation => _name,
            NamingConvention.PascalDotNotation => _namePascal,
            NamingConvention.PascalCase => _namePascal,
            NamingConvention.CamelCase => _name.ToCamelCase(false),
            NamingConvention.UpperCase => _name.ToUpperInvariant(),
            NamingConvention.LowerCase => _name.ToLowerInvariant(),
            NamingConvention.LowerKebab => _name.ToLowerKebabCase(),
            //NamingConvention.None => throw new NotImplementedException(),
            //NamingConvention.LanguageControlled => throw new NotImplementedException(),
            _ => throw new ArgumentException($"Cannot convert to Naming Convention: {convention}"),
        };

        if (reservedWords?.Contains(value) ?? false)
        {
            value = convention switch
            {
                NamingConvention.FhirDotNotation => "Fhir" + value,
                NamingConvention.PascalDotNotation => "Fhir" + value,
                NamingConvention.PascalCase => "Fhir" + value,
                NamingConvention.CamelCase => "fhir" + value.ToPascalCase(false),
                NamingConvention.UpperCase => concatenatePath ? "FHIR_" + value : "FHIR" + value,
                NamingConvention.LowerCase => concatenatePath ? "fhir_" + value : "fhir" + value,
                NamingConvention.LowerKebab => concatenatePath ? "fhir_" + value : "fhir" + value,
                _ => throw new ArgumentException($"Cannot convert to Naming Convention: {convention}"),
            };
        }

        return value;
    }

    /// <summary>Makes a deep copy of this object.</summary>
    /// <returns>A copy of this object.</returns>
    object ICloneable.Clone() => this with { };
}
