@page "/view/package/elements"

@using FhirCodeGenBlazor.Models;
@using FhirCodeGenBlazor.Services;
@using Markdig;
@using Microsoft.CodeAnalysis.CSharp.Scripting;
@using Microsoft.CodeAnalysis.Scripting;
@using Microsoft.Health.Fhir.CodeGenCommon.Models;
@using Microsoft.Health.Fhir.SpecManager.Manager;
@using System.IO;
@using System.Text.RegularExpressions;
@using System.Linq;
@inject NavigationManager NavigationManager
@inject ISpecManagerWebService SpecService
@inject IJSRuntime JS
@implements IDisposable
@implements IPackageVersionProvider

@if (string.IsNullOrEmpty(directive))
{
    <PageTitle>FHIR Element Search</PageTitle>
    <p><em>This page requires a package name and version, please select...</em></p>
}
else if (SpecService.ContainsKey(directive) && SpecService[directive].ArtifactRecordsByClass.Any())
{
    <PageTitle>@directive</PageTitle>
    <p>
        @foreach ((FhirArtifactClassEnum classEnum, bool visible) in showArtifactClass)
        {
            <button type="button"
                class=@GetButtonClass(visible)
                @onclick="() => ToggleShowState(classEnum)">
                @classEnum.ToString() (@SpecService[directive].ArtifactRecordsByClass[classEnum].Count())
            </button>
        }
    </p>
    <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" role="switch" id="switchToggleDetails" @bind="showDetailedInfo" />
        <label for="switchToggleDetails" class="form-label">Show Element Details</label>
    </div>

    <div class="form-control mb-2">
        <label class="form-check-label">
            <input class="form-check-input mb-2" type="radio" name="filterType" id="radioFilterTypeBasic" checked="@filterValueType.Equals("basicName")" onchange="@((ChangeEventArgs __e) => ChangeFilterType("basicName"))" />
            Basic string match on <code>Name</code> property
        </label>
        <br />

        <label class="form-check-label">
            <input class="form-check-input mb-2" type="radio" name="filterType" id="radioFilterTypeRegex" checked="@filterValueType.Equals("regexName")" onchange="@((ChangeEventArgs __e) => ChangeFilterType("regexName"))" />
            Regex matching on <code>Name</code> property
        </label>
        <br />

        <label class="form-check-label">
            <input class="form-check-input" type="radio" name="filterType" id="radioFilterTypeLinq" checked="@filterValueType.Equals("linq")" onchange="@((ChangeEventArgs __e) => ChangeFilterType("linq"))" />
            LINQ query on <code>FhirElement</code> objects
        </label>
        <br />
    </div>

    <div class="input-group">
        <span class="input-group-text" id="basic-addon1">Element Filter</span>
        <input
            type="text"
            placeholder="Filter"
            aria-label="Filter"
            aria-describedby="basic-addon1"
            @bind-value="elementFilterText"
            @oninput="@((ChangeEventArgs e) => InvokeAsync(() => RebuildFilteredElements(e?.Value?.ToString() ?? "")))"
            />
        <span class="ms-2 mt-2">@filteredElements.Count elements found</span>
    </div>

    <div class="input-group">
        <button type="button" class="btn-primary m-1" @onclick="(() => DownloadElementPathsJson())">
            Download Element Paths JSON
        </button>
        <button type="button" class="btn-primary m-1" @onclick="(() => DownloadFhirElementsJson())">
            Download Element JSON
        </button>
    </div>

    <table class="table table-striped table-hover">
        <thead>
            <tr>
                <th class="col-md-2">Element</th>
                <th class="col-md-1">Flags</th>
                <th class="col-md-1">Type</th>
                <th class="col-md-1">Card.</th>
                <th class="col-md-3">Short</th>
            </tr>
        </thead>
        <tbody>
            @foreach (ElementRecord rec in filteredElements)
            {
                <tr class="@GetTrClass()">
                    <td>
                        <span class="fw-bold">@rec.Element.Path</span><br/>
                        <span class="fst-italic">Defined by @rec.DefinedByClass:</span> <span class="fw-bold">@rec.RootComplex.Path</span>
                        @if (!string.IsNullOrEmpty(rec.Element.FixedFieldName))
                        {
                            <span class="text-danger">&nbsp;*</span><span>fixed to:</span>
                            <span class="font-monospace bg-dark bg-opacity-50 text-light p-1">@rec.Element.FixedFieldValue</span>
                        }
                    </td>
                    <td>
                        @if (rec.Element.IsMustSupport)
                        {
                            <span data-bs-toggle="tooltip" title="Must Support">Ⓜ️ </span>
                        }

                        @if (rec.Element.IsModifier)
                        {
                            <span data-bs-toggle="tooltip" title="@(rec.Element.IsModifierReason ?? "Modifier Element")">⁈ </span>
                        }

                        @if (rec.Element.IsSummary)
                        {
                            <span data-bs-toggle="tooltip" title="Included in Summary">∑ </span>
                        }
                    </td>
                    <td class="text-wrap">@GetElementTypeString(rec.Element)</td>
                    <td>@rec.Element.FhirCardinality</td>
                    <td>
                        @rec.Element.ShortDescription
                    </td>
                </tr>

                @if (showDetailedInfo)
                {
                    <tr>
                        <td colspan="5">
                            <div class="small">
                                <strong>Definition:</strong><p>@rec.Element.Purpose</p>

                                <strong>Comments:</strong>
                                @(new MarkupString(Markdown.ToHtml(rec.Element.Comment)))

                                @if (!string.IsNullOrEmpty(rec.Element.ValueSet))
                                {
                                    <p><strong>Bound to:</strong> @rec.Element.ValueSet (@rec.Element.ValueSetBindingStrength)</p>
                                }

                                @if (!string.IsNullOrEmpty(rec.Element.ValidationRegEx))
                                {
                                    <p><strong>Validation RegEx:</strong> @rec.Element.ValidationRegEx</p>
                                }
                            </div>
                        </td>
                    </tr>
                }
            }
        </tbody>
    </table>
}
else
{
    <PageTitle>@directive</PageTitle>
    <p><em>This package contains no supported artifacts.</em></p>
}

@code {
    /// <summary>(Immutable) List of types of the filters.</summary>
    private static readonly Dictionary<string,string> _filterTypes = new()
    {
        { "basicName", "Basic string match on <code>Name</code> property" },
        { "regexName", "Regex matching on <code>Name</code> property" },
        { "linq",      "LINQ query on <code>FhirElement</code> objects" },
    };

    /// <summary>Specifies the filter.</summary>
    private string elementFilterText = "";

    /// <summary>Type of the filter value.</summary>
    private string filterValueType = "basicName";

    /// <summary>The show artifact class.</summary>
    private Dictionary<FhirArtifactClassEnum, bool> showArtifactClass = new()
    {
        { FhirArtifactClassEnum.ComplexType, true },
        { FhirArtifactClassEnum.Resource, true },
        { FhirArtifactClassEnum.Extension, true },
        { FhirArtifactClassEnum.Profile, true },
        { FhirArtifactClassEnum.LogicalModel, false }
    };

    /// <summary>
    /// Gets or sets a value indicating whether the detailed information is shown.
    /// </summary>
    private bool showDetailedInfo { get; set; } = true;

    /// <summary>Gets or sets the navigation tracker.</summary>
    [CascadingParameter]
    public INavTracker? NavTracker { get; set; } = null;

    /// <summary>Gets or sets the package name.</summary>
    [Parameter]
    [SupplyParameterFromQuery(Name = "packageName")]
    public string PackageName { get; set; } = "";

    /// <summary>Gets or sets the package version.</summary>
    [Parameter]
    [SupplyParameterFromQuery(Name = "version")]
    public string Version { get; set; } = "";

    /// <summary>The directive.</summary>
    private string directive = string.Empty;

    /// <summary>Information about the element.</summary>
    private readonly record struct ElementRecord(
        FhirArtifactClassEnum DefinedByClass,
        FhirComplex RootComplex,
        FhirElement Element);

    private List<ElementRecord> filteredElements = new();

    /// <summary>Options for controlling the create structure script.</summary>
    private ScriptOptions csScriptOpts = ScriptOptions.Default
        .AddReferences(
            typeof(FhirElement).Assembly,
            typeof(SpecManagerWebService).Assembly,
            AppDomain.CurrentDomain.GetAssemblies().SingleOrDefault(a => a.GetName().Name?.Equals("System.Linq") ?? false))
        .AddImports("System.Linq");

    /// <summary>Executes the initialized asynchronous action.</summary>
    /// <returns>An asynchronous result.</returns>
    protected override void OnInitialized()
    {
        base.OnInitialized();

        directive = PackageName + "#" + Version;

        NavTracker?.NotifyNav(directive, $"view/package/elements?packageName={PackageName}&version={Version}", 1);
        NavigationManager.LocationChanged += HandleLocationChanged;

        Task.Run(() => RebuildFilteredElements(string.Empty));
    }

    /// <summary>
    /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged
    /// resources.
    /// </summary>
    public void Dispose()
    {
        NavigationManager.LocationChanged -= HandleLocationChanged;
    }

    /// <summary>Gets tr class.</summary>
    /// <returns>The tr class.</returns>
    private string GetTrClass()
    {
        if (showDetailedInfo)
        {
            return "table-active";
        }

        return string.Empty;
    }

    /// <summary>Gets element type string.</summary>
    /// <param name="element">The element.</param>
    /// <returns>The element type string.</returns>
    private string GetElementTypeString(FhirElement element)
    {
        if (element.BaseTypeName.Equals(element.Id, StringComparison.Ordinal))
        {
            return "BackboneElement";
        }

        if (!string.IsNullOrEmpty(element.BaseTypeName))
        {
            return element.BaseTypeName;
        }

        return string.Join(
            ", ",
            element.ElementTypes.Values.Select(
                et => et.Profiles.Any()
                    ? $"{et.Name}( {string.Join(" | ", et.Profiles.Values.Select(p => p.Name))} )"
                    : et.Name));
    }

    /// <summary>Artifacts updated.</summary>
    /// <param name="sender">The sender.</param>
    /// <param name="e">     Artifact index changed event information.</param>
    private void ArtifactsUpdated(object? sender, ArtifactIndexChangedEventArgs e)
    {
        if ((e.PackageName == PackageName) && (e.Version == Version))
        {
            RebuildFilteredElements(elementFilterText);
        }
    }

    /// <summary>Handles the location changed.</summary>
    /// <param name="sender">The sender.</param>
    /// <param name="e">     Location changed event information.</param>
    private void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        if (e.Location.ToLowerInvariant().Contains("/view/package/elements"))
        {
            directive = PackageName + "#" + Version;

            NavTracker?.NotifyNav(directive, $"view/package/elements?packageName={PackageName}&version={Version}", 1);

            Task.Run(() => RebuildFilteredElements(elementFilterText));
        }
    }

    /// <summary>Adds the elements from complex.</summary>
    /// <param name="filter">       Specifies the filter.</param>
    /// <param name="complex">      The complex.</param>
    /// <param name="elements">     The elements.</param>
    /// <param name="rootComplex">  The root complex.</param>
    /// <param name="artifactClass">The artifact class.</param>
    private void AddElementsFromComplex(
        string filter,
        FhirComplex complex,
        List<ElementRecord> elements,
        FhirComplex rootComplex,
        FhirArtifactClassEnum artifactClass)
    {
        if (string.IsNullOrEmpty(filter) || (complex == null))
        {
            return;
        }

        if (complex.Components != null)
        {
            foreach (FhirComplex component in complex.Components.Values)
            {
                AddElementsFromComplex(filter, component, elements, rootComplex, artifactClass);
            }
        }

        if (complex.Elements != null)
        {
            foreach (FhirElement element in complex.Elements.Values)
            {
                if (element.Name.Contains(filter, StringComparison.OrdinalIgnoreCase))
                {
                    elements.Add(new ElementRecord(
                        artifactClass,
                        rootComplex,
                        element));
                }
            }
        }
    }

    /// <summary>Adds the elements from complex.</summary>
    /// <param name="expression">   The expression.</param>
    /// <param name="complex">      The complex.</param>
    /// <param name="elements">     The elements.</param>
    /// <param name="rootComplex">  The root complex.</param>
    /// <param name="artifactClass">The artifact class.</param>
    private void AddElementsFromComplex(
        Regex expression,
        FhirComplex complex,
        List<ElementRecord> elements,
        FhirComplex rootComplex,
        FhirArtifactClassEnum artifactClass)
    {
        if ((expression == null) || (complex == null))
        {
            return;
        }

        if (complex.Components != null)
        {
            foreach (FhirComplex component in complex.Components.Values)
            {
                AddElementsFromComplex(expression, component, elements, rootComplex, artifactClass);
            }
        }

        if (complex.Elements != null)
        {
            foreach (FhirElement element in complex.Elements.Values)
            {
                if (expression.IsMatch(element.Name))
                {
                    elements.Add(new ElementRecord(
                        artifactClass,
                        rootComplex,
                        element));
                }
            }
        }
    }

    /// <summary>Adds the elements from complex.</summary>
    /// <param name="predicate">    The predicate.</param>
    /// <param name="complex">      The complex.</param>
    /// <param name="elements">     The elements.</param>
    /// <param name="rootComplex">  The root complex.</param>
    /// <param name="artifactClass">The artifact class.</param>
    private void AddElementsFromComplex(
        Func<FhirElement, bool> predicate,
        FhirComplex complex,
        List<ElementRecord> elements,
        FhirComplex rootComplex,
        FhirArtifactClassEnum artifactClass)
    {
        if ((predicate == null) || (complex == null))
        {
            return;
        }

        if (complex.Components != null)
        {
            foreach (FhirComplex component in complex.Components.Values)
            {
                AddElementsFromComplex(predicate, component, elements, rootComplex, artifactClass);
            }
        }

        if (complex.Elements != null)
        {
            foreach (FhirElement element in complex.Elements.Values.Where(predicate))
            {
                elements.Add(new ElementRecord(
                    artifactClass,
                    rootComplex,
                    element));
            }
        }
    }

    /// <summary>A script globals.</summary>
    public class ScriptGlobals
    {
        /// <summary>Gets the FhirVersionInfo.</summary>
        public FhirVersionInfo Info { get; }

        /// <summary>Initializes a new instance of the ScriptGlobals class.</summary>
        /// <param name="info">The information.</param>
        public ScriptGlobals(FhirVersionInfo info)
        {
            Info = info;
        }
    }

    /// <summary>Rebuild filtered elements.</summary>
    /// <param name="appliedFilter">(Optional) A filter specifying the applied.</param>
    private async void RebuildFilteredElements(string appliedFilter = "")
    {
        elementFilterText = appliedFilter;

        if (appliedFilter.Length < 3)
        {
            filteredElements.Clear();
            return;
        }

        List<ElementRecord> filtered = new();

        switch (filterValueType)
        {
            case "basicName":
                {
                    foreach ((FhirArtifactClassEnum artifactClass, bool visible) in showArtifactClass)
                    {
                        if (!visible)
                        {
                            continue;
                        }

                        if (SpecService[directive].TryGetArtifactValues<FhirComplex>(artifactClass, out IEnumerable<FhirComplex> values))
                        {
                            foreach (FhirComplex complex in values)
                            {
                                AddElementsFromComplex(appliedFilter, complex, filtered, complex, artifactClass);
                            }
                        }
                    }
                }
                break;

            case "regexName":
                {
                    try
                    {
                        Regex expression = new(appliedFilter);

                        foreach ((FhirArtifactClassEnum artifactClass, bool visible) in showArtifactClass)
                        {
                            if (!visible)
                            {
                                continue;
                            }

                            if (SpecService[directive].TryGetArtifactValues<FhirComplex>(artifactClass, out IEnumerable<FhirComplex> values))
                            {
                                foreach (FhirComplex complex in values)
                                {
                                    AddElementsFromComplex(expression, complex, filtered, complex, artifactClass);
                                }
                            }
                        }
                    }
                    catch (Exception)
                    {
                        filteredElements.Clear();
                        return;
                    }
                }
                break;

            case "linq":
                {
                    Func<FhirElement, bool> predicate;

                    try
                    {
                        predicate = CSharpScript.EvaluateAsync<Func<FhirElement, bool>>(
                            appliedFilter,
                            csScriptOpts,
                            new ScriptGlobals(SpecService[directive])
                        ).Result;
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"RebuildFilteredElements <<< caught exception processing linq filter: {ex.Message}");
                        if (ex.InnerException != null)
                        {
                            Console.WriteLine($" <<< inner: {ex.InnerException.Message}");
                        }
                        filteredElements.Clear();
                        return;
                    }

                    try
                    {
                        foreach ((FhirArtifactClassEnum artifactClass, bool visible) in showArtifactClass)
                        {
                            if (!visible)
                            {
                                continue;
                            }

                            if (SpecService[directive].TryGetArtifactValues<FhirComplex>(artifactClass, out IEnumerable<FhirComplex> values))
                            {
                                foreach (FhirComplex complex in values)
                                {
                                    AddElementsFromComplex(predicate, complex, filtered, complex, artifactClass);
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"RebuildFilteredElements <<< caught exception processing linq filter: {ex.Message}");
                        if (ex.InnerException != null)
                        {
                            Console.WriteLine($" <<< inner: {ex.InnerException.Message}");
                        }
                        filteredElements.Clear();
                        return;
                    }
                }
                break;
        }

        filtered.Sort((a, b) => a.Element.Path.CompareTo(b.Element.Path));
        filteredElements = filtered;

        // manually flag state has changed in case we are in a callback / async context
        await InvokeAsync(() => StateHasChanged());
    }

    /// <summary>Links for artifact.</summary>
    /// <param name="record">The record.</param>
    /// <returns>A string.</returns>
    private string LinkForArtifact(FhirArtifactRecord record)
    {
        return $"/view/{record.ArtifactClass}/?packageName={PackageName}&version={Version}&url={record.Url}";
    }

    /// <summary>Toggle show state.</summary>
    /// <param name="classEnum">The class enum.</param>
    private void ToggleShowState(FhirArtifactClassEnum classEnum)
    {
        showArtifactClass[classEnum] = !showArtifactClass[classEnum];
        InvokeAsync(() => RebuildFilteredElements(elementFilterText));
    }

    /// <summary>Change filter type.</summary>
    /// <param name="filterType">Type of the filter.</param>
    private void ChangeFilterType(string filterType)
    {
        filterValueType = filterType;
        InvokeAsync(() => RebuildFilteredElements(elementFilterText));
    }

    private async void DownloadElementPathsJson()
    {
        /// <summary>The elements.</summary>
        IEnumerable<string> elements = filteredElements.Select<ElementRecord, string>(e => e.Element.Path);
        string content = System.Text.Json.JsonSerializer.Serialize(elements);
        using (Stream fs = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(content), false))
        using (DotNetStreamReference streamRef = new DotNetStreamReference(fs, false))
        {
            await JS.InvokeVoidAsync("downloadFileFromStream", "elementPaths.json", streamRef);
        }
    }

    /// <summary>Downloads the FHIR elements JSON.</summary>
    private async void DownloadFhirElementsJson()
    {
        IEnumerable<FhirElement> elements = filteredElements.Select<ElementRecord, FhirElement>(e => e.Element);
        string content = System.Text.Json.JsonSerializer.Serialize(elements);
        using (Stream fs = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(content), false))
        using (DotNetStreamReference streamRef = new DotNetStreamReference(fs, false))
        {
            await JS.InvokeVoidAsync("downloadFileFromStream", "elements.json", streamRef);
        }
    }

    /// <summary>Gets linq execute button class.</summary>
    /// <param name="currentFilterType">Type of the current filter.</param>
    /// <returns>The linq execute button class.</returns>
    private string GetLinqExecButtonClass(string currentFilterType)
    {
        if (currentFilterType.Equals("linq", StringComparison.Ordinal))
        {
            return "btn btn-primary ms-1";
        }

        return "btn btn-dark ms-1 disabled";
    }

    /// <summary>Gets button class.</summary>
    /// <param name="enabled">True to enable, false to disable.</param>
    /// <returns>The button class.</returns>
    private string GetButtonClass(bool enabled)
    {
        if (enabled)
        {
            return "btn btn-primary m-1";
        }

        return "btn btn-outline-primary m-1";
    }
}
