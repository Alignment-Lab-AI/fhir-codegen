// <auto-generated />
// Built from: hl7.fhir.r3.core version: 3.0.2
  // Option: "NAMESPACE" = "fhirCsR3"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR3.Serialization;

namespace fhirCsR3.Models
{
  /// <summary>
  /// Indicates who or what participated in producing the report.
  /// </summary>
  [JsonConverter(typeof(fhirCsR3.Serialization.JsonStreamComponentConverter<DiagnosticReportPerformer>))]
  public class DiagnosticReportPerformer : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// This is not necessarily the source of the atomic data items. It is the entity that takes responsibility for the clinical report.
    /// </summary>
    public Reference Actor { get; set; }
    /// <summary>
    /// Describes the type of participation (e.g.  a responsible party, author, or verifier).
    /// </summary>
    public CodeableConcept Role { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR3.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Role != null)
      {
        writer.WritePropertyName("role");
        Role.SerializeJson(writer, options);
      }

      if (Actor != null)
      {
        writer.WritePropertyName("actor");
        Actor.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actor":
          Actor = new fhirCsR3.Models.Reference();
          Actor.DeserializeJson(ref reader, options);
          break;

        case "role":
          Role = new fhirCsR3.Models.CodeableConcept();
          Role.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR3.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  /// </summary>
  [JsonConverter(typeof(fhirCsR3.Serialization.JsonStreamComponentConverter<DiagnosticReportImage>))]
  public class DiagnosticReportImage : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The comment should be displayed with the image. It would be common for the report to include additional discussion of the image contents in other sections such as the conclusion.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// Reference to the image source.
    /// </summary>
    public Reference Link { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR3.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if (Link != null)
      {
        writer.WritePropertyName("link");
        Link.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR3.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "link":
          Link = new fhirCsR3.Models.Reference();
          Link.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR3.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
  /// </summary>
  [JsonConverter(typeof(fhirCsR3.Serialization.JsonStreamComponentConverter<DiagnosticReport>))]
  public class DiagnosticReport : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "DiagnosticReport";
    /// <summary>
    /// Note: Usually there is one test request for each result, however in some circumstances multiple test requests may be represented using a single test result resource. Note that there are also cases where one request leads to multiple reports.
    /// </summary>
    public List<Reference> BasedOn { get; set; }
    /// <summary>
    /// The level of granularity is defined by the category concepts in the value set. More fine-grained filtering can be performed using the metadata and/or terminology hierarchy in DiagnosticReport.code.
    /// </summary>
    public CodeableConcept Category { get; set; }
    /// <summary>
    /// A code or name that describes this diagnostic report.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Codes for the conclusion.
    /// </summary>
    public List<CodeableConcept> CodedDiagnosis { get; set; }
    /// <summary>
    /// Concise and clinically contextualized impression / summary of the diagnostic report.
    /// </summary>
    public string Conclusion { get; set; }
    /// <summary>
    /// Extension container element for Conclusion
    /// </summary>
    public Element _Conclusion { get; set; }
    /// <summary>
    /// This will typically be the encounter the event occurred within, but some events may be initiated prior to or after the official completion of an encounter or episode but still be tied to the context of the encounter or episode (e.g. pre-admission lab tests).
    /// </summary>
    public Reference Context { get; set; }
    /// <summary>
    /// If the diagnostic procedure was performed on the patient, this is the time it was performed. If there are specimens, the diagnostically relevant time can be derived from the specimen collection times, but the specimen information is not always available, and the exact relationship between the specimens and the diagnostically relevant time is not always automatic.
    /// </summary>
    public string EffectiveDateTime { get; set; }
    /// <summary>
    /// Extension container element for EffectiveDateTime
    /// </summary>
    public Element _EffectiveDateTime { get; set; }
    /// <summary>
    /// If the diagnostic procedure was performed on the patient, this is the time it was performed. If there are specimens, the diagnostically relevant time can be derived from the specimen collection times, but the specimen information is not always available, and the exact relationship between the specimens and the diagnostically relevant time is not always automatic.
    /// </summary>
    public Period EffectivePeriod { get; set; }
    /// <summary>
    /// Usually assigned by the Information System of the diagnostic service provider (filler id).
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
    /// </summary>
    public List<DiagnosticReportImage> Image { get; set; }
    /// <summary>
    /// ImagingStudy and ImageManifest and the image element are somewhat overlapping - typically, the list of image references in the image element will also be found in one of the imaging study resources. However each caters to different types of displays for different types of purposes. Neither, either, or both may be provided.
    /// </summary>
    public List<Reference> ImagingStudy { get; set; }
    /// <summary>
    /// May be different from the update time of the resource itself, because that is the status of the record (potentially a secondary copy), not the actual release time of the report.
    /// </summary>
    public string Issued { get; set; }
    /// <summary>
    /// Extension container element for Issued
    /// </summary>
    public Element _Issued { get; set; }
    /// <summary>
    /// Indicates who or what participated in producing the report.
    /// </summary>
    public List<DiagnosticReportPerformer> Performer { get; set; }
    /// <summary>
    /// "application/pdf" is recommended as the most reliable and interoperable in this context.
    /// </summary>
    public List<Attachment> PresentedForm { get; set; }
    /// <summary>
    /// Observations that are part of this diagnostic report. Observations can be simple name/value pairs (e.g. "atomic" results), or they can be grouping observations that include references to other members of the group (e.g. "panels").
    /// </summary>
    public List<Reference> Result { get; set; }
    /// <summary>
    /// If the specimen is sufficiently specified with a code in the test result name, then this additional data may be redundant. If there are multiple specimens, these may be represented per observation or group.
    /// </summary>
    public List<Reference> Specimen { get; set; }
    /// <summary>
    /// This is labeled as "Is Modifier" because applications need to take appropriate action if a report is withdrawn.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// The subject of the report. Usually, but not always, this is a patient. However diagnostic services also perform analyses on specimens collected from a variety of other sources.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR3.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BasedOn != null) && (BasedOn.Count != 0))
      {
        writer.WritePropertyName("basedOn");
        writer.WriteStartArray();

        foreach (Reference valBasedOn in BasedOn)
        {
          valBasedOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Category != null)
      {
        writer.WritePropertyName("category");
        Category.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (Context != null)
      {
        writer.WritePropertyName("context");
        Context.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(EffectiveDateTime))
      {
        writer.WriteString("effectiveDateTime", (string)EffectiveDateTime!);
      }

      if (_EffectiveDateTime != null)
      {
        writer.WritePropertyName("_effectiveDateTime");
        _EffectiveDateTime.SerializeJson(writer, options);
      }

      if (EffectivePeriod != null)
      {
        writer.WritePropertyName("effectivePeriod");
        EffectivePeriod.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Issued))
      {
        writer.WriteString("issued", (string)Issued!);
      }

      if (_Issued != null)
      {
        writer.WritePropertyName("_issued");
        _Issued.SerializeJson(writer, options);
      }

      if ((Performer != null) && (Performer.Count != 0))
      {
        writer.WritePropertyName("performer");
        writer.WriteStartArray();

        foreach (DiagnosticReportPerformer valPerformer in Performer)
        {
          valPerformer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Specimen != null) && (Specimen.Count != 0))
      {
        writer.WritePropertyName("specimen");
        writer.WriteStartArray();

        foreach (Reference valSpecimen in Specimen)
        {
          valSpecimen.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Result != null) && (Result.Count != 0))
      {
        writer.WritePropertyName("result");
        writer.WriteStartArray();

        foreach (Reference valResult in Result)
        {
          valResult.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ImagingStudy != null) && (ImagingStudy.Count != 0))
      {
        writer.WritePropertyName("imagingStudy");
        writer.WriteStartArray();

        foreach (Reference valImagingStudy in ImagingStudy)
        {
          valImagingStudy.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Image != null) && (Image.Count != 0))
      {
        writer.WritePropertyName("image");
        writer.WriteStartArray();

        foreach (DiagnosticReportImage valImage in Image)
        {
          valImage.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Conclusion))
      {
        writer.WriteString("conclusion", (string)Conclusion!);
      }

      if (_Conclusion != null)
      {
        writer.WritePropertyName("_conclusion");
        _Conclusion.SerializeJson(writer, options);
      }

      if ((CodedDiagnosis != null) && (CodedDiagnosis.Count != 0))
      {
        writer.WritePropertyName("codedDiagnosis");
        writer.WriteStartArray();

        foreach (CodeableConcept valCodedDiagnosis in CodedDiagnosis)
        {
          valCodedDiagnosis.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((PresentedForm != null) && (PresentedForm.Count != 0))
      {
        writer.WritePropertyName("presentedForm");
        writer.WriteStartArray();

        foreach (Attachment valPresentedForm in PresentedForm)
        {
          valPresentedForm.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "basedOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BasedOn = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.Reference objBasedOn = new fhirCsR3.Models.Reference();
            objBasedOn.DeserializeJson(ref reader, options);
            BasedOn.Add(objBasedOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BasedOn.Count == 0)
          {
            BasedOn = null;
          }

          break;

        case "category":
          Category = new fhirCsR3.Models.CodeableConcept();
          Category.DeserializeJson(ref reader, options);
          break;

        case "code":
          Code = new fhirCsR3.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "codedDiagnosis":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          CodedDiagnosis = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.CodeableConcept objCodedDiagnosis = new fhirCsR3.Models.CodeableConcept();
            objCodedDiagnosis.DeserializeJson(ref reader, options);
            CodedDiagnosis.Add(objCodedDiagnosis);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (CodedDiagnosis.Count == 0)
          {
            CodedDiagnosis = null;
          }

          break;

        case "conclusion":
          Conclusion = reader.GetString();
          break;

        case "_conclusion":
          _Conclusion = new fhirCsR3.Models.Element();
          _Conclusion.DeserializeJson(ref reader, options);
          break;

        case "context":
          Context = new fhirCsR3.Models.Reference();
          Context.DeserializeJson(ref reader, options);
          break;

        case "effectiveDateTime":
          EffectiveDateTime = reader.GetString();
          break;

        case "_effectiveDateTime":
          _EffectiveDateTime = new fhirCsR3.Models.Element();
          _EffectiveDateTime.DeserializeJson(ref reader, options);
          break;

        case "effectivePeriod":
          EffectivePeriod = new fhirCsR3.Models.Period();
          EffectivePeriod.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.Identifier objIdentifier = new fhirCsR3.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "image":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Image = new List<DiagnosticReportImage>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.DiagnosticReportImage objImage = new fhirCsR3.Models.DiagnosticReportImage();
            objImage.DeserializeJson(ref reader, options);
            Image.Add(objImage);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Image.Count == 0)
          {
            Image = null;
          }

          break;

        case "imagingStudy":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ImagingStudy = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.Reference objImagingStudy = new fhirCsR3.Models.Reference();
            objImagingStudy.DeserializeJson(ref reader, options);
            ImagingStudy.Add(objImagingStudy);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ImagingStudy.Count == 0)
          {
            ImagingStudy = null;
          }

          break;

        case "issued":
          Issued = reader.GetString();
          break;

        case "_issued":
          _Issued = new fhirCsR3.Models.Element();
          _Issued.DeserializeJson(ref reader, options);
          break;

        case "performer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Performer = new List<DiagnosticReportPerformer>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.DiagnosticReportPerformer objPerformer = new fhirCsR3.Models.DiagnosticReportPerformer();
            objPerformer.DeserializeJson(ref reader, options);
            Performer.Add(objPerformer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Performer.Count == 0)
          {
            Performer = null;
          }

          break;

        case "presentedForm":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          PresentedForm = new List<Attachment>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.Attachment objPresentedForm = new fhirCsR3.Models.Attachment();
            objPresentedForm.DeserializeJson(ref reader, options);
            PresentedForm.Add(objPresentedForm);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (PresentedForm.Count == 0)
          {
            PresentedForm = null;
          }

          break;

        case "result":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Result = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.Reference objResult = new fhirCsR3.Models.Reference();
            objResult.DeserializeJson(ref reader, options);
            Result.Add(objResult);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Result.Count == 0)
          {
            Result = null;
          }

          break;

        case "specimen":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Specimen = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR3.Models.Reference objSpecimen = new fhirCsR3.Models.Reference();
            objSpecimen.DeserializeJson(ref reader, options);
            Specimen.Add(objSpecimen);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Specimen.Count == 0)
          {
            Specimen = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR3.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR3.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR3.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the DiagnosticReport.status field
  /// </summary>
  public static class DiagnosticReportStatusCodes {
    public const string REGISTERED = "registered";
    public const string PARTIAL = "partial";
    public const string PRELIMINARY = "preliminary";
    public const string FINAL = "final";
    public const string AMENDED = "amended";
    public const string CORRECTED = "corrected";
    public const string APPENDED = "appended";
    public const string CANCELLED = "cancelled";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string UNKNOWN = "unknown";
  }
}
