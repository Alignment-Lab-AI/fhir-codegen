// <auto-generated />
// Built from: hl7.fhir.r5.core version: 5.0.0-ballot
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// Indicates who performed the immunization event.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationPerformer>))]
  public class ImmunizationPerformer : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// When the individual practitioner who performed the action is known, it is best to send.
    /// </summary>
    public Reference Actor { get; set; }
    /// <summary>
    /// Describes the type of performance (e.g. ordering provider, administering provider, etc.).
    /// </summary>
    public CodeableConcept Function { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Function != null)
      {
        writer.WritePropertyName("function");
        Function.SerializeJson(writer, options);
      }

      if (Actor != null)
      {
        writer.WritePropertyName("actor");
        Actor.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actor":
          Actor = new fhirCsR5.Models.Reference();
          Actor.DeserializeJson(ref reader, options);
          break;

        case "function":
          Function = new fhirCsR5.Models.CodeableConcept();
          Function.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Indicates a patient's eligibility for a funding program.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationProgramEligibility>))]
  public class ImmunizationProgramEligibility : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Indicates which program the patient had their eligility evaluated for.
    /// </summary>
    public CodeableConcept Program { get; set; }
    /// <summary>
    /// Indicates the patient's eligility status for for a specific payment program.
    /// </summary>
    public CodeableConcept ProgramStatus { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Program != null)
      {
        writer.WritePropertyName("program");
        Program.SerializeJson(writer, options);
      }

      if (ProgramStatus != null)
      {
        writer.WritePropertyName("programStatus");
        ProgramStatus.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "program":
          Program = new fhirCsR5.Models.CodeableConcept();
          Program.DeserializeJson(ref reader, options);
          break;

        case "programStatus":
          ProgramStatus = new fhirCsR5.Models.CodeableConcept();
          ProgramStatus.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A reaction may be an indication of an allergy or intolerance and, if this is determined to be the case, it should be recorded as a new AllergyIntolerance resource instance as most systems will not query against past Immunization.reaction elements.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationReaction>))]
  public class ImmunizationReaction : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Date of reaction to the immunization.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// Details of the reaction.
    /// </summary>
    public CodeableReference Manifestation { get; set; }
    /// <summary>
    /// Self-reported indicator.
    /// </summary>
    public bool? Reported { get; set; }
    /// <summary>
    /// Extension container element for Reported
    /// </summary>
    public Element _Reported { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (Manifestation != null)
      {
        writer.WritePropertyName("manifestation");
        Manifestation.SerializeJson(writer, options);
      }

      if (Reported != null)
      {
        writer.WriteBoolean("reported", (bool)Reported!);
      }

      if (_Reported != null)
      {
        writer.WritePropertyName("_reported");
        _Reported.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR5.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "manifestation":
          Manifestation = new fhirCsR5.Models.CodeableReference();
          Manifestation.DeserializeJson(ref reader, options);
          break;

        case "reported":
          Reported = reader.GetBoolean();
          break;

        case "_reported":
          _Reported = new fhirCsR5.Models.Element();
          _Reported.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The protocol (set of recommendations) being followed by the provider who administered the dose.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationProtocolApplied>))]
  public class ImmunizationProtocolApplied : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Indicates the authority who published the protocol (e.g. ACIP) that is being followed.
    /// </summary>
    public Reference Authority { get; set; }
    /// <summary>
    /// The use of an integer is preferred if known. Text should only be used in cases where an integer is not available (such as when documenting a recurring booster dose).
    /// </summary>
    public string DoseNumber { get; set; }
    /// <summary>
    /// Extension container element for DoseNumber
    /// </summary>
    public Element _DoseNumber { get; set; }
    /// <summary>
    /// One possible path to achieve presumed immunity against a disease - within the context of an authority.
    /// </summary>
    public string Series { get; set; }
    /// <summary>
    /// Extension container element for Series
    /// </summary>
    public Element _Series { get; set; }
    /// <summary>
    /// The use of an integer is preferred if known.
    /// </summary>
    public string SeriesDoses { get; set; }
    /// <summary>
    /// Extension container element for SeriesDoses
    /// </summary>
    public Element _SeriesDoses { get; set; }
    /// <summary>
    /// The vaccine preventable disease the dose is being administered against.
    /// </summary>
    public List<CodeableConcept> TargetDisease { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Series))
      {
        writer.WriteString("series", (string)Series!);
      }

      if (_Series != null)
      {
        writer.WritePropertyName("_series");
        _Series.SerializeJson(writer, options);
      }

      if (Authority != null)
      {
        writer.WritePropertyName("authority");
        Authority.SerializeJson(writer, options);
      }

      if ((TargetDisease != null) && (TargetDisease.Count != 0))
      {
        writer.WritePropertyName("targetDisease");
        writer.WriteStartArray();

        foreach (CodeableConcept valTargetDisease in TargetDisease)
        {
          valTargetDisease.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(DoseNumber))
      {
        writer.WriteString("doseNumber", (string)DoseNumber!);
      }

      if (_DoseNumber != null)
      {
        writer.WritePropertyName("_doseNumber");
        _DoseNumber.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SeriesDoses))
      {
        writer.WriteString("seriesDoses", (string)SeriesDoses!);
      }

      if (_SeriesDoses != null)
      {
        writer.WritePropertyName("_seriesDoses");
        _SeriesDoses.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "authority":
          Authority = new fhirCsR5.Models.Reference();
          Authority.DeserializeJson(ref reader, options);
          break;

        case "doseNumber":
          DoseNumber = reader.GetString();
          break;

        case "_doseNumber":
          _DoseNumber = new fhirCsR5.Models.Element();
          _DoseNumber.DeserializeJson(ref reader, options);
          break;

        case "series":
          Series = reader.GetString();
          break;

        case "_series":
          _Series = new fhirCsR5.Models.Element();
          _Series.DeserializeJson(ref reader, options);
          break;

        case "seriesDoses":
          SeriesDoses = reader.GetString();
          break;

        case "_seriesDoses":
          _SeriesDoses = new fhirCsR5.Models.Element();
          _SeriesDoses.DeserializeJson(ref reader, options);
          break;

        case "targetDisease":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          TargetDisease = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objTargetDisease = new fhirCsR5.Models.CodeableConcept();
            objTargetDisease.DeserializeJson(ref reader, options);
            TargetDisease.Add(objTargetDisease);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (TargetDisease.Count == 0)
          {
            TargetDisease = null;
          }

          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<Immunization>))]
  public class Immunization : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Immunization";
    /// <summary>
    /// An indication of which product was administered to the patient. This is typically a more detailed representation of the concept conveyed by the vaccineCode data element. If a Medication resource is referenced, it may be to a stand-alone resource or a contained resource within the Immunization resource.
    /// </summary>
    public CodeableReference AdministeredProduct { get; set; }
    /// <summary>
    /// Allows tracing of an authorization for the Immunization.
    /// </summary>
    public List<Reference> BasedOn { get; set; }
    /// <summary>
    /// The quantity of vaccine product that was administered.
    /// </summary>
    public Quantity DoseQuantity { get; set; }
    /// <summary>
    /// The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// Date vaccine batch expires.
    /// </summary>
    public string ExpirationDate { get; set; }
    /// <summary>
    /// Extension container element for ExpirationDate
    /// </summary>
    public Element _ExpirationDate { get; set; }
    /// <summary>
    /// Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).
    /// </summary>
    public CodeableConcept FundingSource { get; set; }
    /// <summary>
    /// A unique identifier assigned to this immunization record.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Typically will not be populated if primarySource = True, not required even if primarySource = False.
    /// </summary>
    public CodeableReference InformationSource { get; set; }
    /// <summary>
    /// Typically, the recognition of the dose being sub-potent is retrospective, after the administration (ex. notification of a manufacturer recall after administration). However, in the case of a partial administration (the patient moves unexpectedly and only some of the dose is actually administered), subpotency may be recognized immediately, but it is still important to record the event.
    /// </summary>
    public bool? IsSubpotent { get; set; }
    /// <summary>
    /// Extension container element for IsSubpotent
    /// </summary>
    public Element _IsSubpotent { get; set; }
    /// <summary>
    /// The service delivery location where the vaccine administration occurred.
    /// </summary>
    public Reference Location { get; set; }
    /// <summary>
    /// Lot number of the  vaccine product.
    /// </summary>
    public string LotNumber { get; set; }
    /// <summary>
    /// Extension container element for LotNumber
    /// </summary>
    public Element _LotNumber { get; set; }
    /// <summary>
    /// Name of vaccine manufacturer.
    /// </summary>
    public CodeableReference Manufacturer { get; set; }
    /// <summary>
    /// Extra information about the immunization that is not conveyed by the other attributes.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// When immunizations are given a specific date and time should always be known.   When immunizations are patient reported, a specific date might not be known.  Although partial dates are allowed, an adult patient might not be able to recall the year a childhood immunization was given. An exact date is always preferable, but the use of the String data type is acceptable when an exact date is not known. A small number of vaccines (e.g. live oral typhoid vaccine) are given as a series of patient self-administered dose over a span of time. In cases like this, often, only the first dose (typically a provider supervised dose) is recorded with the occurrence indicating the date/time of the first dose.
    /// </summary>
    public string OccurrenceDateTime { get; set; }
    /// <summary>
    /// Extension container element for OccurrenceDateTime
    /// </summary>
    public Element _OccurrenceDateTime { get; set; }
    /// <summary>
    /// When immunizations are given a specific date and time should always be known.   When immunizations are patient reported, a specific date might not be known.  Although partial dates are allowed, an adult patient might not be able to recall the year a childhood immunization was given. An exact date is always preferable, but the use of the String data type is acceptable when an exact date is not known. A small number of vaccines (e.g. live oral typhoid vaccine) are given as a series of patient self-administered dose over a span of time. In cases like this, often, only the first dose (typically a provider supervised dose) is recorded with the occurrence indicating the date/time of the first dose.
    /// </summary>
    public string OccurrenceString { get; set; }
    /// <summary>
    /// Extension container element for OccurrenceString
    /// </summary>
    public Element _OccurrenceString { get; set; }
    /// <summary>
    /// The patient who either received or did not receive the immunization.
    /// </summary>
    public Reference Patient { get; set; }
    /// <summary>
    /// Indicates who performed the immunization event.
    /// </summary>
    public List<ImmunizationPerformer> Performer { get; set; }
    /// <summary>
    /// Reflects the “reliability” of the content.
    /// </summary>
    public bool? PrimarySource { get; set; }
    /// <summary>
    /// Extension container element for PrimarySource
    /// </summary>
    public Element _PrimarySource { get; set; }
    /// <summary>
    /// Indicates a patient's eligibility for a funding program.
    /// </summary>
    public List<ImmunizationProgramEligibility> ProgramEligibility { get; set; }
    /// <summary>
    /// The protocol (set of recommendations) being followed by the provider who administered the dose.
    /// </summary>
    public List<ImmunizationProtocolApplied> ProtocolApplied { get; set; }
    /// <summary>
    /// A reaction may be an indication of an allergy or intolerance and, if this is determined to be the case, it should be recorded as a new AllergyIntolerance resource instance as most systems will not query against past Immunization.reaction elements.
    /// </summary>
    public List<ImmunizationReaction> Reaction { get; set; }
    /// <summary>
    /// Describes why the immunization occurred in coded or textual form, or Indicates another resource (Condition, Observation or DiagnosticReport) whose existence justifies this immunization.
    /// </summary>
    public List<CodeableReference> Reason { get; set; }
    /// <summary>
    /// The path by which the vaccine product is taken into the body.
    /// </summary>
    public CodeableConcept Route { get; set; }
    /// <summary>
    /// Body site where vaccine was administered.
    /// </summary>
    public CodeableConcept Site { get; set; }
    /// <summary>
    /// Will generally be set to show that the immunization has been completed or not done.  This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// This is generally only used for the status of "not-done". The reason for performing the immunization event is captured in reasonCode, not here.
    /// </summary>
    public CodeableConcept StatusReason { get; set; }
    /// <summary>
    /// Reason why a dose is considered to be subpotent.
    /// </summary>
    public List<CodeableConcept> SubpotentReason { get; set; }
    /// <summary>
    /// Additional information that is relevant to the immunization (e.g. for a vaccine recipient who is pregnant, the gestational age of the fetus). The reason why a vaccine was given (e.g. occupation, underlying medical condition) should be conveyed in Immunization.reason, not as supporting information. The reason why a vaccine was not given (e.g. contraindication) should be conveyed in Immunization.statusReason, not as supporting information.
    /// </summary>
    public List<Reference> SupportingInformation { get; set; }
    /// <summary>
    /// The code for the administered vaccine may be reported at various levels of granularity from a very generic code for a general type of vaccine (e.g. the SNOMED or CVX code for the flu vaccine) to a very discrete code for a specific product including the form and packaging (e.g. an NDC code). Because vaccineCode uses the CodeableConcept data type, multiple codes at different levels of granularity may be reported for a single immunization event provided that all codes are appropriate for the same vaccine. For example, both NDC and CVX codes may be provided for a given immunization event by repeating the coding element within vaccineCode.
    /// </summary>
    public CodeableConcept VaccineCode { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BasedOn != null) && (BasedOn.Count != 0))
      {
        writer.WritePropertyName("basedOn");
        writer.WriteStartArray();

        foreach (Reference valBasedOn in BasedOn)
        {
          valBasedOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (StatusReason != null)
      {
        writer.WritePropertyName("statusReason");
        StatusReason.SerializeJson(writer, options);
      }

      if (VaccineCode != null)
      {
        writer.WritePropertyName("vaccineCode");
        VaccineCode.SerializeJson(writer, options);
      }

      if (AdministeredProduct != null)
      {
        writer.WritePropertyName("administeredProduct");
        AdministeredProduct.SerializeJson(writer, options);
      }

      if (Manufacturer != null)
      {
        writer.WritePropertyName("manufacturer");
        Manufacturer.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(LotNumber))
      {
        writer.WriteString("lotNumber", (string)LotNumber!);
      }

      if (_LotNumber != null)
      {
        writer.WritePropertyName("_lotNumber");
        _LotNumber.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExpirationDate))
      {
        writer.WriteString("expirationDate", (string)ExpirationDate!);
      }

      if (_ExpirationDate != null)
      {
        writer.WritePropertyName("_expirationDate");
        _ExpirationDate.SerializeJson(writer, options);
      }

      if (Patient != null)
      {
        writer.WritePropertyName("patient");
        Patient.SerializeJson(writer, options);
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(writer, options);
      }

      if ((SupportingInformation != null) && (SupportingInformation.Count != 0))
      {
        writer.WritePropertyName("supportingInformation");
        writer.WriteStartArray();

        foreach (Reference valSupportingInformation in SupportingInformation)
        {
          valSupportingInformation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(OccurrenceDateTime))
      {
        writer.WriteString("occurrenceDateTime", (string)OccurrenceDateTime!);
      }

      if (_OccurrenceDateTime != null)
      {
        writer.WritePropertyName("_occurrenceDateTime");
        _OccurrenceDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(OccurrenceString))
      {
        writer.WriteString("occurrenceString", (string)OccurrenceString!);
      }

      if (_OccurrenceString != null)
      {
        writer.WritePropertyName("_occurrenceString");
        _OccurrenceString.SerializeJson(writer, options);
      }

      if (PrimarySource != null)
      {
        writer.WriteBoolean("primarySource", (bool)PrimarySource!);
      }

      if (_PrimarySource != null)
      {
        writer.WritePropertyName("_primarySource");
        _PrimarySource.SerializeJson(writer, options);
      }

      if (InformationSource != null)
      {
        writer.WritePropertyName("informationSource");
        InformationSource.SerializeJson(writer, options);
      }

      if (Location != null)
      {
        writer.WritePropertyName("location");
        Location.SerializeJson(writer, options);
      }

      if (Site != null)
      {
        writer.WritePropertyName("site");
        Site.SerializeJson(writer, options);
      }

      if (Route != null)
      {
        writer.WritePropertyName("route");
        Route.SerializeJson(writer, options);
      }

      if (DoseQuantity != null)
      {
        writer.WritePropertyName("doseQuantity");
        DoseQuantity.SerializeJson(writer, options);
      }

      if ((Performer != null) && (Performer.Count != 0))
      {
        writer.WritePropertyName("performer");
        writer.WriteStartArray();

        foreach (ImmunizationPerformer valPerformer in Performer)
        {
          valPerformer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Reason != null) && (Reason.Count != 0))
      {
        writer.WritePropertyName("reason");
        writer.WriteStartArray();

        foreach (CodeableReference valReason in Reason)
        {
          valReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (IsSubpotent != null)
      {
        writer.WriteBoolean("isSubpotent", (bool)IsSubpotent!);
      }

      if (_IsSubpotent != null)
      {
        writer.WritePropertyName("_isSubpotent");
        _IsSubpotent.SerializeJson(writer, options);
      }

      if ((SubpotentReason != null) && (SubpotentReason.Count != 0))
      {
        writer.WritePropertyName("subpotentReason");
        writer.WriteStartArray();

        foreach (CodeableConcept valSubpotentReason in SubpotentReason)
        {
          valSubpotentReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ProgramEligibility != null) && (ProgramEligibility.Count != 0))
      {
        writer.WritePropertyName("programEligibility");
        writer.WriteStartArray();

        foreach (ImmunizationProgramEligibility valProgramEligibility in ProgramEligibility)
        {
          valProgramEligibility.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (FundingSource != null)
      {
        writer.WritePropertyName("fundingSource");
        FundingSource.SerializeJson(writer, options);
      }

      if ((Reaction != null) && (Reaction.Count != 0))
      {
        writer.WritePropertyName("reaction");
        writer.WriteStartArray();

        foreach (ImmunizationReaction valReaction in Reaction)
        {
          valReaction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ProtocolApplied != null) && (ProtocolApplied.Count != 0))
      {
        writer.WritePropertyName("protocolApplied");
        writer.WriteStartArray();

        foreach (ImmunizationProtocolApplied valProtocolApplied in ProtocolApplied)
        {
          valProtocolApplied.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "administeredProduct":
          AdministeredProduct = new fhirCsR5.Models.CodeableReference();
          AdministeredProduct.DeserializeJson(ref reader, options);
          break;

        case "basedOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BasedOn = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objBasedOn = new fhirCsR5.Models.Reference();
            objBasedOn.DeserializeJson(ref reader, options);
            BasedOn.Add(objBasedOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BasedOn.Count == 0)
          {
            BasedOn = null;
          }

          break;

        case "doseQuantity":
          DoseQuantity = new fhirCsR5.Models.Quantity();
          DoseQuantity.DeserializeJson(ref reader, options);
          break;

        case "encounter":
          Encounter = new fhirCsR5.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "expirationDate":
          ExpirationDate = reader.GetString();
          break;

        case "_expirationDate":
          _ExpirationDate = new fhirCsR5.Models.Element();
          _ExpirationDate.DeserializeJson(ref reader, options);
          break;

        case "fundingSource":
          FundingSource = new fhirCsR5.Models.CodeableConcept();
          FundingSource.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Identifier objIdentifier = new fhirCsR5.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "informationSource":
          InformationSource = new fhirCsR5.Models.CodeableReference();
          InformationSource.DeserializeJson(ref reader, options);
          break;

        case "isSubpotent":
          IsSubpotent = reader.GetBoolean();
          break;

        case "_isSubpotent":
          _IsSubpotent = new fhirCsR5.Models.Element();
          _IsSubpotent.DeserializeJson(ref reader, options);
          break;

        case "location":
          Location = new fhirCsR5.Models.Reference();
          Location.DeserializeJson(ref reader, options);
          break;

        case "lotNumber":
          LotNumber = reader.GetString();
          break;

        case "_lotNumber":
          _LotNumber = new fhirCsR5.Models.Element();
          _LotNumber.DeserializeJson(ref reader, options);
          break;

        case "manufacturer":
          Manufacturer = new fhirCsR5.Models.CodeableReference();
          Manufacturer.DeserializeJson(ref reader, options);
          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Annotation objNote = new fhirCsR5.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "occurrenceDateTime":
          OccurrenceDateTime = reader.GetString();
          break;

        case "_occurrenceDateTime":
          _OccurrenceDateTime = new fhirCsR5.Models.Element();
          _OccurrenceDateTime.DeserializeJson(ref reader, options);
          break;

        case "occurrenceString":
          OccurrenceString = reader.GetString();
          break;

        case "_occurrenceString":
          _OccurrenceString = new fhirCsR5.Models.Element();
          _OccurrenceString.DeserializeJson(ref reader, options);
          break;

        case "patient":
          Patient = new fhirCsR5.Models.Reference();
          Patient.DeserializeJson(ref reader, options);
          break;

        case "performer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Performer = new List<ImmunizationPerformer>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationPerformer objPerformer = new fhirCsR5.Models.ImmunizationPerformer();
            objPerformer.DeserializeJson(ref reader, options);
            Performer.Add(objPerformer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Performer.Count == 0)
          {
            Performer = null;
          }

          break;

        case "primarySource":
          PrimarySource = reader.GetBoolean();
          break;

        case "_primarySource":
          _PrimarySource = new fhirCsR5.Models.Element();
          _PrimarySource.DeserializeJson(ref reader, options);
          break;

        case "programEligibility":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ProgramEligibility = new List<ImmunizationProgramEligibility>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationProgramEligibility objProgramEligibility = new fhirCsR5.Models.ImmunizationProgramEligibility();
            objProgramEligibility.DeserializeJson(ref reader, options);
            ProgramEligibility.Add(objProgramEligibility);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ProgramEligibility.Count == 0)
          {
            ProgramEligibility = null;
          }

          break;

        case "protocolApplied":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ProtocolApplied = new List<ImmunizationProtocolApplied>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationProtocolApplied objProtocolApplied = new fhirCsR5.Models.ImmunizationProtocolApplied();
            objProtocolApplied.DeserializeJson(ref reader, options);
            ProtocolApplied.Add(objProtocolApplied);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ProtocolApplied.Count == 0)
          {
            ProtocolApplied = null;
          }

          break;

        case "reaction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reaction = new List<ImmunizationReaction>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationReaction objReaction = new fhirCsR5.Models.ImmunizationReaction();
            objReaction.DeserializeJson(ref reader, options);
            Reaction.Add(objReaction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reaction.Count == 0)
          {
            Reaction = null;
          }

          break;

        case "reason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reason = new List<CodeableReference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableReference objReason = new fhirCsR5.Models.CodeableReference();
            objReason.DeserializeJson(ref reader, options);
            Reason.Add(objReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reason.Count == 0)
          {
            Reason = null;
          }

          break;

        case "route":
          Route = new fhirCsR5.Models.CodeableConcept();
          Route.DeserializeJson(ref reader, options);
          break;

        case "site":
          Site = new fhirCsR5.Models.CodeableConcept();
          Site.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "statusReason":
          StatusReason = new fhirCsR5.Models.CodeableConcept();
          StatusReason.DeserializeJson(ref reader, options);
          break;

        case "subpotentReason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          SubpotentReason = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objSubpotentReason = new fhirCsR5.Models.CodeableConcept();
            objSubpotentReason.DeserializeJson(ref reader, options);
            SubpotentReason.Add(objSubpotentReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (SubpotentReason.Count == 0)
          {
            SubpotentReason = null;
          }

          break;

        case "supportingInformation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          SupportingInformation = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objSupportingInformation = new fhirCsR5.Models.Reference();
            objSupportingInformation.DeserializeJson(ref reader, options);
            SupportingInformation.Add(objSupportingInformation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (SupportingInformation.Count == 0)
          {
            SupportingInformation = null;
          }

          break;

        case "vaccineCode":
          VaccineCode = new fhirCsR5.Models.CodeableConcept();
          VaccineCode.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Immunization.status field
  /// </summary>
  public static class ImmunizationStatusCodes {
    public const string COMPLETED = "completed";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string NOT_DONE = "not-done";
    public static HashSet<string> Values = new HashSet<string>() {
      "completed",
      "entered-in-error",
      "not-done",
    };
  }
}
