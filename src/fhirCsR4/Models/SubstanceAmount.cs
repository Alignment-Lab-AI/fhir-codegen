// <auto-generated />
// Built from: hl7.fhir.r4.core version: 4.0.1
  // Option: "NAMESPACE" = "fhirCsR4"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR4.Serialization;

namespace fhirCsR4.Models
{
  /// <summary>
  /// Reference range of possible or expected values.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<SubstanceAmountReferenceRange>))]
  public class SubstanceAmountReferenceRange : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Upper limit possible or expected.
    /// </summary>
    public Quantity HighLimit { get; set; }
    /// <summary>
    /// Lower limit possible or expected.
    /// </summary>
    public Quantity LowLimit { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (LowLimit != null)
      {
        writer.WritePropertyName("lowLimit");
        LowLimit.SerializeJson(writer, options);
      }

      if (HighLimit != null)
      {
        writer.WritePropertyName("highLimit");
        HighLimit.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "highLimit":
          HighLimit = new fhirCsR4.Models.Quantity();
          HighLimit.DeserializeJson(ref reader, options);
          break;

        case "lowLimit":
          LowLimit = new fhirCsR4.Models.Quantity();
          LowLimit.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<SubstanceAmount>))]
  public class SubstanceAmount : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    /// </summary>
    public Quantity AmountQuantity { get; set; }
    /// <summary>
    /// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    /// </summary>
    public Range AmountRange { get; set; }
    /// <summary>
    /// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    /// </summary>
    public string AmountString { get; set; }
    /// <summary>
    /// Extension container element for AmountString
    /// </summary>
    public Element _AmountString { get; set; }
    /// <summary>
    /// A textual comment on a numeric value.
    /// </summary>
    public string AmountText { get; set; }
    /// <summary>
    /// Extension container element for AmountText
    /// </summary>
    public Element _AmountText { get; set; }
    /// <summary>
    /// Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements.
    /// </summary>
    public CodeableConcept AmountType { get; set; }
    /// <summary>
    /// Reference range of possible or expected values.
    /// </summary>
    public SubstanceAmountReferenceRange ReferenceRange { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (AmountQuantity != null)
      {
        writer.WritePropertyName("amountQuantity");
        AmountQuantity.SerializeJson(writer, options);
      }

      if (AmountRange != null)
      {
        writer.WritePropertyName("amountRange");
        AmountRange.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(AmountString))
      {
        writer.WriteString("amountString", (string)AmountString!);
      }

      if (_AmountString != null)
      {
        writer.WritePropertyName("_amountString");
        _AmountString.SerializeJson(writer, options);
      }

      if (AmountType != null)
      {
        writer.WritePropertyName("amountType");
        AmountType.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(AmountText))
      {
        writer.WriteString("amountText", (string)AmountText!);
      }

      if (_AmountText != null)
      {
        writer.WritePropertyName("_amountText");
        _AmountText.SerializeJson(writer, options);
      }

      if (ReferenceRange != null)
      {
        writer.WritePropertyName("referenceRange");
        ReferenceRange.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "amountQuantity":
          AmountQuantity = new fhirCsR4.Models.Quantity();
          AmountQuantity.DeserializeJson(ref reader, options);
          break;

        case "amountRange":
          AmountRange = new fhirCsR4.Models.Range();
          AmountRange.DeserializeJson(ref reader, options);
          break;

        case "amountString":
          AmountString = reader.GetString();
          break;

        case "_amountString":
          _AmountString = new fhirCsR4.Models.Element();
          _AmountString.DeserializeJson(ref reader, options);
          break;

        case "amountText":
          AmountText = reader.GetString();
          break;

        case "_amountText":
          _AmountText = new fhirCsR4.Models.Element();
          _AmountText.DeserializeJson(ref reader, options);
          break;

        case "amountType":
          AmountType = new fhirCsR4.Models.CodeableConcept();
          AmountType.DeserializeJson(ref reader, options);
          break;

        case "referenceRange":
          ReferenceRange = new fhirCsR4.Models.SubstanceAmountReferenceRange();
          ReferenceRange.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
}
