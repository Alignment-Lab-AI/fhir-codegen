// <auto-generated/>
// Contents of: hl7.fhir.r2.core version: 1.0.2
// Using Model Inheritance: True
// Hiding Removed Parent Fields: False
// Nesting Type Definitions: False
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Element Naming Style: PascalCase
// Enum Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitives
// Restricted to: CapabilityStatement|CodeSystem|CompartmentDefinition|ConceptMap|NamingSystem|OperationDefinition|SearchParameter|StructureDefinition|StructureMap|ValueSet|CodeSystem|SearchParameter|StructureDefinition|ElementDefinition

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Microsoft.Health.Fhir.SpecManager.fhir.r2
{
    /// <summary>
    /// There is a variety of postal address formats defined around the world. This format defines a superset that is the basis for all addresses around the world.
    /// </summary>
    public class Address : Element
    {
        /// <summary>
        /// The name of the city, town, village or other community or delivery center.
        /// </summary>
        [JsonProperty("city")]
        public string City { get; set; }
        [JsonProperty("_city")]
        public Element _City { get; set; }
        /// <summary>
        /// ISO 3166 3 letter codes can be used in place of a full country name.
        /// </summary>
        [JsonProperty("country")]
        public string Country { get; set; }
        [JsonProperty("_country")]
        public Element _Country { get; set; }
        /// <summary>
        /// District is sometimes known as county, but in some regions 'county' in used in place of city (municipality), so county name should be conveyed in city instead.
        /// </summary>
        [JsonProperty("district")]
        public string District { get; set; }
        [JsonProperty("_district")]
        public Element _District { get; set; }
        /// <summary>
        /// This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
        /// </summary>
        [JsonProperty("line")]
        public string[] Line { get; set; }
        [JsonProperty("_line")]
        public Element[] _Line { get; set; }
        /// <summary>
        /// Time period when address was/is in use.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// A postal code designating a region defined by the postal service.
        /// </summary>
        [JsonProperty("postalCode")]
        public string PostalCode { get; set; }
        [JsonProperty("_postalCode")]
        public Element _PostalCode { get; set; }
        /// <summary>
        /// Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes).
        /// </summary>
        [JsonProperty("state")]
        public string State { get; set; }
        [JsonProperty("_state")]
        public Element _State { get; set; }
        /// <summary>
        /// Can provide both a text representation and parts.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
        /// <summary>
        /// Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary or old address etc.for a current/permanent one. Applications can assume that an address is current unless it explicitly says that it is temporary or old.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
    }
    /// <summary>
    /// Code Values for the Address.type field
    /// </summary>
    public static class AddressTypeCodes
    {
        public const string POSTAL = "postal";
        public const string PHYSICAL = "physical";
        public const string BOTH = "both";
    }
    /// <summary>
    /// Code Values for the Address.use field
    /// </summary>
    public static class AddressUseCodes
    {
        public const string HOME = "home";
        public const string WORK = "work";
        public const string TEMP = "temp";
        public const string OLD = "old";
    }
    /// <summary>
    /// A  text note which also  contains information about who made the statement and when.
    /// </summary>
    public class Annotation : Element
    {
        /// <summary>
        /// The individual responsible for making the annotation.
        /// </summary>
        [JsonProperty("authorReference")]
        public Reference AuthorReference { get; set; }
        /// <summary>
        /// The individual responsible for making the annotation.
        /// </summary>
        [JsonProperty("authorString")]
        public string AuthorString { get; set; }
        [JsonProperty("_authorString")]
        public Element _AuthorString { get; set; }
        /// <summary>
        /// The text of the annotation.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
        /// <summary>
        /// Indicates when this particular annotation was made.
        /// </summary>
        [JsonProperty("time")]
        public string Time { get; set; }
        [JsonProperty("_time")]
        public Element _Time { get; set; }
    }
    /// <summary>
    /// For referring to data content defined in other formats.
    /// </summary>
    public class Attachment : Element
    {
        /// <summary>
        /// Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
        /// </summary>
        [JsonProperty("contentType")]
        public string ContentType { get; set; }
        [JsonProperty("_contentType")]
        public Element _ContentType { get; set; }
        /// <summary>
        /// The date that the attachment was first created.
        /// </summary>
        [JsonProperty("creation")]
        public string Creation { get; set; }
        [JsonProperty("_creation")]
        public Element _Creation { get; set; }
        /// <summary>
        /// The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
        /// </summary>
        [JsonProperty("data")]
        public string Data { get; set; }
        [JsonProperty("_data")]
        public Element _Data { get; set; }
        /// <summary>
        /// The calculated hash of the data using SHA-1. Represented using base64.
        /// </summary>
        [JsonProperty("hash")]
        public string Hash { get; set; }
        [JsonProperty("_hash")]
        public Element _Hash { get; set; }
        /// <summary>
        /// The human language of the content. The value can be any valid value according to BCP 47.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
        /// </summary>
        [JsonProperty("size")]
        public uint? Size { get; set; }
        /// <summary>
        /// A label or set of text to display in place of the data.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
    }
    /// <summary>
    /// Base definition for all elements that are defined inside a resource - but not those in a data type.
    /// </summary>
    public class BackboneElement : Element
    {
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("modifierExtension")]
        public Extension[] ModifierExtension { get; set; }
    }
    /// <summary>
    /// A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
    /// </summary>
    public class CodeableConcept : Element
    {
        /// <summary>
        /// Codes may be defined very casually in enumerations, or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.  Ordering of codings is undefined and SHALL NOT be used to infer meaning. Generally, at most only one of the coding values will be labelled as UserSelected = true.
        /// </summary>
        [JsonProperty("coding")]
        public Coding[] Coding { get; set; }
        /// <summary>
        /// Very often the text is the same as a displayName of one of the codings.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
    }
    /// <summary>
    /// A reference to a code defined by a terminology system.
    /// </summary>
    public class Coding : Element
    {
        /// <summary>
        /// A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// A representation of the meaning of the code in the system, following the rules of the system.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// The URI may be an OID (urn:oid:...) or a UUID (urn:uuid:...).  OIDs and UUIDs SHALL be references to the HL7 OID registry. Otherwise, the URI should come from HL7's list of FHIR defined special URIs or it should de-reference to some definition that establish the system clearly and unambiguously.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// Amongst a set of alternatives, a directly chosen code is the most appropriate starting point for new translations. There is some ambiguity about what exactly 'directly chosen' implies, and trading partner agreement may be needed to clarify the use of this element and its consequences more completely.
        /// </summary>
        [JsonProperty("userSelected")]
        public bool? UserSelected { get; set; }
        /// <summary>
        /// Where the terminology does not clearly define what string should be used to identify code system versions, the recommendation is to use the date (expressed in FHIR date format) on which that version was officially published as the version date.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
    /// </summary>
    public class ContactPoint : Element
    {
        /// <summary>
        /// Time period when the contact point was/is in use.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Note that rank does not necessarily follow the order in which the contacts are represented in the instance.
        /// </summary>
        [JsonProperty("rank")]
        public uint? Rank { get; set; }
        /// <summary>
        /// Telecommunications form for contact point - what communications system is required to make use of the contact.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary or old contact etc.for a current/permanent one. Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
        /// <summary>
        /// Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the ContactPoint.system field
    /// </summary>
    public static class ContactPointSystemCodes
    {
        public const string PHONE = "phone";
        public const string FAX = "fax";
        public const string EMAIL = "email";
        public const string PAGER = "pager";
        public const string OTHER = "other";
    }
    /// <summary>
    /// Code Values for the ContactPoint.use field
    /// </summary>
    public static class ContactPointUseCodes
    {
        public const string HOME = "home";
        public const string WORK = "work";
        public const string TEMP = "temp";
        public const string OLD = "old";
        public const string MOBILE = "mobile";
    }
    /// <summary>
    /// Base definition for all elements in a resource.
    /// </summary>
    public class Element
    {
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("extension")]
        public Extension[] Extension { get; set; }
        /// <summary>
        /// unique id for the element within a resource (for internal references).
        /// </summary>
        [JsonProperty("id")]
        public string Id { get; set; }
        [JsonProperty("_id")]
        public Element _Id { get; set; }
    }
    /// <summary>
    /// The first element in the sequence, the one that carries the slicing, is the unconstrained element, for reference purposes . This may include the unconstrained children.
    /// </summary>
    public class ElementDefinitionSlicing : Element
    {
        /// <summary>
        /// If it's really not possible to differentiate them, the design should be re-evaluated to make the content usable.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// If there is no discriminator, the content is hard to process, so this should be avoided. If the base element has a cardinality of ..1, and there is a choice of types, the discriminator most be "@type".
        /// </summary>
        [JsonProperty("discriminator")]
        public string[] Discriminator { get; set; }
        [JsonProperty("_discriminator")]
        public Element[] _Discriminator { get; set; }
        /// <summary>
        /// Order should only be required when it is a pressing concern for presentation. Profile authors should consider making the order a feature of the rules about the narrative, not the rules about the data - requiring ordered data makes the profile much less re-usable.
        /// </summary>
        [JsonProperty("ordered")]
        public bool? Ordered { get; set; }
        /// <summary>
        /// Allowing additional elements makes for a much for flexible template - it's open for use in wider contexts, but also means that the content of the resource is not closed, and applications have to decide how to handle content not described by the profile.
        /// </summary>
        [JsonProperty("rules")]
        public string Rules { get; set; }
        [JsonProperty("_rules")]
        public Element _Rules { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.slicing.rules field
    /// </summary>
    public static class ElementDefinitionSlicingRulesCodes
    {
        public const string CLOSED = "closed";
        public const string OPEN = "open";
        public const string OPENATEND = "openAtEnd";
    }
    /// <summary>
    /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. So they are deformalised into this location for tooling convenience, and to ensure that the base information is available without dependencies.
    /// </summary>
    public class ElementDefinitionBase : Element
    {
        /// <summary>
        /// This is provided to code generation, since the wire representation in JSON differs depending on whether the base element has max > 1. Also, some forms of code generation may differ.
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// This is provided for consistency with max, and may affect code generation of mandatory elements of the base resource are generated differently (some reference implementations have done this).
        /// </summary>
        [JsonProperty("min")]
        public int Min { get; set; }
        /// <summary>
        /// The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [[[StructureDefinition]]] without a StructureDefinition.base.
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }
        [JsonProperty("_path")]
        public Element _Path { get; set; }
    }
    /// <summary>
    /// The Type of the element can be left blank, in which case the type is inherited from the resource. The type can only be listed in this field if it is an allowed option in the base resource.
    /// </summary>
    public class ElementDefinitionType : Element
    {
        /// <summary>
        /// If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
        /// </summary>
        [JsonProperty("aggregation")]
        public string[] Aggregation { get; set; }
        [JsonProperty("_aggregation")]
        public Element[] _Aggregation { get; set; }
        /// <summary>
        /// If the element is a reference to another resource, this element contains "Reference", and the profile element refers to the profile of the allowed target of the resource, which may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient). There would be one pair of type/code for each allowed target resource type.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Identifies a profile structure or implementation Guide that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile. When more than one profile is specified, the content must conform to all of them. When an implementation guide is specified, the resource SHALL conform to at least one profile defined in the implementation guide.
        /// </summary>
        [JsonProperty("profile")]
        public string[] Profile { get; set; }
        [JsonProperty("_profile")]
        public Element[] _Profile { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.type.aggregation field
    /// </summary>
    public static class ElementDefinitionTypeAggregationCodes
    {
        public const string CONTAINED = "contained";
        public const string REFERENCED = "referenced";
        public const string BUNDLED = "bundled";
    }
    /// <summary>
    /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
    /// </summary>
    public class ElementDefinitionConstraint : Element
    {
        /// <summary>
        /// Should be expressed in business terms as much as possible.
        /// </summary>
        [JsonProperty("human")]
        public string Human { get; set; }
        [JsonProperty("_human")]
        public Element _Human { get; set; }
        /// <summary>
        /// Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
        [JsonProperty("_key")]
        public Element _Key { get; set; }
        /// <summary>
        /// To be used if the reason for the constraint may not be intuitive to all implementers.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// This allows constraints to be asserted as "shall" (error) and "should" (warning).
        /// </summary>
        [JsonProperty("severity")]
        public string Severity { get; set; }
        [JsonProperty("_severity")]
        public Element _Severity { get; set; }
        /// <summary>
        /// Elements SHALL use "f" as the namespace prefix for the FHIR namespace, and "x" for the xhtml namespace, and SHALL NOT use any other prefixes.
        /// </summary>
        [JsonProperty("xpath")]
        public string Xpath { get; set; }
        [JsonProperty("_xpath")]
        public Element _Xpath { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.constraint.severity field
    /// </summary>
    public static class ElementDefinitionConstraintSeverityCodes
    {
        public const string ERROR = "error";
        public const string WARNING = "warning";
    }
    /// <summary>
    /// Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    /// </summary>
    public class ElementDefinitionBinding : Element
    {
        /// <summary>
        /// Describes the intended use of this particular set of codes.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// For further discussion, see [[[Using Terminologies]]].
        /// </summary>
        [JsonProperty("strength")]
        public string Strength { get; set; }
        [JsonProperty("_strength")]
        public Element _Strength { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetUri")]
        public string ValueSetUri { get; set; }
        [JsonProperty("_valueSetUri")]
        public Element _ValueSetUri { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetReference")]
        public Reference ValueSetReference { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.binding.strength field
    /// </summary>
    public static class ElementDefinitionBindingStrengthCodes
    {
        public const string REQUIRED = "required";
        public const string EXTENSIBLE = "extensible";
        public const string PREFERRED = "preferred";
        public const string EXAMPLE = "example";
    }
    /// <summary>
    /// Mappings are not necessarily specific enough for safe translation.
    /// </summary>
    public class ElementDefinitionMapping : Element
    {
        /// <summary>
        /// An internal reference to the definition of a mapping.
        /// </summary>
        [JsonProperty("identity")]
        public string Identity { get; set; }
        [JsonProperty("_identity")]
        public Element _Identity { get; set; }
        /// <summary>
        /// If omitted, then there can be no expectation of computational interpretation of the mapping.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// For most mappings, the syntax is undefined.  Syntax will be provided for mappings to the RIM.  Multiple mappings may be possible and may include constraints on other resource elements that identify when a particular mapping applies.
        /// </summary>
        [JsonProperty("map")]
        public string Map { get; set; }
        [JsonProperty("_map")]
        public Element _Map { get; set; }
    }
    /// <summary>
    /// Captures constraints on each element within the resource, profile, or extension.
    /// </summary>
    public class ElementDefinition : Element
    {
        /// <summary>
        /// Identifies additional names by which this element might also be known.
        /// </summary>
        [JsonProperty("alias")]
        public string[] Alias { get; set; }
        [JsonProperty("_alias")]
        public Element[] _Alias { get; set; }
        /// <summary>
        /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. So they are deformalised into this location for tooling convenience, and to ensure that the base information is available without dependencies.
        /// </summary>
        [JsonProperty("base")]
        public ElementDefinitionBase Base { get; set; }
        /// <summary>
        /// Binds to a value set if this element is coded (code, Coding, CodeableConcept).
        /// </summary>
        [JsonProperty("binding")]
        public ElementDefinitionBinding Binding { get; set; }
        /// <summary>
        /// The data element definition and other constraints SHALL be a proper constraint on the meaning (as defined in the code system, including relationships) of any code listed here.  Where multiple codes exist in a terminology that could correspond to the data element, the most granular code(s) should be selected, so long as they are not more restrictive than the data element itself.
        /// </summary>
        [JsonProperty("code")]
        public Coding[] Code { get; set; }
        /// <summary>
        /// If it is possible to capture usage rules using constraints, that mechanism should be used in preference to this element.
        /// </summary>
        [JsonProperty("comments")]
        public string Comments { get; set; }
        [JsonProperty("_comments")]
        public Element _Comments { get; set; }
        /// <summary>
        /// A reference to an invariant that may make additional statements about the cardinality or value in the instance.
        /// </summary>
        [JsonProperty("condition")]
        public string[] Condition { get; set; }
        [JsonProperty("_condition")]
        public Element[] _Condition { get; set; }
        /// <summary>
        /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
        /// </summary>
        [JsonProperty("constraint")]
        public ElementDefinitionConstraint[] Constraint { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueBoolean")]
        public bool? DefaultValueBoolean { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueInteger")]
        public int? DefaultValueInteger { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDecimal")]
        public decimal? DefaultValueDecimal { get; set; }
        [JsonProperty("_defaultValueDecimal")]
        public Element _DefaultValueDecimal { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueBase64Binary")]
        public string DefaultValueBase64Binary { get; set; }
        [JsonProperty("_defaultValueBase64Binary")]
        public Element _DefaultValueBase64Binary { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueInstant")]
        public string DefaultValueInstant { get; set; }
        [JsonProperty("_defaultValueInstant")]
        public Element _DefaultValueInstant { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueString")]
        public string DefaultValueString { get; set; }
        [JsonProperty("_defaultValueString")]
        public Element _DefaultValueString { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueUri")]
        public string DefaultValueUri { get; set; }
        [JsonProperty("_defaultValueUri")]
        public Element _DefaultValueUri { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDate")]
        public string DefaultValueDate { get; set; }
        [JsonProperty("_defaultValueDate")]
        public Element _DefaultValueDate { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDateTime")]
        public string DefaultValueDateTime { get; set; }
        [JsonProperty("_defaultValueDateTime")]
        public Element _DefaultValueDateTime { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueTime")]
        public string DefaultValueTime { get; set; }
        [JsonProperty("_defaultValueTime")]
        public Element _DefaultValueTime { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCode")]
        public string DefaultValueCode { get; set; }
        [JsonProperty("_defaultValueCode")]
        public Element _DefaultValueCode { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueOid")]
        public string DefaultValueOid { get; set; }
        [JsonProperty("_defaultValueOid")]
        public Element _DefaultValueOid { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueId")]
        public string DefaultValueId { get; set; }
        [JsonProperty("_defaultValueId")]
        public Element _DefaultValueId { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueUnsignedInt")]
        public uint? DefaultValueUnsignedInt { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValuePositiveInt")]
        public uint? DefaultValuePositiveInt { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueMarkdown")]
        public string DefaultValueMarkdown { get; set; }
        [JsonProperty("_defaultValueMarkdown")]
        public Element _DefaultValueMarkdown { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAnnotation")]
        public Annotation DefaultValueAnnotation { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAttachment")]
        public Attachment DefaultValueAttachment { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueIdentifier")]
        public Identifier DefaultValueIdentifier { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCodeableConcept")]
        public CodeableConcept DefaultValueCodeableConcept { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCoding")]
        public Coding DefaultValueCoding { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueQuantity")]
        public Quantity DefaultValueQuantity { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueRange")]
        public Range DefaultValueRange { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValuePeriod")]
        public Period DefaultValuePeriod { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueRatio")]
        public Ratio DefaultValueRatio { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueSampledData")]
        public SampledData DefaultValueSampledData { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueSignature")]
        public Signature DefaultValueSignature { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueHumanName")]
        public HumanName DefaultValueHumanName { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAddress")]
        public Address DefaultValueAddress { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueContactPoint")]
        public ContactPoint DefaultValueContactPoint { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueTiming")]
        public Timing DefaultValueTiming { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueReference")]
        public Reference DefaultValueReference { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueMeta")]
        public Meta DefaultValueMeta { get; set; }
        /// <summary>
        /// It is easy for a different definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing definitions.
        /// </summary>
        [JsonProperty("definition")]
        public string Definition { get; set; }
        [JsonProperty("_definition")]
        public Element _Definition { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleBoolean")]
        public bool? ExampleBoolean { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleInteger")]
        public int? ExampleInteger { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleDecimal")]
        public decimal? ExampleDecimal { get; set; }
        [JsonProperty("_exampleDecimal")]
        public Element _ExampleDecimal { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleBase64Binary")]
        public string ExampleBase64Binary { get; set; }
        [JsonProperty("_exampleBase64Binary")]
        public Element _ExampleBase64Binary { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleInstant")]
        public string ExampleInstant { get; set; }
        [JsonProperty("_exampleInstant")]
        public Element _ExampleInstant { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleString")]
        public string ExampleString { get; set; }
        [JsonProperty("_exampleString")]
        public Element _ExampleString { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleUri")]
        public string ExampleUri { get; set; }
        [JsonProperty("_exampleUri")]
        public Element _ExampleUri { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleDate")]
        public string ExampleDate { get; set; }
        [JsonProperty("_exampleDate")]
        public Element _ExampleDate { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleDateTime")]
        public string ExampleDateTime { get; set; }
        [JsonProperty("_exampleDateTime")]
        public Element _ExampleDateTime { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleTime")]
        public string ExampleTime { get; set; }
        [JsonProperty("_exampleTime")]
        public Element _ExampleTime { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleCode")]
        public string ExampleCode { get; set; }
        [JsonProperty("_exampleCode")]
        public Element _ExampleCode { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleOid")]
        public string ExampleOid { get; set; }
        [JsonProperty("_exampleOid")]
        public Element _ExampleOid { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleId")]
        public string ExampleId { get; set; }
        [JsonProperty("_exampleId")]
        public Element _ExampleId { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleUnsignedInt")]
        public uint? ExampleUnsignedInt { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("examplePositiveInt")]
        public uint? ExamplePositiveInt { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleMarkdown")]
        public string ExampleMarkdown { get; set; }
        [JsonProperty("_exampleMarkdown")]
        public Element _ExampleMarkdown { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleAnnotation")]
        public Annotation ExampleAnnotation { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleAttachment")]
        public Attachment ExampleAttachment { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleIdentifier")]
        public Identifier ExampleIdentifier { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleCodeableConcept")]
        public CodeableConcept ExampleCodeableConcept { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleCoding")]
        public Coding ExampleCoding { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleQuantity")]
        public Quantity ExampleQuantity { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleRange")]
        public Range ExampleRange { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("examplePeriod")]
        public Period ExamplePeriod { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleRatio")]
        public Ratio ExampleRatio { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleSampledData")]
        public SampledData ExampleSampledData { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleSignature")]
        public Signature ExampleSignature { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleHumanName")]
        public HumanName ExampleHumanName { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleAddress")]
        public Address ExampleAddress { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleContactPoint")]
        public ContactPoint ExampleContactPoint { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleTiming")]
        public Timing ExampleTiming { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleReference")]
        public Reference ExampleReference { get; set; }
        /// <summary>
        /// This will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("exampleMeta")]
        public Meta ExampleMeta { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedBoolean")]
        public bool? FixedBoolean { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedInteger")]
        public int? FixedInteger { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDecimal")]
        public decimal? FixedDecimal { get; set; }
        [JsonProperty("_fixedDecimal")]
        public Element _FixedDecimal { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedBase64Binary")]
        public string FixedBase64Binary { get; set; }
        [JsonProperty("_fixedBase64Binary")]
        public Element _FixedBase64Binary { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedInstant")]
        public string FixedInstant { get; set; }
        [JsonProperty("_fixedInstant")]
        public Element _FixedInstant { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedString")]
        public string FixedString { get; set; }
        [JsonProperty("_fixedString")]
        public Element _FixedString { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedUri")]
        public string FixedUri { get; set; }
        [JsonProperty("_fixedUri")]
        public Element _FixedUri { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDate")]
        public string FixedDate { get; set; }
        [JsonProperty("_fixedDate")]
        public Element _FixedDate { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDateTime")]
        public string FixedDateTime { get; set; }
        [JsonProperty("_fixedDateTime")]
        public Element _FixedDateTime { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedTime")]
        public string FixedTime { get; set; }
        [JsonProperty("_fixedTime")]
        public Element _FixedTime { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCode")]
        public string FixedCode { get; set; }
        [JsonProperty("_fixedCode")]
        public Element _FixedCode { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedOid")]
        public string FixedOid { get; set; }
        [JsonProperty("_fixedOid")]
        public Element _FixedOid { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedId")]
        public string FixedId { get; set; }
        [JsonProperty("_fixedId")]
        public Element _FixedId { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedUnsignedInt")]
        public uint? FixedUnsignedInt { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedPositiveInt")]
        public uint? FixedPositiveInt { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedMarkdown")]
        public string FixedMarkdown { get; set; }
        [JsonProperty("_fixedMarkdown")]
        public Element _FixedMarkdown { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAnnotation")]
        public Annotation FixedAnnotation { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAttachment")]
        public Attachment FixedAttachment { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedIdentifier")]
        public Identifier FixedIdentifier { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCodeableConcept")]
        public CodeableConcept FixedCodeableConcept { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCoding")]
        public Coding FixedCoding { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedQuantity")]
        public Quantity FixedQuantity { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedRange")]
        public Range FixedRange { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedPeriod")]
        public Period FixedPeriod { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedRatio")]
        public Ratio FixedRatio { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedSampledData")]
        public SampledData FixedSampledData { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedSignature")]
        public Signature FixedSignature { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedHumanName")]
        public HumanName FixedHumanName { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAddress")]
        public Address FixedAddress { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedContactPoint")]
        public ContactPoint FixedContactPoint { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedTiming")]
        public Timing FixedTiming { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedReference")]
        public Reference FixedReference { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedMeta")]
        public Meta FixedMeta { get; set; }
        /// <summary>
        /// Only the definition of an element can set IsModifier true - either the specification itself or where an extension is originally defined. Once set, it cannot be changed in derived profiles. An element/extension that has isModifier=true SHOULD also have a minimum cardinality of 1, so that there is no lack of clarity about what to do if it is missing. If it can be missing, the definition SHALL make the meaning of a missing element clear.
        /// </summary>
        [JsonProperty("isModifier")]
        public bool? IsModifier { get; set; }
        /// <summary>
        /// Some resources include a set of simple metadata, and some very large data. This element is used to reduce the quantity of data returned in searches. Note that servers may pre-cache summarized resources for optimal performance, so servers may not support per-profile use of the isSummary flag.
        /// </summary>
        [JsonProperty("isSummary")]
        public bool? IsSummary { get; set; }
        /// <summary>
        /// Question and label serve similar purposes in they both can be used to prompt for capturing a data element.  Whether the question form or label form should be used will depend on the type of instrument being used to capture the information.
        /// </summary>
        [JsonProperty("label")]
        public string Label { get; set; }
        [JsonProperty("_label")]
        public Element _Label { get; set; }
        /// <summary>
        /// Mappings are not necessarily specific enough for safe translation.
        /// </summary>
        [JsonProperty("mapping")]
        public ElementDefinitionMapping[] Mapping { get; set; }
        /// <summary>
        /// The maximum number of times this element is permitted to appear in the instance.
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// Receivers are not required to reject instances that exceed the maximum length.  The full length could be stored.  In some cases, data might be truncated, though truncation should be undertaken with care and an understanding of the consequences of doing so. If not specified, there is no conformance expectation for length support.
        /// </summary>
        [JsonProperty("maxLength")]
        public int? MaxLength { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueBoolean")]
        public bool? MaxValueBoolean { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueInteger")]
        public int? MaxValueInteger { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueDecimal")]
        public decimal? MaxValueDecimal { get; set; }
        [JsonProperty("_maxValueDecimal")]
        public Element _MaxValueDecimal { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueBase64Binary")]
        public string MaxValueBase64Binary { get; set; }
        [JsonProperty("_maxValueBase64Binary")]
        public Element _MaxValueBase64Binary { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueInstant")]
        public string MaxValueInstant { get; set; }
        [JsonProperty("_maxValueInstant")]
        public Element _MaxValueInstant { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueString")]
        public string MaxValueString { get; set; }
        [JsonProperty("_maxValueString")]
        public Element _MaxValueString { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueUri")]
        public string MaxValueUri { get; set; }
        [JsonProperty("_maxValueUri")]
        public Element _MaxValueUri { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueDate")]
        public string MaxValueDate { get; set; }
        [JsonProperty("_maxValueDate")]
        public Element _MaxValueDate { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueDateTime")]
        public string MaxValueDateTime { get; set; }
        [JsonProperty("_maxValueDateTime")]
        public Element _MaxValueDateTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueTime")]
        public string MaxValueTime { get; set; }
        [JsonProperty("_maxValueTime")]
        public Element _MaxValueTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueCode")]
        public string MaxValueCode { get; set; }
        [JsonProperty("_maxValueCode")]
        public Element _MaxValueCode { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueOid")]
        public string MaxValueOid { get; set; }
        [JsonProperty("_maxValueOid")]
        public Element _MaxValueOid { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueId")]
        public string MaxValueId { get; set; }
        [JsonProperty("_maxValueId")]
        public Element _MaxValueId { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueUnsignedInt")]
        public uint? MaxValueUnsignedInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValuePositiveInt")]
        public uint? MaxValuePositiveInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueMarkdown")]
        public string MaxValueMarkdown { get; set; }
        [JsonProperty("_maxValueMarkdown")]
        public Element _MaxValueMarkdown { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueAnnotation")]
        public Annotation MaxValueAnnotation { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueAttachment")]
        public Attachment MaxValueAttachment { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueIdentifier")]
        public Identifier MaxValueIdentifier { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueCodeableConcept")]
        public CodeableConcept MaxValueCodeableConcept { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueCoding")]
        public Coding MaxValueCoding { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueQuantity")]
        public Quantity MaxValueQuantity { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueRange")]
        public Range MaxValueRange { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValuePeriod")]
        public Period MaxValuePeriod { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueRatio")]
        public Ratio MaxValueRatio { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueSampledData")]
        public SampledData MaxValueSampledData { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueSignature")]
        public Signature MaxValueSignature { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueHumanName")]
        public HumanName MaxValueHumanName { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueAddress")]
        public Address MaxValueAddress { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueContactPoint")]
        public ContactPoint MaxValueContactPoint { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueTiming")]
        public Timing MaxValueTiming { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueReference")]
        public Reference MaxValueReference { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueMeta")]
        public Meta MaxValueMeta { get; set; }
        /// <summary>
        /// Implicit meanings for missing values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. An implicit meaning for a missing value can never be changed, and specifying one has the consequence that constraining its use in profiles eliminates use cases as possibilities, not merely moving them out of scope.
        /// </summary>
        [JsonProperty("meaningWhenMissing")]
        public string MeaningWhenMissing { get; set; }
        [JsonProperty("_meaningWhenMissing")]
        public Element _MeaningWhenMissing { get; set; }
        /// <summary>
        /// The minimum number of times this element SHALL appear in the instance.
        /// </summary>
        [JsonProperty("min")]
        public int? Min { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueBoolean")]
        public bool? MinValueBoolean { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueInteger")]
        public int? MinValueInteger { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueDecimal")]
        public decimal? MinValueDecimal { get; set; }
        [JsonProperty("_minValueDecimal")]
        public Element _MinValueDecimal { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueBase64Binary")]
        public string MinValueBase64Binary { get; set; }
        [JsonProperty("_minValueBase64Binary")]
        public Element _MinValueBase64Binary { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueInstant")]
        public string MinValueInstant { get; set; }
        [JsonProperty("_minValueInstant")]
        public Element _MinValueInstant { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueString")]
        public string MinValueString { get; set; }
        [JsonProperty("_minValueString")]
        public Element _MinValueString { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueUri")]
        public string MinValueUri { get; set; }
        [JsonProperty("_minValueUri")]
        public Element _MinValueUri { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueDate")]
        public string MinValueDate { get; set; }
        [JsonProperty("_minValueDate")]
        public Element _MinValueDate { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueDateTime")]
        public string MinValueDateTime { get; set; }
        [JsonProperty("_minValueDateTime")]
        public Element _MinValueDateTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueTime")]
        public string MinValueTime { get; set; }
        [JsonProperty("_minValueTime")]
        public Element _MinValueTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueCode")]
        public string MinValueCode { get; set; }
        [JsonProperty("_minValueCode")]
        public Element _MinValueCode { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueOid")]
        public string MinValueOid { get; set; }
        [JsonProperty("_minValueOid")]
        public Element _MinValueOid { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueId")]
        public string MinValueId { get; set; }
        [JsonProperty("_minValueId")]
        public Element _MinValueId { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueUnsignedInt")]
        public uint? MinValueUnsignedInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValuePositiveInt")]
        public uint? MinValuePositiveInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueMarkdown")]
        public string MinValueMarkdown { get; set; }
        [JsonProperty("_minValueMarkdown")]
        public Element _MinValueMarkdown { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueAnnotation")]
        public Annotation MinValueAnnotation { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueAttachment")]
        public Attachment MinValueAttachment { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueIdentifier")]
        public Identifier MinValueIdentifier { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueCodeableConcept")]
        public CodeableConcept MinValueCodeableConcept { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueCoding")]
        public Coding MinValueCoding { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueQuantity")]
        public Quantity MinValueQuantity { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueRange")]
        public Range MinValueRange { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValuePeriod")]
        public Period MinValuePeriod { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueRatio")]
        public Ratio MinValueRatio { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueSampledData")]
        public SampledData MinValueSampledData { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueSignature")]
        public Signature MinValueSignature { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueHumanName")]
        public HumanName MinValueHumanName { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueAddress")]
        public Address MinValueAddress { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueContactPoint")]
        public ContactPoint MinValueContactPoint { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueTiming")]
        public Timing MinValueTiming { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueReference")]
        public Reference MinValueReference { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueMeta")]
        public Meta MinValueMeta { get; set; }
        /// <summary>
        /// "Something useful" is context dependent and impossible to describe in the base FHIR specification. For this reason, tue mustSupport flag is never set to true by the FHIR specification itself - it is only set to true in profiles.   This is done in [Resource Profiles](profiling.html#mustsupport), where the profile labels an element as mustSupport=true. When a profile does this, it SHALL also make clear exactly what kind of "support" is required, as this can mean many things.  Note that an element that has the property IsModifier is not necessarily a "key" element (e.g. one of the important elements to make use of the resource), nor is it automatically mustSupport - however both of these things are more likely to be true for IsModifier elements than for other elements.
        /// </summary>
        [JsonProperty("mustSupport")]
        public bool? MustSupport { get; set; }
        /// <summary>
        /// The name SHALL be unique within the structure within the context of the constrained resource element.  (Though to avoid confusion, uniqueness across all elements is recommended.).
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// If child components of this element are defined, they act as constraints on the referenced slice.
        /// </summary>
        [JsonProperty("nameReference")]
        public string NameReference { get; set; }
        [JsonProperty("_nameReference")]
        public Element _NameReference { get; set; }
        /// <summary>
        /// The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }
        [JsonProperty("_path")]
        public Element _Path { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternBoolean")]
        public bool? PatternBoolean { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternInteger")]
        public int? PatternInteger { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternDecimal")]
        public decimal? PatternDecimal { get; set; }
        [JsonProperty("_patternDecimal")]
        public Element _PatternDecimal { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternBase64Binary")]
        public string PatternBase64Binary { get; set; }
        [JsonProperty("_patternBase64Binary")]
        public Element _PatternBase64Binary { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternInstant")]
        public string PatternInstant { get; set; }
        [JsonProperty("_patternInstant")]
        public Element _PatternInstant { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternString")]
        public string PatternString { get; set; }
        [JsonProperty("_patternString")]
        public Element _PatternString { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternUri")]
        public string PatternUri { get; set; }
        [JsonProperty("_patternUri")]
        public Element _PatternUri { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternDate")]
        public string PatternDate { get; set; }
        [JsonProperty("_patternDate")]
        public Element _PatternDate { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternDateTime")]
        public string PatternDateTime { get; set; }
        [JsonProperty("_patternDateTime")]
        public Element _PatternDateTime { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternTime")]
        public string PatternTime { get; set; }
        [JsonProperty("_patternTime")]
        public Element _PatternTime { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternCode")]
        public string PatternCode { get; set; }
        [JsonProperty("_patternCode")]
        public Element _PatternCode { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternOid")]
        public string PatternOid { get; set; }
        [JsonProperty("_patternOid")]
        public Element _PatternOid { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternId")]
        public string PatternId { get; set; }
        [JsonProperty("_patternId")]
        public Element _PatternId { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternUnsignedInt")]
        public uint? PatternUnsignedInt { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternPositiveInt")]
        public uint? PatternPositiveInt { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternMarkdown")]
        public string PatternMarkdown { get; set; }
        [JsonProperty("_patternMarkdown")]
        public Element _PatternMarkdown { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternAnnotation")]
        public Annotation PatternAnnotation { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternAttachment")]
        public Attachment PatternAttachment { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternIdentifier")]
        public Identifier PatternIdentifier { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternCodeableConcept")]
        public CodeableConcept PatternCodeableConcept { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternCoding")]
        public Coding PatternCoding { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternQuantity")]
        public Quantity PatternQuantity { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternRange")]
        public Range PatternRange { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternPeriod")]
        public Period PatternPeriod { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternRatio")]
        public Ratio PatternRatio { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternSampledData")]
        public SampledData PatternSampledData { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternSignature")]
        public Signature PatternSignature { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternHumanName")]
        public HumanName PatternHumanName { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternAddress")]
        public Address PatternAddress { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternContactPoint")]
        public ContactPoint PatternContactPoint { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternTiming")]
        public Timing PatternTiming { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternReference")]
        public Reference PatternReference { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the DSTU period.
        /// </summary>
        [JsonProperty("patternMeta")]
        public Meta PatternMeta { get; set; }
        /// <summary>
        /// This is rarely used except for special cases where the representation deviates from the normal, which is done only very reluctantly, and can only be done in the base standard (and profiles must reproduce what the base standard does).
        /// </summary>
        [JsonProperty("representation")]
        public string[] Representation { get; set; }
        [JsonProperty("_representation")]
        public Element[] _Representation { get; set; }
        /// <summary>
        /// This element does not describe the usage of the element (that's done in comments), rather it's for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// May change the term to provide language more appropriate to the context of the profile or to reflect slicing.
        /// </summary>
        [JsonProperty("short")]
        public string Short { get; set; }
        [JsonProperty("_short")]
        public Element _Short { get; set; }
        /// <summary>
        /// The first element in the sequence, the one that carries the slicing, is the unconstrained element, for reference purposes . This may include the unconstrained children.
        /// </summary>
        [JsonProperty("slicing")]
        public ElementDefinitionSlicing Slicing { get; set; }
        /// <summary>
        /// The Type of the element can be left blank, in which case the type is inherited from the resource. The type can only be listed in this field if it is an allowed option in the base resource.
        /// </summary>
        [JsonProperty("type")]
        public ElementDefinitionType[] Type { get; set; }
    }
    /// <summary>
    /// Optional Extensions Element - found in all resources.
    /// </summary>
    public class Extension : Element
    {
        /// <summary>
        /// The definition may point directly to a computable or human-readable definition of the extensibility codes, or it may be a logical URI as declared in some other specification. The definition should be version specific.  This will ideally be the URI for the Resource Profile defining the extension, with the code for the extension after a #.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool? ValueBoolean { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueInteger")]
        public int? ValueInteger { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDecimal")]
        public decimal? ValueDecimal { get; set; }
        [JsonProperty("_valueDecimal")]
        public Element _ValueDecimal { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueBase64Binary")]
        public string ValueBase64Binary { get; set; }
        [JsonProperty("_valueBase64Binary")]
        public Element _ValueBase64Binary { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueInstant")]
        public string ValueInstant { get; set; }
        [JsonProperty("_valueInstant")]
        public Element _ValueInstant { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueUri")]
        public string ValueUri { get; set; }
        [JsonProperty("_valueUri")]
        public Element _ValueUri { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDate")]
        public string ValueDate { get; set; }
        [JsonProperty("_valueDate")]
        public Element _ValueDate { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDateTime")]
        public string ValueDateTime { get; set; }
        [JsonProperty("_valueDateTime")]
        public Element _ValueDateTime { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueTime")]
        public string ValueTime { get; set; }
        [JsonProperty("_valueTime")]
        public Element _ValueTime { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCode")]
        public string ValueCode { get; set; }
        [JsonProperty("_valueCode")]
        public Element _ValueCode { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueOid")]
        public string ValueOid { get; set; }
        [JsonProperty("_valueOid")]
        public Element _ValueOid { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueId")]
        public string ValueId { get; set; }
        [JsonProperty("_valueId")]
        public Element _ValueId { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueUnsignedInt")]
        public uint? ValueUnsignedInt { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valuePositiveInt")]
        public uint? ValuePositiveInt { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueMarkdown")]
        public string ValueMarkdown { get; set; }
        [JsonProperty("_valueMarkdown")]
        public Element _ValueMarkdown { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAnnotation")]
        public Annotation ValueAnnotation { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAttachment")]
        public Attachment ValueAttachment { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueIdentifier")]
        public Identifier ValueIdentifier { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCodeableConcept")]
        public CodeableConcept ValueCodeableConcept { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCoding")]
        public Coding ValueCoding { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueQuantity")]
        public Quantity ValueQuantity { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueRange")]
        public Range ValueRange { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valuePeriod")]
        public Period ValuePeriod { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueRatio")]
        public Ratio ValueRatio { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueSampledData")]
        public SampledData ValueSampledData { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueSignature")]
        public Signature ValueSignature { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueHumanName")]
        public HumanName ValueHumanName { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAddress")]
        public Address ValueAddress { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueContactPoint")]
        public ContactPoint ValueContactPoint { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueTiming")]
        public Timing ValueTiming { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueReference")]
        public Reference ValueReference { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueMeta")]
        public Meta ValueMeta { get; set; }
    }
    /// <summary>
    /// A human's name with the ability to identify parts and usage.
    /// </summary>
    public class HumanName : Element
    {
        /// <summary>
        /// For family name, hyphenated names such as "Smith-Jones" are a single name, but names with spaces such as "Smith Jones" are broken into multiple parts.
        /// </summary>
        [JsonProperty("family")]
        public string[] Family { get; set; }
        [JsonProperty("_family")]
        public Element[] _Family { get; set; }
        /// <summary>
        /// If only initials are recorded, they may be used in place of the full name.  Not called "first name" since given names do not always come first.
        /// </summary>
        [JsonProperty("given")]
        public string[] Given { get; set; }
        [JsonProperty("_given")]
        public Element[] _Given { get; set; }
        /// <summary>
        /// Indicates the period of time when this name was valid for the named person.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
        /// </summary>
        [JsonProperty("prefix")]
        public string[] Prefix { get; set; }
        [JsonProperty("_prefix")]
        public Element[] _Prefix { get; set; }
        /// <summary>
        /// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
        /// </summary>
        [JsonProperty("suffix")]
        public string[] Suffix { get; set; }
        [JsonProperty("_suffix")]
        public Element[] _Suffix { get; set; }
        /// <summary>
        /// Can provide both a text representation and structured parts.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary or old name etc.for a current/permanent one. Applications can assume that a name is current unless it explicitly says that it is temporary or old.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
    }
    /// <summary>
    /// Code Values for the HumanName.use field
    /// </summary>
    public static class HumanNameUseCodes
    {
        public const string USUAL = "usual";
        public const string OFFICIAL = "official";
        public const string TEMP = "temp";
        public const string NICKNAME = "nickname";
        public const string ANONYMOUS = "anonymous";
        public const string OLD = "old";
        public const string MAIDEN = "maiden";
    }
    /// <summary>
    /// A technical identifier - identifies some entity uniquely and unambiguously.
    /// </summary>
    public class Identifier : Element
    {
        /// <summary>
        /// The reference may be just a text description of the assigner.
        /// </summary>
        [JsonProperty("assigner")]
        public Reference Assigner { get; set; }
        /// <summary>
        /// Time period during which identifier is/was valid for use.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Establishes the namespace in which set of possible id values is unique.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage.   Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
        /// </summary>
        [JsonProperty("type")]
        public CodeableConcept Type { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary id for a permanent one. Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
        /// <summary>
        /// If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the Identifier.use field
    /// </summary>
    public static class IdentifierUseCodes
    {
        public const string USUAL = "usual";
        public const string OFFICIAL = "official";
        public const string TEMP = "temp";
        public const string SECONDARY = "secondary";
    }
    /// <summary>
    /// The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource.
    /// </summary>
    public class Meta : Element
    {
        /// <summary>
        /// This value is always populated except when the resource is first being created. The server / resource manager sets this value; what a client provides is irrelevant.
        /// </summary>
        [JsonProperty("lastUpdated")]
        public string LastUpdated { get; set; }
        [JsonProperty("_lastUpdated")]
        public Element _LastUpdated { get; set; }
        /// <summary>
        /// It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time.  The list of profile URLs is a set.
        /// </summary>
        [JsonProperty("profile")]
        public string[] Profile { get; set; }
        [JsonProperty("_profile")]
        public Element[] _Profile { get; set; }
        /// <summary>
        /// The security labels can be updated without changing the stated version of the resource  The list of security labels is a set. Uniqueness is based the system/code, and version and display are ignored.
        /// </summary>
        [JsonProperty("security")]
        public Coding[] Security { get; set; }
        /// <summary>
        /// The tags can be updated without changing the stated version of the resource.  The list of tags is a set. Uniqueness is based the system/code, and version and display are ignored.
        /// </summary>
        [JsonProperty("tag")]
        public Coding[] Tag { get; set; }
        /// <summary>
        /// The server assigns this value, and ignores what the client specifies, except in the case that the server is imposing version integrity on updates/deletes.
        /// </summary>
        [JsonProperty("versionId")]
        public string VersionId { get; set; }
        [JsonProperty("_versionId")]
        public Element _VersionId { get; set; }
    }
    /// <summary>
    /// A human-readable formatted text, including images.
    /// </summary>
    public class Narrative : Element
    {
        /// <summary>
        /// The contents of the html element are an XHTML fragment containing only the basic html formatting elements described in chapters 7-11 and 15 of the HTML 4.0 standard, <a> elements (either name or href), images and internally contained stylesheets. The XHTML content may not contain a head, a body, external stylesheet references, scripts, forms, base/link/xlink, frames, iframes and objects.
        /// </summary>
        [JsonProperty("div")]
        public string Div { get; set; }
        [JsonProperty("_div")]
        public Element _Div { get; set; }
        /// <summary>
        /// The status of the narrative - whether it's entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
    }
    /// <summary>
    /// Code Values for the Narrative.status field
    /// </summary>
    public static class NarrativeStatusCodes
    {
        public const string GENERATED = "generated";
        public const string EXTENSIONS = "extensions";
        public const string ADDITIONAL = "additional";
        public const string EMPTY = "empty";
    }
    /// <summary>
    /// A time period defined by a start and end date and optionally time.
    /// </summary>
    public class Period : Element
    {
        /// <summary>
        /// The high value includes any matching date/time. i.e. 2012-02-03T10:00:00 is in a period that has a end value of 2012-02-03.
        /// </summary>
        [JsonProperty("end")]
        public string End { get; set; }
        [JsonProperty("_end")]
        public Element _End { get; set; }
        /// <summary>
        /// If the low element is missing, the meaning is that the low boundary is not known.
        /// </summary>
        [JsonProperty("start")]
        public string Start { get; set; }
        [JsonProperty("_start")]
        public Element _Start { get; set; }
    }
    /// <summary>
    /// A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
    /// </summary>
    public class Quantity : Element
    {
        /// <summary>
        /// The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value.
        /// </summary>
        [JsonProperty("comparator")]
        public string Comparator { get; set; }
        [JsonProperty("_comparator")]
        public Element _Comparator { get; set; }
        /// <summary>
        /// The identification of the system that provides the coded form of the unit.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// A human-readable form of the unit.
        /// </summary>
        [JsonProperty("unit")]
        public string Unit { get; set; }
        [JsonProperty("_unit")]
        public Element _Unit { get; set; }
        /// <summary>
        /// The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
        /// </summary>
        [JsonProperty("value")]
        public decimal? Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the Quantity.comparator field
    /// </summary>
    public static class QuantityComparatorCodes
    {
        public const string LESS_THAN = "<";
        public const string LESS_THAN_OR_EQUALS = "<=";
        public const string GREATER_THAN_OR_EQUALS = ">=";
        public const string GREATER_THAN = ">";
    }
    /// <summary>
    /// A set of ordered Quantities defined by a low and high limit.
    /// </summary>
    public class Range : Element
    {
        /// <summary>
        /// If the high element is missing, the high boundary is not known.
        /// </summary>
        [JsonProperty("high")]
        public Quantity High { get; set; }
        /// <summary>
        /// If the low element is missing, the low boundary is not known.
        /// </summary>
        [JsonProperty("low")]
        public Quantity Low { get; set; }
    }
    /// <summary>
    /// A relationship of two Quantity values - expressed as a numerator and a denominator.
    /// </summary>
    public class Ratio : Element
    {
        /// <summary>
        /// The value of the denominator.
        /// </summary>
        [JsonProperty("denominator")]
        public Quantity Denominator { get; set; }
        /// <summary>
        /// The value of the numerator.
        /// </summary>
        [JsonProperty("numerator")]
        public Quantity Numerator { get; set; }
    }
    /// <summary>
    /// A reference from one resource to another.
    /// </summary>
    public class Reference : Element
    {
        /// <summary>
        /// This is generally not the same as the Resource.text of the referenced resource.  The purpose is to identify what's being referenced, not to fully describe it.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// Using absolute URLs provides a stable scalable approach suitable for a cloud/web context, while using relative/logical references provides a flexible approach suitable for use when trading across closed eco-system boundaries.   Absolute URLs do not need to point to a FHIR RESTful server, though this is the preferred approach. If the URL conforms to the structure "/[type]/[id]" then it should be assumed that the reference is to a FHIR RESTful server.
        /// </summary>
        [JsonProperty("reference")]
        public string ReferenceField { get; set; }
        [JsonProperty("_reference")]
        public Element _ReferenceField { get; set; }
    }
    /// <summary>
    /// A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
    /// </summary>
    public class SampledData : Element
    {
        /// <summary>
        /// A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
        /// </summary>
        [JsonProperty("data")]
        public string Data { get; set; }
        [JsonProperty("_data")]
        public Element _Data { get; set; }
        /// <summary>
        /// If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
        /// </summary>
        [JsonProperty("dimensions")]
        public uint Dimensions { get; set; }
        /// <summary>
        /// A correction factor that is applied to the sampled data points before they are added to the origin.
        /// </summary>
        [JsonProperty("factor")]
        public decimal? Factor { get; set; }
        [JsonProperty("_factor")]
        public Element _Factor { get; set; }
        /// <summary>
        /// The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
        /// </summary>
        [JsonProperty("lowerLimit")]
        public decimal? LowerLimit { get; set; }
        [JsonProperty("_lowerLimit")]
        public Element _LowerLimit { get; set; }
        /// <summary>
        /// The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
        /// </summary>
        [JsonProperty("origin")]
        public Quantity Origin { get; set; }
        /// <summary>
        /// This is usually a whole number.
        /// </summary>
        [JsonProperty("period")]
        public decimal Period { get; set; }
        [JsonProperty("_period")]
        public Element _Period { get; set; }
        /// <summary>
        /// The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
        /// </summary>
        [JsonProperty("upperLimit")]
        public decimal? UpperLimit { get; set; }
        [JsonProperty("_upperLimit")]
        public Element _UpperLimit { get; set; }
    }
    /// <summary>
    /// A digital signature along with supporting context. The signature may be electronic/cryptographic in nature, or a graphical image representing a hand-written signature, or a signature process. Different Signature approaches have different utilities.
    /// </summary>
    public class Signature : Element
    {
        /// <summary>
        /// Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
        /// </summary>
        [JsonProperty("blob")]
        public string Blob { get; set; }
        [JsonProperty("_blob")]
        public Element _Blob { get; set; }
        /// <summary>
        /// A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jwt for JWT, and image/* for a graphical image of a signature.
        /// </summary>
        [JsonProperty("contentType")]
        public string ContentType { get; set; }
        [JsonProperty("_contentType")]
        public Element _ContentType { get; set; }
        /// <summary>
        /// Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
        /// </summary>
        [JsonProperty("type")]
        public Coding[] Type { get; set; }
        /// <summary>
        /// This should agree with the information in the signature.
        /// </summary>
        [JsonProperty("when")]
        public string When { get; set; }
        [JsonProperty("_when")]
        public Element _When { get; set; }
        /// <summary>
        /// This should agree with the information in the signature.
        /// </summary>
        [JsonProperty("whoUri")]
        public string WhoUri { get; set; }
        [JsonProperty("_whoUri")]
        public Element _WhoUri { get; set; }
        /// <summary>
        /// This should agree with the information in the signature.
        /// </summary>
        [JsonProperty("whoReference")]
        public Reference WhoReference { get; set; }
    }
    /// <summary>
    /// A set of rules that describe when the event should occur.
    /// </summary>
    public class TimingRepeat : Element
    {
        /// <summary>
        /// Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// </summary>
        [JsonProperty("boundsQuantity")]
        public Quantity BoundsQuantity { get; set; }
        /// <summary>
        /// Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// </summary>
        [JsonProperty("boundsRange")]
        public Range BoundsRange { get; set; }
        /// <summary>
        /// Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// </summary>
        [JsonProperty("boundsPeriod")]
        public Period BoundsPeriod { get; set; }
        /// <summary>
        /// If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
        /// </summary>
        [JsonProperty("count")]
        public int? Count { get; set; }
        /// <summary>
        /// For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
        /// </summary>
        [JsonProperty("duration")]
        public decimal? Duration { get; set; }
        [JsonProperty("_duration")]
        public Element _Duration { get; set; }
        /// <summary>
        /// For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
        /// </summary>
        [JsonProperty("durationMax")]
        public decimal? DurationMax { get; set; }
        [JsonProperty("_durationMax")]
        public Element _DurationMax { get; set; }
        /// <summary>
        /// The units of time for the duration, in UCUM units.
        /// </summary>
        [JsonProperty("durationUnits")]
        public string DurationUnits { get; set; }
        [JsonProperty("_durationUnits")]
        public Element _DurationUnits { get; set; }
        /// <summary>
        /// The number of times to repeat the action within the specified period / period range (i.e. both period and periodMax provided).
        /// </summary>
        [JsonProperty("frequency")]
        public int? Frequency { get; set; }
        /// <summary>
        /// If present, indicates that the frequency is a range - so repeat between [frequency] and [frequencyMax] times within the period or period range.
        /// </summary>
        [JsonProperty("frequencyMax")]
        public int? FrequencyMax { get; set; }
        /// <summary>
        /// Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period.
        /// </summary>
        [JsonProperty("period")]
        public decimal? Period { get; set; }
        [JsonProperty("_period")]
        public Element _Period { get; set; }
        /// <summary>
        /// If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
        /// </summary>
        [JsonProperty("periodMax")]
        public decimal? PeriodMax { get; set; }
        [JsonProperty("_periodMax")]
        public Element _PeriodMax { get; set; }
        /// <summary>
        /// The units of time for the period in UCUM units.
        /// </summary>
        [JsonProperty("periodUnits")]
        public string PeriodUnits { get; set; }
        [JsonProperty("_periodUnits")]
        public Element _PeriodUnits { get; set; }
        /// <summary>
        /// A real world event that the occurrence of the event should be tied to.
        /// </summary>
        [JsonProperty("when")]
        public string When { get; set; }
        [JsonProperty("_when")]
        public Element _When { get; set; }
    }
    /// <summary>
    /// Code Values for the Timing.repeat.durationUnits field
    /// </summary>
    public static class TimingRepeatDurationUnitsCodes
    {
        public const string S = "s";
        public const string MIN = "min";
        public const string H = "h";
        public const string D = "d";
        public const string WK = "wk";
        public const string MO = "mo";
        public const string A = "a";
    }
    /// <summary>
    /// Code Values for the Timing.repeat.periodUnits field
    /// </summary>
    public static class TimingRepeatPeriodUnitsCodes
    {
        public const string S = "s";
        public const string MIN = "min";
        public const string H = "h";
        public const string D = "d";
        public const string WK = "wk";
        public const string MO = "mo";
        public const string A = "a";
    }
    /// <summary>
    /// Specifies an event that may occur multiple times. Timing schedules are used to record when things are expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds.
    /// </summary>
    public class Timing : Element
    {
        /// <summary>
        /// A repeat should always be defined except for the common codes BID, TID, QID, AM and PM, which all systems are required to understand.
        /// </summary>
        [JsonProperty("code")]
        public CodeableConcept Code { get; set; }
        /// <summary>
        /// Identifies specific times when the event occurs.
        /// </summary>
        [JsonProperty("event")]
        public string[] Event { get; set; }
        [JsonProperty("_event")]
        public Element[] _Event { get; set; }
        /// <summary>
        /// A set of rules that describe when the event should occur.
        /// </summary>
        [JsonProperty("repeat")]
        public TimingRepeat Repeat { get; set; }
    }
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public class ConceptMapContact : BackboneElement
    {
        /// <summary>
        /// If there is no named individual, the telecom is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Contact details for individual (if a name was provided) or the publisher.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    /// </summary>
    public class ConceptMapElementTargetDependsOn : BackboneElement
    {
        /// <summary>
        /// Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
        /// </summary>
        [JsonProperty("codeSystem")]
        public string CodeSystem { get; set; }
        [JsonProperty("_codeSystem")]
        public Element _CodeSystem { get; set; }
        /// <summary>
        /// A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. HL7 v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
        /// </summary>
        [JsonProperty("element")]
        public string Element { get; set; }
        [JsonProperty("_element")]
        public Element _Element { get; set; }
    }
    /// <summary>
    /// Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
    /// </summary>
    public class ConceptMapElementTarget : BackboneElement
    {
        /// <summary>
        /// Identity (code or path) or the element/item that the map refers to.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Should be a version specific reference.
        /// </summary>
        [JsonProperty("codeSystem")]
        public string CodeSystem { get; set; }
        [JsonProperty("_codeSystem")]
        public Element _CodeSystem { get; set; }
        /// <summary>
        /// A description of status/issues in mapping that conveys additional information not represented in  the structured data.
        /// </summary>
        [JsonProperty("comments")]
        public string Comments { get; set; }
        [JsonProperty("_comments")]
        public Element _Comments { get; set; }
        /// <summary>
        /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
        /// </summary>
        [JsonProperty("dependsOn")]
        public ConceptMapElementTargetDependsOn[] DependsOn { get; set; }
        /// <summary>
        /// The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from target to source (e.g. the target is 'wider' than the source).
        /// </summary>
        [JsonProperty("equivalence")]
        public string Equivalence { get; set; }
        [JsonProperty("_equivalence")]
        public Element _Equivalence { get; set; }
        /// <summary>
        /// A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
        /// </summary>
        [JsonProperty("product")]
        public ConceptMapElementTargetDependsOn[] Product { get; set; }
    }
    /// <summary>
    /// Code Values for the ConceptMap.element.target.equivalence field
    /// </summary>
    public static class ConceptMapElementTargetEquivalenceCodes
    {
        public const string EQUIVALENT = "equivalent";
        public const string EQUAL = "equal";
        public const string WIDER = "wider";
        public const string SUBSUMES = "subsumes";
        public const string NARROWER = "narrower";
        public const string SPECIALIZES = "specializes";
        public const string INEXACT = "inexact";
        public const string UNMATCHED = "unmatched";
        public const string DISJOINT = "disjoint";
    }
    /// <summary>
    /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
    /// </summary>
    public class ConceptMapElement : BackboneElement
    {
        /// <summary>
        /// Identity (code or path) or the element/item being mapped.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
        /// </summary>
        [JsonProperty("codeSystem")]
        public string CodeSystem { get; set; }
        [JsonProperty("_codeSystem")]
        public Element _CodeSystem { get; set; }
        /// <summary>
        /// Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
        /// </summary>
        [JsonProperty("target")]
        public ConceptMapElementTarget[] Target { get; set; }
    }
    /// <summary>
    /// A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
    /// </summary>
    public class ConceptMap : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "ConceptMap";
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ConceptMapContact[] Contact { get; set; }
        /// <summary>
        /// Frequently, the copyright differs between the concept map, and codes that are included. The copyright statement should clearly differentiate between these when required.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the concept map. Additional specific dates may be added as extensions.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// The description is not intended to describe the semantics of the concept map. The description should capture its intended use, which is needed for ensuring integrity for its use in models across future changes.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
        /// </summary>
        [JsonProperty("element")]
        public ConceptMapElement[] Element { get; set; }
        /// <summary>
        /// Allows filtering of ConceptMap resources that are appropriate for use.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Typically, this is used for values that can go in a v3 II data type.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier Identifier { get; set; }
        /// <summary>
        /// Not expected to be unique.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the concept map (that is done in comments), rather it's for traceability of ''why'' the element is either needed or ''why'' the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute.
        /// </summary>
        [JsonProperty("sourceUri")]
        public string SourceUri { get; set; }
        [JsonProperty("_sourceUri")]
        public Element _SourceUri { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute.
        /// </summary>
        [JsonProperty("sourceReference")]
        public Reference SourceReference { get; set; }
        /// <summary>
        /// Allows filtering of ConceptMap resources that are appropriate for use.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute.
        /// </summary>
        [JsonProperty("targetUri")]
        public string TargetUri { get; set; }
        [JsonProperty("_targetUri")]
        public Element _TargetUri { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute.
        /// </summary>
        [JsonProperty("targetReference")]
        public Reference TargetReference { get; set; }
        /// <summary>
        /// An absolute URL that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) published.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of concept map instances.
        /// </summary>
        [JsonProperty("useContext")]
        public CodeableConcept[] UseContext { get; set; }
        /// <summary>
        /// There may be multiple resource versions of the concept map that have this same identifier.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the ConceptMap.status field
    /// </summary>
    public static class ConceptMapStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
    }
    /// <summary>
    /// A resource that includes narrative, extensions, and contained resources.
    /// </summary>
    public class DomainResource : Resource
    {
        /// <summary>
        /// This should never be done when the content can be identified properly, as once identification is lost, it is extremely difficult (and context dependent) to restore it again.
        /// </summary>
        [JsonProperty("contained")]
        public Resource[] Contained { get; set; }
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("extension")]
        public Extension[] Extension { get; set; }
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("modifierExtension")]
        public Extension[] ModifierExtension { get; set; }
        /// <summary>
        /// Contained resources do not have narrative. Resources that are not contained SHOULD have a narrative.
        /// </summary>
        [JsonProperty("text")]
        public Narrative Text { get; set; }
    }
    /// <summary>
    /// May be a web site, an email address, a telephone number (tel:), etc.
    /// </summary>
    public class NamingSystemContact : BackboneElement
    {
        /// <summary>
        /// If there is no named individual, the telecom is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Contact details for individual (if a name was provided) or the publisher.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// Multiple identifiers may exist, either due to duplicate registration, regional rules, needs of different communication technologies, etc.
    /// </summary>
    public class NamingSystemUniqueId : BackboneElement
    {
        /// <summary>
        /// Within a registry, a given identifier should only be "active" for a single namespace at a time.  (Ideally, an identifier should only ever be associated with a single namespace across all time).
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Indicates whether this identifier is the "preferred" identifier of this type.
        /// </summary>
        [JsonProperty("preferred")]
        public bool? Preferred { get; set; }
        /// <summary>
        /// Different identifier types may be used in different types of communications (OIDs for v3, URIs for FHIR, etc.).  Other includes RUIDs from v3, standard v2 code name strings, etc.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// If the value is a URI intended for use as FHIR system identifier, the URI should not contain "\" or "?" or "," since this makes escaping very difficult.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the NamingSystem.uniqueId.type field
    /// </summary>
    public static class NamingSystemUniqueIdTypeCodes
    {
        public const string OID = "oid";
        public const string UUID = "uuid";
        public const string URI = "uri";
        public const string OTHER = "other";
    }
    /// <summary>
    /// A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
    /// </summary>
    public class NamingSystem : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "NamingSystem";
        /// <summary>
        /// May be a web site, an email address, a telephone number (tel:), etc.
        /// </summary>
        [JsonProperty("contact")]
        public NamingSystemContact[] Contact { get; set; }
        /// <summary>
        /// Additional specific dates may be added as extensions.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// Details about what the namespace identifies including scope, granularity, version labeling, etc.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Indicates the purpose for the naming system - what kinds of things does it make unique?
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// The"symbolic name" for an OID would be captured as an extension.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// For naming systems that are retired, indicates the naming system that should be used in their place (if any).
        /// </summary>
        [JsonProperty("replacedBy")]
        public Reference ReplacedBy { get; set; }
        /// <summary>
        /// This is the primary organization.  Responsibility for some aspects of a namespace may be delegated.
        /// </summary>
        [JsonProperty("responsible")]
        public string Responsible { get; set; }
        [JsonProperty("_responsible")]
        public Element _Responsible { get; set; }
        /// <summary>
        /// Indicates whether the naming system is "ready for use" or not.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This will most commonly be used for identifier namespaces, but categories could potentially be useful for code systems and authorities as well.
        /// </summary>
        [JsonProperty("type")]
        public CodeableConcept Type { get; set; }
        /// <summary>
        /// Multiple identifiers may exist, either due to duplicate registration, regional rules, needs of different communication technologies, etc.
        /// </summary>
        [JsonProperty("uniqueId")]
        public NamingSystemUniqueId[] UniqueId { get; set; }
        /// <summary>
        /// Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
        /// </summary>
        [JsonProperty("usage")]
        public string Usage { get; set; }
        [JsonProperty("_usage")]
        public Element _Usage { get; set; }
        /// <summary>
        /// The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of naming systems.
        /// </summary>
        [JsonProperty("useContext")]
        public CodeableConcept[] UseContext { get; set; }
    }
    /// <summary>
    /// Code Values for the NamingSystem.kind field
    /// </summary>
    public static class NamingSystemKindCodes
    {
        public const string CODESYSTEM = "codesystem";
        public const string IDENTIFIER = "identifier";
        public const string ROOT = "root";
    }
    /// <summary>
    /// Code Values for the NamingSystem.status field
    /// </summary>
    public static class NamingSystemStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
    }
    /// <summary>
    /// May be a web site, an email address, a telephone number (tel:), etc.
    /// </summary>
    public class OperationDefinitionContact : BackboneElement
    {
        /// <summary>
        /// If there is no named individual, the telecom is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Contact details for individual (if a name was provided) or the publisher.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
    /// </summary>
    public class OperationDefinitionParameterBinding : BackboneElement
    {
        /// <summary>
        /// For further discussion, see [[[Using Terminologies]]].
        /// </summary>
        [JsonProperty("strength")]
        public string Strength { get; set; }
        [JsonProperty("_strength")]
        public Element _Strength { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetUri")]
        public string ValueSetUri { get; set; }
        [JsonProperty("_valueSetUri")]
        public Element _ValueSetUri { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetReference")]
        public Reference ValueSetReference { get; set; }
    }
    /// <summary>
    /// Code Values for the OperationDefinition.parameter.binding.strength field
    /// </summary>
    public static class OperationDefinitionParameterBindingStrengthCodes
    {
        public const string REQUIRED = "required";
        public const string EXTENSIBLE = "extensible";
        public const string PREFERRED = "preferred";
        public const string EXAMPLE = "example";
    }
    /// <summary>
    /// Query Definitions only have one output parameter, named "result". This may not be described, but can be to allow a profile to be defined.
    /// </summary>
    public class OperationDefinitionParameter : BackboneElement
    {
        /// <summary>
        /// Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
        /// </summary>
        [JsonProperty("binding")]
        public OperationDefinitionParameterBinding Binding { get; set; }
        /// <summary>
        /// Describes the meaning or use of this parameter.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// The maximum number of times this element is permitted to appear in the request or response.
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// The minimum number of times this parameter SHALL appear in the request or response.
        /// </summary>
        [JsonProperty("min")]
        public int Min { get; set; }
        /// <summary>
        /// This name must be a token (start with a letter in a..z, and only contain letters, numerals, and underscore.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Query Definitions only have one output parameter, named "result". This may not be described, but can be to allow a profile to be defined.
        /// </summary>
        [JsonProperty("part")]
        public OperationDefinitionParameter[] Part { get; set; }
        /// <summary>
        /// A profile the specifies the rules that this parameter must conform to.
        /// </summary>
        [JsonProperty("profile")]
        public Reference Profile { get; set; }
        /// <summary>
        /// if there is no stated parameter, then the parameter is a "Tuple" type and must have at least one part defined.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// If a parameter name is used for both an input and an output parameter, the parameter should be defined twice.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
    }
    /// <summary>
    /// Code Values for the OperationDefinition.parameter.use field
    /// </summary>
    public static class OperationDefinitionParameterUseCodes
    {
        public const string VAL_IN = "in";
        public const string VAL_OUT = "out";
    }
    /// <summary>
    /// A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
    /// </summary>
    public class OperationDefinition : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "OperationDefinition";
        /// <summary>
        /// A constrained profile can make optional parameters required or not used and clarify documentation.
        /// </summary>
        [JsonProperty("base")]
        public Reference Base { get; set; }
        /// <summary>
        /// The name used to invoke the operation.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number (tel:), etc.
        /// </summary>
        [JsonProperty("contact")]
        public OperationDefinitionContact[] Contact { get; set; }
        /// <summary>
        /// Additional specific dates may be added as extensions.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This field can be used for things such as why the profile was written, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc.  It is *not* a rendering of the profile as conveyed in Profile.text. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// This profile was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Operations that are idempotent (see [HTTP specification definition of idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) may be invoked by performing an HTTP GET operation instead of a POST.
        /// </summary>
        [JsonProperty("idempotent")]
        public bool? Idempotent { get; set; }
        /// <summary>
        /// Indicates whether this operation can be invoked on a particular instance of one of the given types.
        /// </summary>
        [JsonProperty("instance")]
        public bool Instance { get; set; }
        /// <summary>
        /// Named queries are invoked differently, and have different capabilities.
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// Not expected to be globally unique.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Additional information about how to use this operation or named query.
        /// </summary>
        [JsonProperty("notes")]
        public string Notes { get; set; }
        [JsonProperty("_notes")]
        public Element _Notes { get; set; }
        /// <summary>
        /// Query Definitions only have one output parameter, named "result". This may not be described, but can be to allow a profile to be defined.
        /// </summary>
        [JsonProperty("parameter")]
        public OperationDefinitionParameter[] Parameter { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the operation definition (that's done in comments), rather it's for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// The status of the profile.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
        /// </summary>
        [JsonProperty("system")]
        public bool System { get; set; }
        /// <summary>
        /// Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a resource type for the context).
        /// </summary>
        [JsonProperty("type")]
        public string[] Type { get; set; }
        [JsonProperty("_type")]
        public Element[] _Type { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// The identifier that is used to identify this version of the profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the OperationDefinition.kind field
    /// </summary>
    public static class OperationDefinitionKindCodes
    {
        public const string OPERATION = "operation";
        public const string QUERY = "query";
    }
    /// <summary>
    /// Code Values for the OperationDefinition.status field
    /// </summary>
    public static class OperationDefinitionStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
    }
    /// <summary>
    /// This is the base resource type for everything.
    /// </summary>
    public class Resource
    {
        /// <summary>
        /// The only time that a resource does not have an id is when it is being submitted to the server using a create operation. Bundles always have an id, though it is usually a generated UUID.
        /// </summary>
        [JsonProperty("id")]
        public string Id { get; set; }
        [JsonProperty("_id")]
        public Element _Id { get; set; }
        /// <summary>
        /// Asserting this rule set restricts the content to be only understood by a limited set of trading partners. This inherently limits the usefulness of the data in the long term. However, the existing health eco-system is highly fractured, and not yet ready to define, collect, and exchange data in a generally computable sense. Wherever possible, implementers and/or specification writers should avoid using this element as much as possible.
        /// </summary>
        [JsonProperty("implicitRules")]
        public string ImplicitRules { get; set; }
        [JsonProperty("_implicitRules")]
        public Element _ImplicitRules { get; set; }
        /// <summary>
        /// Language is provided to support indexing and accessibility (typically, services such as text to speech use the language tag). The html language tag in the narrative applies  to the narrative. The language tag on the resource may be used to specify the language of other presentations generated from the data in the resource  Not all the content has to be in the base language. The Resource.language should not be assumed to apply to the narrative automatically. If a language is specified, it should it also be specified on the div element in the html (see rules in HTML5 for information about the relationship between xml:lang and the html lang attribute).
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource.
        /// </summary>
        [JsonProperty("meta")]
        public Meta Meta { get; set; }
    }
    /// <summary>
    /// May be a web site, an email address, a telephone number (tel:), etc.
    /// </summary>
    public class SearchParameterContact : BackboneElement
    {
        /// <summary>
        /// If there is no named individual, the telecom is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Contact details for individual (if a name was provided) or the publisher.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// A search parameter that defines a named search item that can be used to search/filter on a resource.
    /// </summary>
    public class SearchParameter : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "SearchParameter";
        /// <summary>
        /// The base resource type that this search parameter refers to.
        /// </summary>
        [JsonProperty("base")]
        public string Base { get; set; }
        [JsonProperty("_base")]
        public Element _Base { get; set; }
        /// <summary>
        /// For maximum compatibility, use only lowercase ASCII characters.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number (tel:), etc.
        /// </summary>
        [JsonProperty("contact")]
        public SearchParameterContact[] Contact { get; set; }
        /// <summary>
        /// Additional specific dates may be added as extensions.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// A description of the search parameters and how it used.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of search parameter definitions that are appropriate for use vs. not.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// This is often the same as the code for the parameter, but does not need to be.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// The Scope and Usage that this search parameter was created to meet.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// This is not intended for use with actual conformance statements, but where conformance statements are used to describe possible or desired systems.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// Types of resource (if a resource is referenced).
        /// </summary>
        [JsonProperty("target")]
        public string[] Target { get; set; }
        [JsonProperty("_target")]
        public Element[] _Target { get; set; }
        /// <summary>
        /// The type of value a search parameter refers to, and how the content is interpreted.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// An absolute URL that is used to identify this search parameter when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this search parameter is (or will be) published.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// Note that the elements returned by the XPath are sometimes complex elements where logic is required to determine quite how to handle them; e.g. CodeableConcepts may contain text and/or multiple codings, where the codings themselves contain a code and a system.
        /// </summary>
        [JsonProperty("xpath")]
        public string Xpath { get; set; }
        [JsonProperty("_xpath")]
        public Element _Xpath { get; set; }
        /// <summary>
        /// How the search parameter relates to the set of elements returned by evaluating the xpath query.
        /// </summary>
        [JsonProperty("xpathUsage")]
        public string XpathUsage { get; set; }
        [JsonProperty("_xpathUsage")]
        public Element _XpathUsage { get; set; }
    }
    /// <summary>
    /// Code Values for the SearchParameter.status field
    /// </summary>
    public static class SearchParameterStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
    }
    /// <summary>
    /// Code Values for the SearchParameter.type field
    /// </summary>
    public static class SearchParameterTypeCodes
    {
        public const string NUMBER = "number";
        public const string DATE = "date";
        public const string VAL_STRING = "string";
        public const string TOKEN = "token";
        public const string REFERENCE = "reference";
        public const string COMPOSITE = "composite";
        public const string QUANTITY = "quantity";
        public const string URI = "uri";
    }
    /// <summary>
    /// Code Values for the SearchParameter.xpathUsage field
    /// </summary>
    public static class SearchParameterXpathUsageCodes
    {
        public const string NORMAL = "normal";
        public const string PHONETIC = "phonetic";
        public const string NEARBY = "nearby";
        public const string DISTANCE = "distance";
        public const string OTHER = "other";
    }
    /// <summary>
    /// May be a web site, an email address, a telephone number (tel:), etc.
    /// </summary>
    public class StructureDefinitionContact : BackboneElement
    {
        /// <summary>
        /// If there is no named individual, the telecom is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Contact details for individual (if a name was provided) or the publisher.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// An external specification that the content is mapped to.
    /// </summary>
    public class StructureDefinitionMapping : BackboneElement
    {
        /// <summary>
        /// Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
        /// </summary>
        [JsonProperty("comments")]
        public string Comments { get; set; }
        [JsonProperty("_comments")]
        public Element _Comments { get; set; }
        /// <summary>
        /// The specification is described once, with general comments, and then specific mappings are made that reference this declaration.
        /// </summary>
        [JsonProperty("identity")]
        public string Identity { get; set; }
        [JsonProperty("_identity")]
        public Element _Identity { get; set; }
        /// <summary>
        /// A name for the specification that is being mapped to.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// A formal identity for the specification being mapped to helps with identifying maps consistently.
        /// </summary>
        [JsonProperty("uri")]
        public string Uri { get; set; }
        [JsonProperty("_uri")]
        public Element _Uri { get; set; }
    }
    /// <summary>
    /// A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
    /// </summary>
    public class StructureDefinitionSnapshot : BackboneElement
    {
        /// <summary>
        /// Captures constraints on each element within the resource.
        /// </summary>
        [JsonProperty("element")]
        public ElementDefinition[] Element { get; set; }
    }
    /// <summary>
    /// A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
    /// </summary>
    public class StructureDefinitionDifferential : BackboneElement
    {
        /// <summary>
        /// Captures constraints on each element within the resource.
        /// </summary>
        [JsonProperty("element")]
        public ElementDefinition[] Element { get; set; }
    }
    /// <summary>
    /// A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions, and constraints on resources and data types.
    /// </summary>
    public class StructureDefinition : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "StructureDefinition";
        /// <summary>
        /// Abstract Resources cannot be instantiated - a concrete sub-type must be used. Abstract datatypes and extensions cannot be used in an instance. Flagging a constraint structure as abstract conveys design intent but makes no difference to how the structure definition is handled. Note that inline declared elements that are given the type "Element" in the profile, but have children described, are anonymous concrete types that specialise Element. Abstract is not relevant for logical models.
        /// </summary>
        [JsonProperty("abstract")]
        public bool Abstract { get; set; }
        /// <summary>
        /// If differential constraints are specified in this structure, they are applied to the base in a "differential" fashion. If there is no base, then the differential constraints cannot be provided (snapshot only). Differential structures are useful for the editing perspective, and snapshot structures are suitable for operational use. The FHIR Project provides a number of tools/services to populate snapshots from differential constraints. Logical Models have a base of "Element" or another logical model.
        /// </summary>
        [JsonProperty("base")]
        public string Base { get; set; }
        [JsonProperty("_base")]
        public Element _Base { get; set; }
        /// <summary>
        /// A set of terms from external terminologies that may be used to assist with indexing and searching of templates.
        /// </summary>
        [JsonProperty("code")]
        public Coding[] Code { get; set; }
        /// <summary>
        /// if a constrained type is present, then there SHALL be a base resource as well. Note that the constrained type could be determined by chasing through the base references until the base definition is reached, or by looking at the path of the first element in the snapshot - if present - but providing the constrainedType directly makes for simpler tooling and indexing.
        /// </summary>
        [JsonProperty("constrainedType")]
        public string ConstrainedType { get; set; }
        [JsonProperty("_constrainedType")]
        public Element _ConstrainedType { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number (tel:), etc.
        /// </summary>
        [JsonProperty("contact")]
        public StructureDefinitionContact[] Contact { get; set; }
        /// <summary>
        /// If the context is an element that can have multiple types, then use (e.g.) value[x] if the extension works on all choice types, or otherwise an enumeration of explicitly named elements if not. Note that a context of "string" doesn't mean that the extension can be used with one of the string patterns such as "id" etc.
        /// </summary>
        [JsonProperty("context")]
        public string[] Context { get; set; }
        [JsonProperty("_context")]
        public Element[] _Context { get; set; }
        /// <summary>
        /// If this is an extension, Identifies the context within FHIR resources where the extension can be used.
        /// </summary>
        [JsonProperty("contextType")]
        public string ContextType { get; set; }
        [JsonProperty("_contextType")]
        public Element _ContextType { get; set; }
        /// <summary>
        /// A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Additional specific dates may be added as extensions.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This field can be used for things such as why the StructureDefinition was written, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc.  It is *not* a rendering of the StructureDefinition as conveyed in StructureDefinition.text. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
        /// </summary>
        [JsonProperty("differential")]
        public StructureDefinitionDifferential Differential { get; set; }
        /// <summary>
        /// Applications don't have to use this name, but can always fall back to it. In the absence of a value for this element, use the name.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// This StructureDefinition was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// A StructureDefinition does not need to specify the target it applies to,as StructureDefinitions will often be valid across multiple versions of FHIR. FHIR tooling can determine whether a StructureDefinition is consistent with a particular StructureDefinition if desired.
        /// </summary>
        [JsonProperty("fhirVersion")]
        public string FhirVersion { get; set; }
        [JsonProperty("_fhirVersion")]
        public Element _FhirVersion { get; set; }
        /// <summary>
        /// Formal identifier that is used to identify this StructureDefinition when it is represented in other formats, or referenced in a specification, model, design or an instance  (should be globally unique OID, UUID, or URI), (if it's not possible to use the literal URI).
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier[] Identifier { get; set; }
        /// <summary>
        /// Defines the kind of structure that this definition is describing.
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// An external specification that the content is mapped to.
        /// </summary>
        [JsonProperty("mapping")]
        public StructureDefinitionMapping[] Mapping { get; set; }
        /// <summary>
        /// Not expected to be globally unique.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the structure definition (that's done in comments), rather it's for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
        /// </summary>
        [JsonProperty("snapshot")]
        public StructureDefinitionSnapshot Snapshot { get; set; }
        /// <summary>
        /// The status of the StructureDefinition.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// An absolute URL that is used to identify this structure definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure definition is (or will be) published.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of structure definitions.
        /// </summary>
        [JsonProperty("useContext")]
        public CodeableConcept[] UseContext { get; set; }
        /// <summary>
        /// The identifier that is used to identify this version of the StructureDefinition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the StructureDefinition author manually.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureDefinition.contextType field
    /// </summary>
    public static class StructureDefinitionContextTypeCodes
    {
        public const string RESOURCE = "resource";
        public const string DATATYPE = "datatype";
        public const string MAPPING = "mapping";
        public const string EXTENSION = "extension";
    }
    /// <summary>
    /// Code Values for the StructureDefinition.kind field
    /// </summary>
    public static class StructureDefinitionKindCodes
    {
        public const string DATATYPE = "datatype";
        public const string RESOURCE = "resource";
        public const string LOGICAL = "logical";
    }
    /// <summary>
    /// Code Values for the StructureDefinition.status field
    /// </summary>
    public static class StructureDefinitionStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
    }
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public class ValueSetContact : BackboneElement
    {
        /// <summary>
        /// If there is no named individual, the telecom is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Contact details for individual (if a name was provided) or the publisher.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
    /// </summary>
    public class ValueSetCodeSystemConceptDesignation : BackboneElement
    {
        /// <summary>
        /// In the absence of a language, the resource language applies.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// If no use is provided, the designation can be assumed to be suitable for general display to a human user.
        /// </summary>
        [JsonProperty("use")]
        public Coding Use { get; set; }
        /// <summary>
        /// The text value for this designation.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meaning of the hierarchical relationships are.
    /// </summary>
    public class ValueSetCodeSystemConcept : BackboneElement
    {
        /// <summary>
        /// If this code is not for use as a real concept.
        /// </summary>
        [JsonProperty("abstract")]
        public bool? Abstract { get; set; }
        /// <summary>
        /// A code - a text symbol - that uniquely identifies the concept within the code system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) and can only be determined by examining the definitions of the concepts.
        /// </summary>
        [JsonProperty("concept")]
        public ValueSetCodeSystemConcept[] Concept { get; set; }
        /// <summary>
        /// The formal definition of the concept. The value set resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
        /// </summary>
        [JsonProperty("definition")]
        public string Definition { get; set; }
        [JsonProperty("_definition")]
        public Element _Definition { get; set; }
        /// <summary>
        /// Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
        /// </summary>
        [JsonProperty("designation")]
        public ValueSetCodeSystemConceptDesignation[] Designation { get; set; }
        /// <summary>
        /// A human readable string that is the recommended default way to present this concept to a user.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
    }
    /// <summary>
    /// All code systems defined as part of a FHIR value set have an implicit valueset that includes all of the codes in the code system - the value set in which they are defined.
    /// </summary>
    public class ValueSetCodeSystem : BackboneElement
    {
        /// <summary>
        /// If this value is missing, then it is not specified whether a code system is case sensitive or not. When the rule is not known, Postel's law should be followed: produce codes with the correct case, and accept codes in any case. This element is primarily provided to support validation software.
        /// </summary>
        [JsonProperty("caseSensitive")]
        public bool? CaseSensitive { get; set; }
        /// <summary>
        /// Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meaning of the hierarchical relationships are.
        /// </summary>
        [JsonProperty("concept")]
        public ValueSetCodeSystemConcept[] Concept { get; set; }
        /// <summary>
        /// The reference is not required to point to any specific kind of definition, but the more information that can be provided, the more useful it is for implementers. Best practice is to resolve to a computable definition of the code system (either a value set, or some other format). Terminology servers MAY validate this reference (e.g. when accepting PUT/POST), and MAY make additional rules about what kind of content it refers to.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// The list of concepts is considered ordered, though the order may not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
    /// </summary>
    public class ValueSetComposeIncludeConcept : BackboneElement
    {
        /// <summary>
        /// Expressions are allowed if defined by the underlying code system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
        /// </summary>
        [JsonProperty("designation")]
        public ValueSetCodeSystemConceptDesignation[] Designation { get; set; }
        /// <summary>
        /// The value set resource allows for an alternative display to be specified for when this concept is used in this particular value set. See notes in the value set narrative about the correct use of this element.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
    }
    /// <summary>
    /// Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
    /// </summary>
    public class ValueSetComposeIncludeFilter : BackboneElement
    {
        /// <summary>
        /// The kind of operation to perform as a part of the filter criteria.
        /// </summary>
        [JsonProperty("op")]
        public string Op { get; set; }
        [JsonProperty("_op")]
        public Element _Op { get; set; }
        /// <summary>
        /// A code that identifies a property defined in the code system.
        /// </summary>
        [JsonProperty("property")]
        public string Property { get; set; }
        [JsonProperty("_property")]
        public Element _Property { get; set; }
        /// <summary>
        /// Use regex matching with care - full regex matching on every SNOMED CT term is prohibitive, for example.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the ValueSet.compose.include.filter.op field
    /// </summary>
    public static class ValueSetComposeIncludeFilterOpCodes
    {
        public const string EQUALS = "=";
        public const string IS_A = "is-a";
        public const string IS_NOT_A = "is-not-a";
        public const string REGEX = "regex";
        public const string VAL_IN = "in";
        public const string NOT_IN = "not-in";
    }
    /// <summary>
    /// If there are no codes or filters, the entire code system is included. Note that the set of codes that are included may contain abstract codes.
    /// </summary>
    public class ValueSetComposeInclude : BackboneElement
    {
        /// <summary>
        /// The list of concepts is considered ordered, though the order may not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
        /// </summary>
        [JsonProperty("concept")]
        public ValueSetComposeIncludeConcept[] Concept { get; set; }
        /// <summary>
        /// Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
        /// </summary>
        [JsonProperty("filter")]
        public ValueSetComposeIncludeFilter[] Filter { get; set; }
        /// <summary>
        /// See ''Coding.system'' for further documentation.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// This is used when selecting the descendants of a concept - they may change between versions. If no version is specified, then the exact contents of the value set may not be known until a context of use binds it to a particular version.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// A set of criteria that provide the content logical definition of the value set by including or excluding codes from outside this value set.
    /// </summary>
    public class ValueSetCompose : BackboneElement
    {
        /// <summary>
        /// Usually this is used to selectively exclude codes that were included by subsumption in the inclusions. Any display names specified for the codes are ignored.
        /// </summary>
        [JsonProperty("exclude")]
        public ValueSetComposeInclude[] Exclude { get; set; }
        /// <summary>
        /// The value set URI is either a logical reference to a defined value set such as a [SNOMED CT reference set]{snomedct.html#implicit}, or a direct reference to a value set definition using ValueSet.url. The reference may also not reference an actual FHIR ValueSet resource; in this case, whatever is referenced is an implicit definition of a value set that needs to be clear about how versions are resolved.
        /// </summary>
        [JsonProperty("import")]
        public string[] Import { get; set; }
        [JsonProperty("_import")]
        public Element[] _Import { get; set; }
        /// <summary>
        /// If there are no codes or filters, the entire code system is included. Note that the set of codes that are included may contain abstract codes.
        /// </summary>
        [JsonProperty("include")]
        public ValueSetComposeInclude[] Include { get; set; }
    }
    /// <summary>
    /// The server decides which parameters to include here, but at a minimum, the list SHOULD include the date, filter, and profile parameters passed to the $expand operation (if any).
    /// </summary>
    public class ValueSetExpansionParameter : BackboneElement
    {
        /// <summary>
        /// The names are assigned at the discretion of the server.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool? ValueBoolean { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueInteger")]
        public int? ValueInteger { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueDecimal")]
        public decimal? ValueDecimal { get; set; }
        [JsonProperty("_valueDecimal")]
        public Element _ValueDecimal { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueUri")]
        public string ValueUri { get; set; }
        [JsonProperty("_valueUri")]
        public Element _ValueUri { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueCode")]
        public string ValueCode { get; set; }
        [JsonProperty("_valueCode")]
        public Element _ValueCode { get; set; }
    }
    /// <summary>
    /// The codes that are contained in the value set expansion.
    /// </summary>
    public class ValueSetExpansionContains : BackboneElement
    {
        /// <summary>
        /// This should not be understood to exclude its use for searching (e.g. by subsumption testing). The client should know whether it is appropriate for the user to select an abstract code or not.
        /// </summary>
        [JsonProperty("abstract")]
        public bool? Abstract { get; set; }
        /// <summary>
        /// The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// If the expansion uses this element, there is  no implication about the logical relationship between them, and the  structure cannot be used for logical inferencing. The structure  exists to provide navigational assistance for helping human users to  locate codes in the expansion.
        /// </summary>
        [JsonProperty("contains")]
        public ValueSetExpansionContains[] Contains { get; set; }
        /// <summary>
        /// The recommended display for this item in the expansion.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// An absolute URI which is the code system in which the code for this item in the expansion is defined.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// The exact value of the version string is specified by the system from which the code is derived.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Expansion is performed to produce a collection of codes that are ready to use for data entry or validation.
    /// </summary>
    public class ValueSetExpansion : BackboneElement
    {
        /// <summary>
        /// The codes that are contained in the value set expansion.
        /// </summary>
        [JsonProperty("contains")]
        public ValueSetExpansionContains[] Contains { get; set; }
        /// <summary>
        /// Typically, this uri is a UUID (e.g. urn:uuid:8230ff20-c97a-4167-a59d-dc2cb9df16dd).
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }
        [JsonProperty("_identifier")]
        public Element _Identifier { get; set; }
        /// <summary>
        /// Paging only applies to flat expansions. If a filter is applied, the count is the number of concepts that matched the filter, not the number of concepts in an unfiltered view of the expansion.
        /// </summary>
        [JsonProperty("offset")]
        public int? Offset { get; set; }
        /// <summary>
        /// The server decides which parameters to include here, but at a minimum, the list SHOULD include the date, filter, and profile parameters passed to the $expand operation (if any).
        /// </summary>
        [JsonProperty("parameter")]
        public ValueSetExpansionParameter[] Parameter { get; set; }
        /// <summary>
        /// This SHOULD be a fully populated instant, but in some circumstances, value sets are expanded by hand, and the expansion is published without that precision.
        /// </summary>
        [JsonProperty("timestamp")]
        public string Timestamp { get; set; }
        [JsonProperty("_timestamp")]
        public Element _Timestamp { get; set; }
        /// <summary>
        /// Paging only applies to flat expansions.
        /// </summary>
        [JsonProperty("total")]
        public int? Total { get; set; }
    }
    /// <summary>
    /// A value set specifies a set of codes drawn from one or more code systems.
    /// </summary>
    public class ValueSet : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "ValueSet";
        /// <summary>
        /// All code systems defined as part of a FHIR value set have an implicit valueset that includes all of the codes in the code system - the value set in which they are defined.
        /// </summary>
        [JsonProperty("codeSystem")]
        public ValueSetCodeSystem CodeSystem { get; set; }
        /// <summary>
        /// A set of criteria that provide the content logical definition of the value set by including or excluding codes from outside this value set.
        /// </summary>
        [JsonProperty("compose")]
        public ValueSetCompose Compose { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ValueSetContact[] Contact { get; set; }
        /// <summary>
        /// Frequently, the copyright differs between the value set and the codes that are included. The copyright statement should clearly differentiate between these when required.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the value set. Additional specific dates may be added as extensions.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// The description is not intended to describe the semantics of the Value Set - there are no intrinsic semantics separate from the codes contained in its expansion. The description should capture its intended use, which is needed for ensuring integrity for its use in models across future changes. A description should be provided unless the value set is a contained resource (e.g. an anonymous value set in a profile). Most registries will require a description.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Expansion is performed to produce a collection of codes that are ready to use for data entry or validation.
        /// </summary>
        [JsonProperty("expansion")]
        public ValueSetExpansion Expansion { get; set; }
        /// <summary>
        /// Allows filtering of value sets that are appropriate for use vs. not.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Whether this is intended to be used with an extensible binding or not.
        /// </summary>
        [JsonProperty("extensible")]
        public bool? Extensible { get; set; }
        /// <summary>
        /// Typically, this is used for values that can go in an HL7 v3 II data type.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier Identifier { get; set; }
        /// <summary>
        /// Normally immutability is set to 'false', which is the default assumption if it is not populated.  Note that the implication is that if this is set to 'true', there may be only one ValueSet version for this definition. Immutability tends to be set to 'true' in one of two cases: - Where the value set, by the nature of its usage, cannot change.  For example "All specializations of ACT in ActClassCode" - Where there's no safe way to express the "Purpose" such that someone else could safely make changes to the value set definition. Source workflow control must guarantee that the same URI always yields the same definition.
        /// </summary>
        [JsonProperty("immutable")]
        public bool? Immutable { get; set; }
        /// <summary>
        /// With a defined lockedDate the value set is considered "Locked". Otherwise, the value set may have different expansions as underlying code systems and/or value sets evolve.  The interpretation of lockedDate is often dependent on the context - e.g. a SNOMED CT derived value set with a lockedDate will have a different expansion in USA than in UK.  If a value set specifies a version for include and exclude statements, and also specifies a locked date, the specified versions need to be available that date, or the value set will not be usable.
        /// </summary>
        [JsonProperty("lockedDate")]
        public string LockedDate { get; set; }
        [JsonProperty("_lockedDate")]
        public Element _LockedDate { get; set; }
        /// <summary>
        /// The name is not expected to be unique. A name should be provided unless the value set is a contained resource (e.g. an anonymous value set in a profile). Most registries will require a name.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the value set (that is done in comments), rather it's for traceability of ''why'' the element is either needed or ''why'' the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// Allows filtering of value set instances that are appropriate (or not) for use.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// An absolute URL that is used to identify this value set when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this value set is (or will be) published.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of value set definitions.
        /// </summary>
        [JsonProperty("useContext")]
        public CodeableConcept[] UseContext { get; set; }
        /// <summary>
        /// There may be multiple resource versions of the value set that have the same identifier.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the ValueSet.status field
    /// </summary>
    public static class ValueSetStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
    }
    public class ResourceConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return typeof(Resource).IsAssignableFrom(objectType);
        }
        public override bool CanWrite
        {
            get { return false; }
        }
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            throw new NotImplementedException();
        }
        public override bool CanRead
        {
            get { return true; }
        }
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            JObject jObject = JObject.Load(reader);
            string resourceType = jObject["resourceType"].Value<string>();
            object target = null;
            switch (resourceType)
            {
                case "ConceptMap":
                    target = new ConceptMap();
                    break;
                case "NamingSystem":
                    target = new NamingSystem();
                    break;
                case "OperationDefinition":
                    target = new OperationDefinition();
                    break;
                case "SearchParameter":
                    target = new SearchParameter();
                    break;
                case "StructureDefinition":
                    target = new StructureDefinition();
                    break;
                case "ValueSet":
                    target = new ValueSet();
                    break;
                default:
                    target = new Resource();
                    break;
            }
            serializer.Populate(jObject.CreateReader(), target);
            return target;
        }
    }
}
/// end of file
