// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Using Model Inheritance: True
// Hiding Removed Parent Fields: False
// Nesting Type Definitions: False
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Element Naming Style: PascalCase
// Enum Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitives
// Restricted to: CapabilityStatement|CodeSystem|CompartmentDefinition|ConceptMap|NamingSystem|OperationDefinition|SearchParameter|StructureDefinition|StructureMap|ValueSet|CodeSystem|SearchParameter|StructureDefinition|ElementDefinition

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Microsoft.Health.Fhir.SpecManager.fhir.r3
{
    /// <summary>
    /// An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
    /// </summary>
    public class Address : Element
    {
        /// <summary>
        /// The name of the city, town, village or other community or delivery center.
        /// </summary>
        [JsonProperty("city")]
        public string City { get; set; }
        [JsonProperty("_city")]
        public Element _City { get; set; }
        /// <summary>
        /// ISO 3166 3 letter codes can be used in place of a full country name.
        /// </summary>
        [JsonProperty("country")]
        public string Country { get; set; }
        [JsonProperty("_country")]
        public Element _Country { get; set; }
        /// <summary>
        /// District is sometimes known as county, but in some regions 'county' is used in place of city (municipality), so county name should be conveyed in city instead.
        /// </summary>
        [JsonProperty("district")]
        public string District { get; set; }
        [JsonProperty("_district")]
        public Element _District { get; set; }
        /// <summary>
        /// This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
        /// </summary>
        [JsonProperty("line")]
        public string[] Line { get; set; }
        [JsonProperty("_line")]
        public Element[] _Line { get; set; }
        /// <summary>
        /// Time period when address was/is in use.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// A postal code designating a region defined by the postal service.
        /// </summary>
        [JsonProperty("postalCode")]
        public string PostalCode { get; set; }
        [JsonProperty("_postalCode")]
        public Element _PostalCode { get; set; }
        /// <summary>
        /// Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes).
        /// </summary>
        [JsonProperty("state")]
        public string State { get; set; }
        [JsonProperty("_state")]
        public Element _State { get; set; }
        /// <summary>
        /// Can provide both a text representation and parts.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
        /// <summary>
        /// Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary or old address etc.for a current/permanent one. Applications can assume that an address is current unless it explicitly says that it is temporary or old.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
    }
    /// <summary>
    /// Code Values for the Address.type field
    /// </summary>
    public static class AddressTypeCodes
    {
        public const string POSTAL = "postal";
        public const string PHYSICAL = "physical";
        public const string BOTH = "both";
    }
    /// <summary>
    /// Code Values for the Address.use field
    /// </summary>
    public static class AddressUseCodes
    {
        public const string HOME = "home";
        public const string WORK = "work";
        public const string TEMP = "temp";
        public const string OLD = "old";
    }
    /// <summary>
    /// A duration of time during which an organism (or a process) has existed.
    /// </summary>
    public class Age : Quantity
    {
    }
    /// <summary>
    /// A  text note which also  contains information about who made the statement and when.
    /// </summary>
    public class Annotation : Element
    {
        /// <summary>
        /// The individual responsible for making the annotation.
        /// </summary>
        [JsonProperty("authorReference")]
        public Reference AuthorReference { get; set; }
        /// <summary>
        /// The individual responsible for making the annotation.
        /// </summary>
        [JsonProperty("authorString")]
        public string AuthorString { get; set; }
        [JsonProperty("_authorString")]
        public Element _AuthorString { get; set; }
        /// <summary>
        /// The text of the annotation.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
        /// <summary>
        /// Indicates when this particular annotation was made.
        /// </summary>
        [JsonProperty("time")]
        public string Time { get; set; }
        [JsonProperty("_time")]
        public Element _Time { get; set; }
    }
    /// <summary>
    /// For referring to data content defined in other formats.
    /// </summary>
    public class Attachment : Element
    {
        /// <summary>
        /// Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
        /// </summary>
        [JsonProperty("contentType")]
        public string ContentType { get; set; }
        [JsonProperty("_contentType")]
        public Element _ContentType { get; set; }
        /// <summary>
        /// The date that the attachment was first created.
        /// </summary>
        [JsonProperty("creation")]
        public string Creation { get; set; }
        [JsonProperty("_creation")]
        public Element _Creation { get; set; }
        /// <summary>
        /// The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
        /// </summary>
        [JsonProperty("data")]
        public string Data { get; set; }
        [JsonProperty("_data")]
        public Element _Data { get; set; }
        /// <summary>
        /// The hash is calculated on the data prior to base64 encoding, if the data is based64 encoded.
        /// </summary>
        [JsonProperty("hash")]
        public string Hash { get; set; }
        [JsonProperty("_hash")]
        public Element _Hash { get; set; }
        /// <summary>
        /// The human language of the content. The value can be any valid value according to BCP 47.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
        /// </summary>
        [JsonProperty("size")]
        public uint? Size { get; set; }
        /// <summary>
        /// A label or set of text to display in place of the data.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
    }
    /// <summary>
    /// Base definition for all elements that are defined inside a resource - but not those in a data type.
    /// </summary>
    public class BackboneElement : Element
    {
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("modifierExtension")]
        public Extension[] ModifierExtension { get; set; }
    }
    /// <summary>
    /// A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
    /// </summary>
    public class CodeableConcept : Element
    {
        /// <summary>
        /// Codes may be defined very casually in enumerations, or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.  Ordering of codings is undefined and SHALL NOT be used to infer meaning. Generally, at most only one of the coding values will be labeled as UserSelected = true.
        /// </summary>
        [JsonProperty("coding")]
        public Coding[] Coding { get; set; }
        /// <summary>
        /// Very often the text is the same as a displayName of one of the codings.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
    }
    /// <summary>
    /// A reference to a code defined by a terminology system.
    /// </summary>
    public class Coding : Element
    {
        /// <summary>
        /// A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// A representation of the meaning of the code in the system, following the rules of the system.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// The URI may be an OID (urn:oid:...) or a UUID (urn:uuid:...).  OIDs and UUIDs SHALL be references to the HL7 OID registry. Otherwise, the URI should come from HL7's list of FHIR defined special URIs or it should de-reference to some definition that establish the system clearly and unambiguously.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// Amongst a set of alternatives, a directly chosen code is the most appropriate starting point for new translations. There is some ambiguity about what exactly 'directly chosen' implies, and trading partner agreement may be needed to clarify the use of this element and its consequences more completely.
        /// </summary>
        [JsonProperty("userSelected")]
        public bool? UserSelected { get; set; }
        /// <summary>
        /// Where the terminology does not clearly define what string should be used to identify code system versions, the recommendation is to use the date (expressed in FHIR date format) on which that version was officially published as the version date.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Specifies contact information for a person or organization.
    /// </summary>
    public class ContactDetail : Element
    {
        /// <summary>
        /// If there is no named individual, the telecom information is for the organization as a whole.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// The contact details for the individual (if a name was provided) or the organization.
        /// </summary>
        [JsonProperty("telecom")]
        public ContactPoint[] Telecom { get; set; }
    }
    /// <summary>
    /// Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
    /// </summary>
    public class ContactPoint : Element
    {
        /// <summary>
        /// Time period when the contact point was/is in use.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Note that rank does not necessarily follow the order in which the contacts are represented in the instance.
        /// </summary>
        [JsonProperty("rank")]
        public uint? Rank { get; set; }
        /// <summary>
        /// Telecommunications form for contact point - what communications system is required to make use of the contact.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary or old contact etc.for a current/permanent one. Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
        /// <summary>
        /// Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the ContactPoint.system field
    /// </summary>
    public static class ContactPointSystemCodes
    {
        public const string PHONE = "phone";
        public const string FAX = "fax";
        public const string EMAIL = "email";
        public const string PAGER = "pager";
        public const string URL = "url";
        public const string SMS = "sms";
        public const string OTHER = "other";
    }
    /// <summary>
    /// Code Values for the ContactPoint.use field
    /// </summary>
    public static class ContactPointUseCodes
    {
        public const string HOME = "home";
        public const string WORK = "work";
        public const string TEMP = "temp";
        public const string OLD = "old";
        public const string MOBILE = "mobile";
    }
    /// <summary>
    /// A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
    /// </summary>
    public class Count : Quantity
    {
    }
    /// <summary>
    /// A length - a value with a unit that is a physical distance.
    /// </summary>
    public class Distance : Quantity
    {
    }
    /// <summary>
    /// A length of time.
    /// </summary>
    public class Duration : Quantity
    {
    }
    /// <summary>
    /// Base definition for all elements in a resource.
    /// </summary>
    public class Element
    {
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("extension")]
        public Extension[] Extension { get; set; }
        /// <summary>
        /// unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
        /// </summary>
        [JsonProperty("id")]
        public string Id { get; set; }
        [JsonProperty("_id")]
        public Element _Id { get; set; }
    }
    /// <summary>
    /// If there is no discriminator, the content is hard to process, so this should be avoided. If the base element has a cardinality of ..1, and there is a choice of types, the discriminator must be "@type".
    /// </summary>
    public class ElementDefinitionSlicingDiscriminator : Element
    {
        /// <summary>
        /// The only FHIRPath functions that are allowed are resolve(), and extension(url).
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }
        [JsonProperty("_path")]
        public Element _Path { get; set; }
        /// <summary>
        /// How the element value is interpreted when discrimination is evaluated.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.slicing.discriminator.type field
    /// </summary>
    public static class ElementDefinitionSlicingDiscriminatorTypeCodes
    {
        public const string VALUE = "value";
        public const string EXISTS = "exists";
        public const string PATTERN = "pattern";
        public const string TYPE = "type";
        public const string PROFILE = "profile";
    }
    /// <summary>
    /// The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
    /// </summary>
    public class ElementDefinitionSlicing : Element
    {
        /// <summary>
        /// If it's really not possible to differentiate them, the design should be re-evaluated to make the content usable.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// If there is no discriminator, the content is hard to process, so this should be avoided. If the base element has a cardinality of ..1, and there is a choice of types, the discriminator must be "@type".
        /// </summary>
        [JsonProperty("discriminator")]
        public ElementDefinitionSlicingDiscriminator[] Discriminator { get; set; }
        /// <summary>
        /// Order should only be required when it is a pressing concern for presentation. Profile authors should consider making the order a feature of the rules about the narrative, not the rules about the data - requiring ordered data makes the profile much less re-usable.
        /// </summary>
        [JsonProperty("ordered")]
        public bool? Ordered { get; set; }
        /// <summary>
        /// Allowing additional elements makes for a much for flexible template - it's open for use in wider contexts, but also means that the content of the resource is not closed, and applications have to decide how to handle content not described by the profile.
        /// </summary>
        [JsonProperty("rules")]
        public string Rules { get; set; }
        [JsonProperty("_rules")]
        public Element _Rules { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.slicing.rules field
    /// </summary>
    public static class ElementDefinitionSlicingRulesCodes
    {
        public const string CLOSED = "closed";
        public const string OPEN = "open";
        public const string OPENATEND = "openAtEnd";
    }
    /// <summary>
    /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. So they are deformalised into this location for tooling convenience, and to ensure that the base information is available without dependencies.
    /// </summary>
    public class ElementDefinitionBase : Element
    {
        /// <summary>
        /// This is provided to code generation, since the serialization representation in JSON differs depending on whether the base element has max > 1. Also, some forms of code generation may differ.
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// This is provided for consistency with max, and may affect code generation of mandatory elements of the base resource are generated differently (some reference implementations have done this).
        /// </summary>
        [JsonProperty("min")]
        public uint Min { get; set; }
        /// <summary>
        /// The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](structuredefinition.html#) without a StructureDefinition.base.
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }
        [JsonProperty("_path")]
        public Element _Path { get; set; }
    }
    /// <summary>
    /// The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
    /// </summary>
    public class ElementDefinitionType : Element
    {
        /// <summary>
        /// If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
        /// </summary>
        [JsonProperty("aggregation")]
        public string[] Aggregation { get; set; }
        [JsonProperty("_aggregation")]
        public Element[] _Aggregation { get; set; }
        /// <summary>
        /// If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient). There would be one pair of type/code for each allowed target resource type.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Identifies a profile structure or implementation Guide that SHALL hold for the datatype this element refers to. Can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the resource SHALL conform to at least one profile defined in the implementation guide.
        /// </summary>
        [JsonProperty("profile")]
        public string Profile { get; set; }
        [JsonProperty("_profile")]
        public Element _Profile { get; set; }
        /// <summary>
        /// Identifies a profile structure or implementation Guide that SHALL hold for the target of the reference this element refers to. Can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the resource SHALL conform to at least one profile defined in the implementation guide.
        /// </summary>
        [JsonProperty("targetProfile")]
        public string TargetProfile { get; set; }
        [JsonProperty("_targetProfile")]
        public Element _TargetProfile { get; set; }
        /// <summary>
        /// The base specification never makes a rule as to which form is allowed, but implementation guides may do this.
        /// </summary>
        [JsonProperty("versioning")]
        public string Versioning { get; set; }
        [JsonProperty("_versioning")]
        public Element _Versioning { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.type.aggregation field
    /// </summary>
    public static class ElementDefinitionTypeAggregationCodes
    {
        public const string CONTAINED = "contained";
        public const string REFERENCED = "referenced";
        public const string BUNDLED = "bundled";
    }
    /// <summary>
    /// Code Values for the ElementDefinition.type.versioning field
    /// </summary>
    public static class ElementDefinitionTypeVersioningCodes
    {
        public const string EITHER = "either";
        public const string INDEPENDENT = "independent";
        public const string SPECIFIC = "specific";
    }
    /// <summary>
    /// Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
    /// </summary>
    public class ElementDefinitionExample : Element
    {
        /// <summary>
        /// Describes the purpose of this example amoung the set of examples.
        /// </summary>
        [JsonProperty("label")]
        public string Label { get; set; }
        [JsonProperty("_label")]
        public Element _Label { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueBase64Binary")]
        public string ValueBase64Binary { get; set; }
        [JsonProperty("_valueBase64Binary")]
        public Element _ValueBase64Binary { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool ValueBoolean { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueCode")]
        public string ValueCode { get; set; }
        [JsonProperty("_valueCode")]
        public Element _ValueCode { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueDate")]
        public string ValueDate { get; set; }
        [JsonProperty("_valueDate")]
        public Element _ValueDate { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueDateTime")]
        public string ValueDateTime { get; set; }
        [JsonProperty("_valueDateTime")]
        public Element _ValueDateTime { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueDecimal")]
        public decimal ValueDecimal { get; set; }
        [JsonProperty("_valueDecimal")]
        public Element _ValueDecimal { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueId")]
        public string ValueId { get; set; }
        [JsonProperty("_valueId")]
        public Element _ValueId { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueInstant")]
        public string ValueInstant { get; set; }
        [JsonProperty("_valueInstant")]
        public Element _ValueInstant { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueInteger")]
        public int ValueInteger { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueMarkdown")]
        public string ValueMarkdown { get; set; }
        [JsonProperty("_valueMarkdown")]
        public Element _ValueMarkdown { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueOid")]
        public string ValueOid { get; set; }
        [JsonProperty("_valueOid")]
        public Element _ValueOid { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valuePositiveInt")]
        public uint ValuePositiveInt { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueTime")]
        public string ValueTime { get; set; }
        [JsonProperty("_valueTime")]
        public Element _ValueTime { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueUnsignedInt")]
        public uint ValueUnsignedInt { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueUri")]
        public string ValueUri { get; set; }
        [JsonProperty("_valueUri")]
        public Element _ValueUri { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueAddress")]
        public Address ValueAddress { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueAge")]
        public Age ValueAge { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueAnnotation")]
        public Annotation ValueAnnotation { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueAttachment")]
        public Attachment ValueAttachment { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueCodeableConcept")]
        public CodeableConcept ValueCodeableConcept { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueCoding")]
        public Coding ValueCoding { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueContactPoint")]
        public ContactPoint ValueContactPoint { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueCount")]
        public Count ValueCount { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueDistance")]
        public Distance ValueDistance { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueDuration")]
        public Duration ValueDuration { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueHumanName")]
        public HumanName ValueHumanName { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueIdentifier")]
        public Identifier ValueIdentifier { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueMoney")]
        public Money ValueMoney { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valuePeriod")]
        public Period ValuePeriod { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueQuantity")]
        public Quantity ValueQuantity { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueRange")]
        public Range ValueRange { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueRatio")]
        public Ratio ValueRatio { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueReference")]
        public Reference ValueReference { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueSampledData")]
        public SampledData ValueSampledData { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueSignature")]
        public Signature ValueSignature { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueTiming")]
        public Timing ValueTiming { get; set; }
        /// <summary>
        /// The actual value for the element, which must be one of the types allowed for this element.
        /// </summary>
        [JsonProperty("valueMeta")]
        public Meta ValueMeta { get; set; }
    }
    /// <summary>
    /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
    /// </summary>
    public class ElementDefinitionConstraint : Element
    {
        /// <summary>
        /// A [FHIRPath](http://hl7.org/fluentpath) expression of constraint that can be executed to see if this constraint is met.
        /// </summary>
        [JsonProperty("expression")]
        public string Expression { get; set; }
        [JsonProperty("_expression")]
        public Element _Expression { get; set; }
        /// <summary>
        /// Should be expressed in business terms as much as possible.
        /// </summary>
        [JsonProperty("human")]
        public string Human { get; set; }
        [JsonProperty("_human")]
        public Element _Human { get; set; }
        /// <summary>
        /// Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
        [JsonProperty("_key")]
        public Element _Key { get; set; }
        /// <summary>
        /// To be used if the reason for the constraint may not be intuitive to all implementers.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// This allows constraints to be asserted as "shall" (error) and "should" (warning).
        /// </summary>
        [JsonProperty("severity")]
        public string Severity { get; set; }
        [JsonProperty("_severity")]
        public Element _Severity { get; set; }
        /// <summary>
        /// This is used when, e.g. rendering, where it is not useful to present inherited constraints when rendering the snapshot.
        /// </summary>
        [JsonProperty("source")]
        public string Source { get; set; }
        [JsonProperty("_source")]
        public Element _Source { get; set; }
        /// <summary>
        /// Elements SHALL use "f" as the namespace prefix for the FHIR namespace, and "x" for the xhtml namespace, and SHALL NOT use any other prefixes. 
        /// Note: we are considering deprecating the xpath element. Implementer feedback is welcome.
        /// </summary>
        [JsonProperty("xpath")]
        public string Xpath { get; set; }
        [JsonProperty("_xpath")]
        public Element _Xpath { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.constraint.severity field
    /// </summary>
    public static class ElementDefinitionConstraintSeverityCodes
    {
        public const string ERROR = "error";
        public const string WARNING = "warning";
    }
    /// <summary>
    /// For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
    /// </summary>
    public class ElementDefinitionBinding : Element
    {
        /// <summary>
        /// Describes the intended use of this particular set of codes.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// For further discussion, see [Using Terminologies](terminologies.html).
        /// </summary>
        [JsonProperty("strength")]
        public string Strength { get; set; }
        [JsonProperty("_strength")]
        public Element _Strength { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetUri")]
        public string ValueSetUri { get; set; }
        [JsonProperty("_valueSetUri")]
        public Element _ValueSetUri { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetReference")]
        public Reference ValueSetReference { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.binding.strength field
    /// </summary>
    public static class ElementDefinitionBindingStrengthCodes
    {
        public const string REQUIRED = "required";
        public const string EXTENSIBLE = "extensible";
        public const string PREFERRED = "preferred";
        public const string EXAMPLE = "example";
    }
    /// <summary>
    /// Mappings are not necessarily specific enough for safe translation.
    /// </summary>
    public class ElementDefinitionMapping : Element
    {
        /// <summary>
        /// Comments that provide information about the mapping or its use.
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// An internal reference to the definition of a mapping.
        /// </summary>
        [JsonProperty("identity")]
        public string Identity { get; set; }
        [JsonProperty("_identity")]
        public Element _Identity { get; set; }
        /// <summary>
        /// If omitted, then there can be no expectation of computational interpretation of the mapping.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// For most mappings, the syntax is undefined.  Syntax will be provided for mappings to the RIM.  Multiple mappings may be possible and may include constraints on other resource elements that identify when a particular mapping applies.
        /// </summary>
        [JsonProperty("map")]
        public string Map { get; set; }
        [JsonProperty("_map")]
        public Element _Map { get; set; }
    }
    /// <summary>
    /// Captures constraints on each element within the resource, profile, or extension.
    /// </summary>
    public class ElementDefinition : Element
    {
        /// <summary>
        /// Identifies additional names by which this element might also be known.
        /// </summary>
        [JsonProperty("alias")]
        public string[] Alias { get; set; }
        [JsonProperty("_alias")]
        public Element[] _Alias { get; set; }
        /// <summary>
        /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. So they are deformalised into this location for tooling convenience, and to ensure that the base information is available without dependencies.
        /// </summary>
        [JsonProperty("base")]
        public ElementDefinitionBase Base { get; set; }
        /// <summary>
        /// For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
        /// </summary>
        [JsonProperty("binding")]
        public ElementDefinitionBinding Binding { get; set; }
        /// <summary>
        /// The concept SHALL be properly aligned with the data element definition and other constraints, as defined in the code system, including relationships, of any code listed here.  Where multiple codes exist in a terminology that could correspond to the data element, the most granular code(s) should be selected, so long as they are not more restrictive than the data element itself. The mappings may be used to provide more or less granular or structured equivalences in the code system.
        /// </summary>
        [JsonProperty("code")]
        public Coding[] Code { get; set; }
        /// <summary>
        /// If it is possible to capture usage rules using constraints, that mechanism should be used in preference to this element.
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// A reference to an invariant that may make additional statements about the cardinality or value in the instance.
        /// </summary>
        [JsonProperty("condition")]
        public string[] Condition { get; set; }
        [JsonProperty("_condition")]
        public Element[] _Condition { get; set; }
        /// <summary>
        /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
        /// </summary>
        [JsonProperty("constraint")]
        public ElementDefinitionConstraint[] Constraint { get; set; }
        /// <summary>
        /// Identifies the identity of an element defined elsewhere in the profile whose content rules should be applied to the current element.
        /// </summary>
        [JsonProperty("contentReference")]
        public string ContentReference { get; set; }
        [JsonProperty("_contentReference")]
        public Element _ContentReference { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueBase64Binary")]
        public string DefaultValueBase64Binary { get; set; }
        [JsonProperty("_defaultValueBase64Binary")]
        public Element _DefaultValueBase64Binary { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueBoolean")]
        public bool? DefaultValueBoolean { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCode")]
        public string DefaultValueCode { get; set; }
        [JsonProperty("_defaultValueCode")]
        public Element _DefaultValueCode { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDate")]
        public string DefaultValueDate { get; set; }
        [JsonProperty("_defaultValueDate")]
        public Element _DefaultValueDate { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDateTime")]
        public string DefaultValueDateTime { get; set; }
        [JsonProperty("_defaultValueDateTime")]
        public Element _DefaultValueDateTime { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDecimal")]
        public decimal? DefaultValueDecimal { get; set; }
        [JsonProperty("_defaultValueDecimal")]
        public Element _DefaultValueDecimal { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueId")]
        public string DefaultValueId { get; set; }
        [JsonProperty("_defaultValueId")]
        public Element _DefaultValueId { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueInstant")]
        public string DefaultValueInstant { get; set; }
        [JsonProperty("_defaultValueInstant")]
        public Element _DefaultValueInstant { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueInteger")]
        public int? DefaultValueInteger { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueMarkdown")]
        public string DefaultValueMarkdown { get; set; }
        [JsonProperty("_defaultValueMarkdown")]
        public Element _DefaultValueMarkdown { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueOid")]
        public string DefaultValueOid { get; set; }
        [JsonProperty("_defaultValueOid")]
        public Element _DefaultValueOid { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValuePositiveInt")]
        public uint? DefaultValuePositiveInt { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueString")]
        public string DefaultValueString { get; set; }
        [JsonProperty("_defaultValueString")]
        public Element _DefaultValueString { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueTime")]
        public string DefaultValueTime { get; set; }
        [JsonProperty("_defaultValueTime")]
        public Element _DefaultValueTime { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueUnsignedInt")]
        public uint? DefaultValueUnsignedInt { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueUri")]
        public string DefaultValueUri { get; set; }
        [JsonProperty("_defaultValueUri")]
        public Element _DefaultValueUri { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAddress")]
        public Address DefaultValueAddress { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAge")]
        public Age DefaultValueAge { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAnnotation")]
        public Annotation DefaultValueAnnotation { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueAttachment")]
        public Attachment DefaultValueAttachment { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCodeableConcept")]
        public CodeableConcept DefaultValueCodeableConcept { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCoding")]
        public Coding DefaultValueCoding { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueContactPoint")]
        public ContactPoint DefaultValueContactPoint { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueCount")]
        public Count DefaultValueCount { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDistance")]
        public Distance DefaultValueDistance { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueDuration")]
        public Duration DefaultValueDuration { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueHumanName")]
        public HumanName DefaultValueHumanName { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueIdentifier")]
        public Identifier DefaultValueIdentifier { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueMoney")]
        public Money DefaultValueMoney { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValuePeriod")]
        public Period DefaultValuePeriod { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueQuantity")]
        public Quantity DefaultValueQuantity { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueRange")]
        public Range DefaultValueRange { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueRatio")]
        public Ratio DefaultValueRatio { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueReference")]
        public Reference DefaultValueReference { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueSampledData")]
        public SampledData DefaultValueSampledData { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueSignature")]
        public Signature DefaultValueSignature { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueTiming")]
        public Timing DefaultValueTiming { get; set; }
        /// <summary>
        /// Default values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed. For these reasons, default values are (and should be) used extremely sparingly.
        /// </summary>
        [JsonProperty("defaultValueMeta")]
        public Meta DefaultValueMeta { get; set; }
        /// <summary>
        /// It is easy for a different definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing definitions.
        /// </summary>
        [JsonProperty("definition")]
        public string Definition { get; set; }
        [JsonProperty("_definition")]
        public Element _Definition { get; set; }
        /// <summary>
        /// Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
        /// </summary>
        [JsonProperty("example")]
        public ElementDefinitionExample[] Example { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedBase64Binary")]
        public string FixedBase64Binary { get; set; }
        [JsonProperty("_fixedBase64Binary")]
        public Element _FixedBase64Binary { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedBoolean")]
        public bool? FixedBoolean { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCode")]
        public string FixedCode { get; set; }
        [JsonProperty("_fixedCode")]
        public Element _FixedCode { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDate")]
        public string FixedDate { get; set; }
        [JsonProperty("_fixedDate")]
        public Element _FixedDate { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDateTime")]
        public string FixedDateTime { get; set; }
        [JsonProperty("_fixedDateTime")]
        public Element _FixedDateTime { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDecimal")]
        public decimal? FixedDecimal { get; set; }
        [JsonProperty("_fixedDecimal")]
        public Element _FixedDecimal { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedId")]
        public string FixedId { get; set; }
        [JsonProperty("_fixedId")]
        public Element _FixedId { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedInstant")]
        public string FixedInstant { get; set; }
        [JsonProperty("_fixedInstant")]
        public Element _FixedInstant { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedInteger")]
        public int? FixedInteger { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedMarkdown")]
        public string FixedMarkdown { get; set; }
        [JsonProperty("_fixedMarkdown")]
        public Element _FixedMarkdown { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedOid")]
        public string FixedOid { get; set; }
        [JsonProperty("_fixedOid")]
        public Element _FixedOid { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedPositiveInt")]
        public uint? FixedPositiveInt { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedString")]
        public string FixedString { get; set; }
        [JsonProperty("_fixedString")]
        public Element _FixedString { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedTime")]
        public string FixedTime { get; set; }
        [JsonProperty("_fixedTime")]
        public Element _FixedTime { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedUnsignedInt")]
        public uint? FixedUnsignedInt { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedUri")]
        public string FixedUri { get; set; }
        [JsonProperty("_fixedUri")]
        public Element _FixedUri { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAddress")]
        public Address FixedAddress { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAge")]
        public Age FixedAge { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAnnotation")]
        public Annotation FixedAnnotation { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedAttachment")]
        public Attachment FixedAttachment { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCodeableConcept")]
        public CodeableConcept FixedCodeableConcept { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCoding")]
        public Coding FixedCoding { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedContactPoint")]
        public ContactPoint FixedContactPoint { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedCount")]
        public Count FixedCount { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDistance")]
        public Distance FixedDistance { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedDuration")]
        public Duration FixedDuration { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedHumanName")]
        public HumanName FixedHumanName { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedIdentifier")]
        public Identifier FixedIdentifier { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedMoney")]
        public Money FixedMoney { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedPeriod")]
        public Period FixedPeriod { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedQuantity")]
        public Quantity FixedQuantity { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedRange")]
        public Range FixedRange { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedRatio")]
        public Ratio FixedRatio { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedReference")]
        public Reference FixedReference { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedSampledData")]
        public SampledData FixedSampledData { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedSignature")]
        public Signature FixedSignature { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedTiming")]
        public Timing FixedTiming { get; set; }
        /// <summary>
        /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
        /// </summary>
        [JsonProperty("fixedMeta")]
        public Meta FixedMeta { get; set; }
        /// <summary>
        /// Only the definition of an element can set IsModifier true - either the specification itself or where an extension is originally defined. Once set, it cannot be changed in derived profiles. An element/extension that has isModifier=true SHOULD also have a minimum cardinality of 1, so that there is no lack of clarity about what to do if it is missing. If it can be missing, the definition SHALL make the meaning of a missing element clear.
        /// </summary>
        [JsonProperty("isModifier")]
        public bool? IsModifier { get; set; }
        /// <summary>
        /// Some resources include a set of simple metadata, and some very large data. This element is used to reduce the quantity of data returned in searches. Note that servers may pre-cache summarized resources for optimal performance, so servers may not support per-profile use of the isSummary flag. When a request is made with _summary=true, serailisers only include elements marked as 'isSummary = true'. Other than Attachment.data, all data type properties are included in the summary form. Modifier elements or elements with minimum cardinality = 1 must be marked as summary elements.
        /// </summary>
        [JsonProperty("isSummary")]
        public bool? IsSummary { get; set; }
        /// <summary>
        /// See also the extension (http://hl7.org/fhir/StructureDefinition/elementdefinition-question)[extension-elementdefinition-question.html].
        /// </summary>
        [JsonProperty("label")]
        public string Label { get; set; }
        [JsonProperty("_label")]
        public Element _Label { get; set; }
        /// <summary>
        /// Mappings are not necessarily specific enough for safe translation.
        /// </summary>
        [JsonProperty("mapping")]
        public ElementDefinitionMapping[] Mapping { get; set; }
        /// <summary>
        /// The maximum number of times this element is permitted to appear in the instance.
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// Receivers are not required to reject instances that exceed the maximum length.  The full length could be stored.  In some cases, data might be truncated, though truncation should be undertaken with care and an understanding of the consequences of doing so. If not specified, there is no conformance expectation for length support.
        /// </summary>
        [JsonProperty("maxLength")]
        public int? MaxLength { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueDate")]
        public string MaxValueDate { get; set; }
        [JsonProperty("_maxValueDate")]
        public Element _MaxValueDate { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueDateTime")]
        public string MaxValueDateTime { get; set; }
        [JsonProperty("_maxValueDateTime")]
        public Element _MaxValueDateTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueInstant")]
        public string MaxValueInstant { get; set; }
        [JsonProperty("_maxValueInstant")]
        public Element _MaxValueInstant { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueTime")]
        public string MaxValueTime { get; set; }
        [JsonProperty("_maxValueTime")]
        public Element _MaxValueTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueDecimal")]
        public decimal? MaxValueDecimal { get; set; }
        [JsonProperty("_maxValueDecimal")]
        public Element _MaxValueDecimal { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueInteger")]
        public int? MaxValueInteger { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValuePositiveInt")]
        public uint? MaxValuePositiveInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueUnsignedInt")]
        public uint? MaxValueUnsignedInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
        /// </summary>
        [JsonProperty("maxValueQuantity")]
        public Quantity MaxValueQuantity { get; set; }
        /// <summary>
        /// Implicit meanings for missing values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. An implicit meaning for a missing value can never be changed, and specifying one has the consequence that constraining its use in profiles eliminates use cases as possibilities, not merely moving them out of scope.
        /// </summary>
        [JsonProperty("meaningWhenMissing")]
        public string MeaningWhenMissing { get; set; }
        [JsonProperty("_meaningWhenMissing")]
        public Element _MeaningWhenMissing { get; set; }
        /// <summary>
        /// The minimum number of times this element SHALL appear in the instance.
        /// </summary>
        [JsonProperty("min")]
        public uint? Min { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueDate")]
        public string MinValueDate { get; set; }
        [JsonProperty("_minValueDate")]
        public Element _MinValueDate { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueDateTime")]
        public string MinValueDateTime { get; set; }
        [JsonProperty("_minValueDateTime")]
        public Element _MinValueDateTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueInstant")]
        public string MinValueInstant { get; set; }
        [JsonProperty("_minValueInstant")]
        public Element _MinValueInstant { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueTime")]
        public string MinValueTime { get; set; }
        [JsonProperty("_minValueTime")]
        public Element _MinValueTime { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueDecimal")]
        public decimal? MinValueDecimal { get; set; }
        [JsonProperty("_minValueDecimal")]
        public Element _MinValueDecimal { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueInteger")]
        public int? MinValueInteger { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValuePositiveInt")]
        public uint? MinValuePositiveInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueUnsignedInt")]
        public uint? MinValueUnsignedInt { get; set; }
        /// <summary>
        /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a a [Duration](datatypes.html#duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
        /// </summary>
        [JsonProperty("minValueQuantity")]
        public Quantity MinValueQuantity { get; set; }
        /// <summary>
        /// "Something useful" is context dependent and impossible to describe in the base FHIR specification. For this reason, tue mustSupport flag is never set to true by the FHIR specification itself - it is only set to true in profiles. 
        /// This is done in [Resource Profiles](profiling.html#mustsupport), where the profile labels an element as mustSupport=true. When a profile does this, it SHALL also make clear exactly what kind of "support" is required, as this can mean many things.
        /// Note that an element that has the property IsModifier is not necessarily a "key" element (e.g. one of the important elements to make use of the resource), nor is it automatically mustSupport - however both of these things are more likely to be true for IsModifier elements than for other elements.
        /// </summary>
        [JsonProperty("mustSupport")]
        public bool? MustSupport { get; set; }
        /// <summary>
        /// This element can only be asserted on repeating elements and can only be introduced when defining resources or data types.  It can be further refined profiled elements but if absent in the base type, a profile cannot assert meaning.
        /// </summary>
        [JsonProperty("orderMeaning")]
        public string OrderMeaning { get; set; }
        [JsonProperty("_orderMeaning")]
        public Element _OrderMeaning { get; set; }
        /// <summary>
        /// The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }
        [JsonProperty("_path")]
        public Element _Path { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternBase64Binary")]
        public string PatternBase64Binary { get; set; }
        [JsonProperty("_patternBase64Binary")]
        public Element _PatternBase64Binary { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternBoolean")]
        public bool? PatternBoolean { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternCode")]
        public string PatternCode { get; set; }
        [JsonProperty("_patternCode")]
        public Element _PatternCode { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternDate")]
        public string PatternDate { get; set; }
        [JsonProperty("_patternDate")]
        public Element _PatternDate { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternDateTime")]
        public string PatternDateTime { get; set; }
        [JsonProperty("_patternDateTime")]
        public Element _PatternDateTime { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternDecimal")]
        public decimal? PatternDecimal { get; set; }
        [JsonProperty("_patternDecimal")]
        public Element _PatternDecimal { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternId")]
        public string PatternId { get; set; }
        [JsonProperty("_patternId")]
        public Element _PatternId { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternInstant")]
        public string PatternInstant { get; set; }
        [JsonProperty("_patternInstant")]
        public Element _PatternInstant { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternInteger")]
        public int? PatternInteger { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternMarkdown")]
        public string PatternMarkdown { get; set; }
        [JsonProperty("_patternMarkdown")]
        public Element _PatternMarkdown { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternOid")]
        public string PatternOid { get; set; }
        [JsonProperty("_patternOid")]
        public Element _PatternOid { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternPositiveInt")]
        public uint? PatternPositiveInt { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternString")]
        public string PatternString { get; set; }
        [JsonProperty("_patternString")]
        public Element _PatternString { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternTime")]
        public string PatternTime { get; set; }
        [JsonProperty("_patternTime")]
        public Element _PatternTime { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternUnsignedInt")]
        public uint? PatternUnsignedInt { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternUri")]
        public string PatternUri { get; set; }
        [JsonProperty("_patternUri")]
        public Element _PatternUri { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternAddress")]
        public Address PatternAddress { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternAge")]
        public Age PatternAge { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternAnnotation")]
        public Annotation PatternAnnotation { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternAttachment")]
        public Attachment PatternAttachment { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternCodeableConcept")]
        public CodeableConcept PatternCodeableConcept { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternCoding")]
        public Coding PatternCoding { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternContactPoint")]
        public ContactPoint PatternContactPoint { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternCount")]
        public Count PatternCount { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternDistance")]
        public Distance PatternDistance { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternDuration")]
        public Duration PatternDuration { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternHumanName")]
        public HumanName PatternHumanName { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternIdentifier")]
        public Identifier PatternIdentifier { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternMoney")]
        public Money PatternMoney { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternPeriod")]
        public Period PatternPeriod { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternQuantity")]
        public Quantity PatternQuantity { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternRange")]
        public Range PatternRange { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternRatio")]
        public Ratio PatternRatio { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternReference")]
        public Reference PatternReference { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternSampledData")]
        public SampledData PatternSampledData { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternSignature")]
        public Signature PatternSignature { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternTiming")]
        public Timing PatternTiming { get; set; }
        /// <summary>
        /// Mostly used for fixing values of CodeableConcept. At present, pattern[x] is not recommended as a basis for slicing while issues related to this are investigated during the STU period.
        /// </summary>
        [JsonProperty("patternMeta")]
        public Meta PatternMeta { get; set; }
        /// <summary>
        /// In resources, this is rarely used except for special cases where the representation deviates from the normal, and can only be done in the base standard (and profiles must reproduce what the base standard does). This element is used quite commonly in Logical models when the logical models represent a specific serialization format (e.g. CDA, v2 etc).
        /// </summary>
        [JsonProperty("representation")]
        public string[] Representation { get; set; }
        [JsonProperty("_representation")]
        public Element[] _Representation { get; set; }
        /// <summary>
        /// This element does not describe the usage of the element (that's done in comments), rather it's for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
        /// </summary>
        [JsonProperty("requirements")]
        public string Requirements { get; set; }
        [JsonProperty("_requirements")]
        public Element _Requirements { get; set; }
        /// <summary>
        /// May change the term to provide language more appropriate to the context of the profile or to reflect slicing.
        /// </summary>
        [JsonProperty("short")]
        public string Short { get; set; }
        [JsonProperty("_short")]
        public Element _Short { get; set; }
        /// <summary>
        /// The name SHALL be unique within the structure within the context of the constrained resource element.  (Though to avoid confusion, uniqueness across all elements is recommended.).
        /// </summary>
        [JsonProperty("sliceName")]
        public string SliceName { get; set; }
        [JsonProperty("_sliceName")]
        public Element _SliceName { get; set; }
        /// <summary>
        /// The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
        /// </summary>
        [JsonProperty("slicing")]
        public ElementDefinitionSlicing Slicing { get; set; }
        /// <summary>
        /// The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
        /// </summary>
        [JsonProperty("type")]
        public ElementDefinitionType[] Type { get; set; }
    }
    /// <summary>
    /// Code Values for the ElementDefinition.representation field
    /// </summary>
    public static class ElementDefinitionRepresentationCodes
    {
        public const string XMLATTR = "xmlAttr";
        public const string XMLTEXT = "xmlText";
        public const string TYPEATTR = "typeAttr";
        public const string CDATEXT = "cdaText";
        public const string XHTML = "xhtml";
    }
    /// <summary>
    /// Optional Extension Element - found in all resources.
    /// </summary>
    public class Extension : Element
    {
        /// <summary>
        /// The definition may point directly to a computable or human-readable definition of the extensibility codes, or it may be a logical URI as declared in some other specification. The definition SHALL be a URI for the Structure Definition defining the extension.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueBase64Binary")]
        public string ValueBase64Binary { get; set; }
        [JsonProperty("_valueBase64Binary")]
        public Element _ValueBase64Binary { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool? ValueBoolean { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCode")]
        public string ValueCode { get; set; }
        [JsonProperty("_valueCode")]
        public Element _ValueCode { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDate")]
        public string ValueDate { get; set; }
        [JsonProperty("_valueDate")]
        public Element _ValueDate { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDateTime")]
        public string ValueDateTime { get; set; }
        [JsonProperty("_valueDateTime")]
        public Element _ValueDateTime { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDecimal")]
        public decimal? ValueDecimal { get; set; }
        [JsonProperty("_valueDecimal")]
        public Element _ValueDecimal { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueId")]
        public string ValueId { get; set; }
        [JsonProperty("_valueId")]
        public Element _ValueId { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueInstant")]
        public string ValueInstant { get; set; }
        [JsonProperty("_valueInstant")]
        public Element _ValueInstant { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueInteger")]
        public int? ValueInteger { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueMarkdown")]
        public string ValueMarkdown { get; set; }
        [JsonProperty("_valueMarkdown")]
        public Element _ValueMarkdown { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueOid")]
        public string ValueOid { get; set; }
        [JsonProperty("_valueOid")]
        public Element _ValueOid { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valuePositiveInt")]
        public uint? ValuePositiveInt { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueTime")]
        public string ValueTime { get; set; }
        [JsonProperty("_valueTime")]
        public Element _ValueTime { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueUnsignedInt")]
        public uint? ValueUnsignedInt { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueUri")]
        public string ValueUri { get; set; }
        [JsonProperty("_valueUri")]
        public Element _ValueUri { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAddress")]
        public Address ValueAddress { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAge")]
        public Age ValueAge { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAnnotation")]
        public Annotation ValueAnnotation { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueAttachment")]
        public Attachment ValueAttachment { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCodeableConcept")]
        public CodeableConcept ValueCodeableConcept { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCoding")]
        public Coding ValueCoding { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueContactPoint")]
        public ContactPoint ValueContactPoint { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueCount")]
        public Count ValueCount { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDistance")]
        public Distance ValueDistance { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueDuration")]
        public Duration ValueDuration { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueHumanName")]
        public HumanName ValueHumanName { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueIdentifier")]
        public Identifier ValueIdentifier { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueMoney")]
        public Money ValueMoney { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valuePeriod")]
        public Period ValuePeriod { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueQuantity")]
        public Quantity ValueQuantity { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueRange")]
        public Range ValueRange { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueRatio")]
        public Ratio ValueRatio { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueReference")]
        public Reference ValueReference { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueSampledData")]
        public SampledData ValueSampledData { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueSignature")]
        public Signature ValueSignature { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueTiming")]
        public Timing ValueTiming { get; set; }
        /// <summary>
        /// Value of extension - may be a resource or one of a constrained set of the data types (see Extensibility in the spec for list).
        /// </summary>
        [JsonProperty("valueMeta")]
        public Meta ValueMeta { get; set; }
    }
    /// <summary>
    /// A human's name with the ability to identify parts and usage.
    /// </summary>
    public class HumanName : Element
    {
        /// <summary>
        /// Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
        /// </summary>
        [JsonProperty("family")]
        public string Family { get; set; }
        [JsonProperty("_family")]
        public Element _Family { get; set; }
        /// <summary>
        /// If only initials are recorded, they may be used in place of the full name.  Not called "first name" since given names do not always come first.
        /// </summary>
        [JsonProperty("given")]
        public string[] Given { get; set; }
        [JsonProperty("_given")]
        public Element[] _Given { get; set; }
        /// <summary>
        /// Indicates the period of time when this name was valid for the named person.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
        /// </summary>
        [JsonProperty("prefix")]
        public string[] Prefix { get; set; }
        [JsonProperty("_prefix")]
        public Element[] _Prefix { get; set; }
        /// <summary>
        /// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
        /// </summary>
        [JsonProperty("suffix")]
        public string[] Suffix { get; set; }
        [JsonProperty("_suffix")]
        public Element[] _Suffix { get; set; }
        /// <summary>
        /// Can provide both a text representation and structured parts.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }
        [JsonProperty("_text")]
        public Element _Text { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary or old name etc.for a current/permanent one. Applications can assume that a name is current unless it explicitly says that it is temporary or old.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
    }
    /// <summary>
    /// Code Values for the HumanName.use field
    /// </summary>
    public static class HumanNameUseCodes
    {
        public const string USUAL = "usual";
        public const string OFFICIAL = "official";
        public const string TEMP = "temp";
        public const string NICKNAME = "nickname";
        public const string ANONYMOUS = "anonymous";
        public const string OLD = "old";
        public const string MAIDEN = "maiden";
    }
    /// <summary>
    /// A technical identifier - identifies some entity uniquely and unambiguously.
    /// </summary>
    public class Identifier : Element
    {
        /// <summary>
        /// The Identifier.assigner may omit the .reference element and only contain a .display element reflecting the name or other textual information about the assigning organization.
        /// </summary>
        [JsonProperty("assigner")]
        public Reference Assigner { get; set; }
        /// <summary>
        /// Time period during which identifier is/was valid for use.
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Establishes the namespace for the value - that is, a URL that describes a set values that are unique.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage. 
        /// Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
        /// </summary>
        [JsonProperty("type")]
        public CodeableConcept Type { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because applications should not mistake a temporary id for a permanent one. Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
        /// <summary>
        /// If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.  The value's primary purpose is computational mapping.  As a result, it may be normalized for comparison purposes (e.g. removing non-significant whitespace, dashes, etc.)  A value formatted for human display can be conveyed using the [Rendered Value extension](extension-rendered-value.html).
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the Identifier.use field
    /// </summary>
    public static class IdentifierUseCodes
    {
        public const string USUAL = "usual";
        public const string OFFICIAL = "official";
        public const string TEMP = "temp";
        public const string SECONDARY = "secondary";
    }
    /// <summary>
    /// The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource.
    /// </summary>
    public class Meta : Element
    {
        /// <summary>
        /// This value is always populated except when the resource is first being created. The server / resource manager sets this value; what a client provides is irrelevant.
        /// </summary>
        [JsonProperty("lastUpdated")]
        public string LastUpdated { get; set; }
        [JsonProperty("_lastUpdated")]
        public Element _LastUpdated { get; set; }
        /// <summary>
        /// It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time.  The list of profile URLs is a set.
        /// </summary>
        [JsonProperty("profile")]
        public string[] Profile { get; set; }
        [JsonProperty("_profile")]
        public Element[] _Profile { get; set; }
        /// <summary>
        /// The security labels can be updated without changing the stated version of the resource  The list of security labels is a set. Uniqueness is based the system/code, and version and display are ignored.
        /// </summary>
        [JsonProperty("security")]
        public Coding[] Security { get; set; }
        /// <summary>
        /// The tags can be updated without changing the stated version of the resource.  The list of tags is a set. Uniqueness is based the system/code, and version and display are ignored.
        /// </summary>
        [JsonProperty("tag")]
        public Coding[] Tag { get; set; }
        /// <summary>
        /// The server assigns this value, and ignores what the client specifies, except in the case that the server is imposing version integrity on updates/deletes.
        /// </summary>
        [JsonProperty("versionId")]
        public string VersionId { get; set; }
        [JsonProperty("_versionId")]
        public Element _VersionId { get; set; }
    }
    /// <summary>
    /// An amount of economic utility in some recognized currency.
    /// </summary>
    public class Money : Quantity
    {
    }
    /// <summary>
    /// A human-readable formatted text, including images.
    /// </summary>
    public class Narrative : Element
    {
        /// <summary>
        /// The contents of the html element are an XHTML fragment containing only the basic html formatting elements described in chapters 7-11 and 15 of the HTML 4.0 standard, <a> elements (either name or href), images and internally contained stylesheets. The XHTML content may not contain a head, a body, external stylesheet references, scripts, forms, base/link/xlink, frames, iframes and objects.
        /// </summary>
        [JsonProperty("div")]
        public string Div { get; set; }
        [JsonProperty("_div")]
        public Element _Div { get; set; }
        /// <summary>
        /// The status of the narrative - whether it's entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
    }
    /// <summary>
    /// Code Values for the Narrative.status field
    /// </summary>
    public static class NarrativeStatusCodes
    {
        public const string GENERATED = "generated";
        public const string EXTENSIONS = "extensions";
        public const string ADDITIONAL = "additional";
        public const string EMPTY = "empty";
    }
    /// <summary>
    /// A time period defined by a start and end date and optionally time.
    /// </summary>
    public class Period : Element
    {
        /// <summary>
        /// The high value includes any matching date/time. i.e. 2012-02-03T10:00:00 is in a period that has a end value of 2012-02-03.
        /// </summary>
        [JsonProperty("end")]
        public string End { get; set; }
        [JsonProperty("_end")]
        public Element _End { get; set; }
        /// <summary>
        /// If the low element is missing, the meaning is that the low boundary is not known.
        /// </summary>
        [JsonProperty("start")]
        public string Start { get; set; }
        [JsonProperty("_start")]
        public Element _Start { get; set; }
    }
    /// <summary>
    /// A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
    /// </summary>
    public class Quantity : Element
    {
        /// <summary>
        /// The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// This is labeled as "Is Modifier" because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value.
        /// </summary>
        [JsonProperty("comparator")]
        public string Comparator { get; set; }
        [JsonProperty("_comparator")]
        public Element _Comparator { get; set; }
        /// <summary>
        /// The identification of the system that provides the coded form of the unit.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// A human-readable form of the unit.
        /// </summary>
        [JsonProperty("unit")]
        public string Unit { get; set; }
        [JsonProperty("_unit")]
        public Element _Unit { get; set; }
        /// <summary>
        /// The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
        /// </summary>
        [JsonProperty("value")]
        public decimal? Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the Quantity.comparator field
    /// </summary>
    public static class QuantityComparatorCodes
    {
        public const string LESS_THAN = "<";
        public const string LESS_THAN_OR_EQUALS = "<=";
        public const string GREATER_THAN_OR_EQUALS = ">=";
        public const string GREATER_THAN = ">";
    }
    /// <summary>
    /// A set of ordered Quantities defined by a low and high limit.
    /// </summary>
    public class Range : Element
    {
        /// <summary>
        /// If the high element is missing, the high boundary is not known.
        /// </summary>
        [JsonProperty("high")]
        public Quantity High { get; set; }
        /// <summary>
        /// If the low element is missing, the low boundary is not known.
        /// </summary>
        [JsonProperty("low")]
        public Quantity Low { get; set; }
    }
    /// <summary>
    /// A relationship of two Quantity values - expressed as a numerator and a denominator.
    /// </summary>
    public class Ratio : Element
    {
        /// <summary>
        /// The value of the denominator.
        /// </summary>
        [JsonProperty("denominator")]
        public Quantity Denominator { get; set; }
        /// <summary>
        /// The value of the numerator.
        /// </summary>
        [JsonProperty("numerator")]
        public Quantity Numerator { get; set; }
    }
    /// <summary>
    /// A reference from one resource to another.
    /// </summary>
    public class Reference : Element
    {
        /// <summary>
        /// This is generally not the same as the Resource.text of the referenced resource.  The purpose is to identify what's being referenced, not to fully describe it.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// When an identifier is provided in place of a reference, any system processing the reference will only be able to resolve the identifier to a reference if it understands the business context in which the identifier is used. Sometimes this is global (e.g. a national identifier) but often it is not. For this reason, none of the useful mechanisms described for working with references (e.g. chaining, includes) are possible, nor should servers be expected to be able resolve the reference. Servers may accept an identifier based reference untouched, resolve it, and/or reject it - see CapabilityStatement.rest.resource.referencePolicy. 
        /// When both an identifier and a literal reference are provided, the literal reference is preferred. Applications processing the resource are allowed - but not required - to check that the identifier matches the literal reference
        /// Applications converting a logical reference to a literal reference may choose to leave the logical reference present, or remove it.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier Identifier { get; set; }
        /// <summary>
        /// Using absolute URLs provides a stable scalable approach suitable for a cloud/web context, while using relative/logical references provides a flexible approach suitable for use when trading across closed eco-system boundaries.   Absolute URLs do not need to point to a FHIR RESTful server, though this is the preferred approach. If the URL conforms to the structure "/[type]/[id]" then it should be assumed that the reference is to a FHIR RESTful server.
        /// </summary>
        [JsonProperty("reference")]
        public string ReferenceField { get; set; }
        [JsonProperty("_reference")]
        public Element _ReferenceField { get; set; }
    }
    /// <summary>
    /// A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
    /// </summary>
    public class SampledData : Element
    {
        /// <summary>
        /// A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
        /// </summary>
        [JsonProperty("data")]
        public string Data { get; set; }
        [JsonProperty("_data")]
        public Element _Data { get; set; }
        /// <summary>
        /// If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
        /// </summary>
        [JsonProperty("dimensions")]
        public uint Dimensions { get; set; }
        /// <summary>
        /// A correction factor that is applied to the sampled data points before they are added to the origin.
        /// </summary>
        [JsonProperty("factor")]
        public decimal? Factor { get; set; }
        [JsonProperty("_factor")]
        public Element _Factor { get; set; }
        /// <summary>
        /// The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
        /// </summary>
        [JsonProperty("lowerLimit")]
        public decimal? LowerLimit { get; set; }
        [JsonProperty("_lowerLimit")]
        public Element _LowerLimit { get; set; }
        /// <summary>
        /// The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
        /// </summary>
        [JsonProperty("origin")]
        public Quantity Origin { get; set; }
        /// <summary>
        /// This is usually a whole number.
        /// </summary>
        [JsonProperty("period")]
        public decimal Period { get; set; }
        [JsonProperty("_period")]
        public Element _Period { get; set; }
        /// <summary>
        /// The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
        /// </summary>
        [JsonProperty("upperLimit")]
        public decimal? UpperLimit { get; set; }
        [JsonProperty("_upperLimit")]
        public Element _UpperLimit { get; set; }
    }
    /// <summary>
    /// A digital signature along with supporting context. The signature may be electronic/cryptographic in nature, or a graphical image representing a hand-written signature, or a signature process. Different signature approaches have different utilities.
    /// </summary>
    public class Signature : Element
    {
        /// <summary>
        /// Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
        /// </summary>
        [JsonProperty("blob")]
        public string Blob { get; set; }
        [JsonProperty("_blob")]
        public Element _Blob { get; set; }
        /// <summary>
        /// A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jwt for JWT, and image/* for a graphical image of a signature, etc.
        /// </summary>
        [JsonProperty("contentType")]
        public string ContentType { get; set; }
        [JsonProperty("_contentType")]
        public Element _ContentType { get; set; }
        /// <summary>
        /// The party that can't sign. For example a child.
        /// </summary>
        [JsonProperty("onBehalfOfUri")]
        public string OnBehalfOfUri { get; set; }
        [JsonProperty("_onBehalfOfUri")]
        public Element _OnBehalfOfUri { get; set; }
        /// <summary>
        /// The party that can't sign. For example a child.
        /// </summary>
        [JsonProperty("onBehalfOfReference")]
        public Reference OnBehalfOfReference { get; set; }
        /// <summary>
        /// Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
        /// </summary>
        [JsonProperty("type")]
        public Coding[] Type { get; set; }
        /// <summary>
        /// This should agree with the information in the signature.
        /// </summary>
        [JsonProperty("when")]
        public string When { get; set; }
        [JsonProperty("_when")]
        public Element _When { get; set; }
        /// <summary>
        /// This should agree with the information in the signature.
        /// </summary>
        [JsonProperty("whoUri")]
        public string WhoUri { get; set; }
        [JsonProperty("_whoUri")]
        public Element _WhoUri { get; set; }
        /// <summary>
        /// This should agree with the information in the signature.
        /// </summary>
        [JsonProperty("whoReference")]
        public Reference WhoReference { get; set; }
    }
    /// <summary>
    /// A set of rules that describe when the event is scheduled.
    /// </summary>
    public class TimingRepeat : Element
    {
        /// <summary>
        /// Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// </summary>
        [JsonProperty("boundsDuration")]
        public Duration BoundsDuration { get; set; }
        /// <summary>
        /// Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// </summary>
        [JsonProperty("boundsRange")]
        public Range BoundsRange { get; set; }
        /// <summary>
        /// Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// </summary>
        [JsonProperty("boundsPeriod")]
        public Period BoundsPeriod { get; set; }
        /// <summary>
        /// If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
        /// </summary>
        [JsonProperty("count")]
        public int? Count { get; set; }
        /// <summary>
        /// A maximum value for the count of the desired repetitions (e.g. do something 6-8 times).
        /// </summary>
        [JsonProperty("countMax")]
        public int? CountMax { get; set; }
        /// <summary>
        /// If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek.
        /// </summary>
        [JsonProperty("dayOfWeek")]
        public string[] DayOfWeek { get; set; }
        [JsonProperty("_dayOfWeek")]
        public Element[] _DayOfWeek { get; set; }
        /// <summary>
        /// For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
        /// </summary>
        [JsonProperty("duration")]
        public decimal? Duration { get; set; }
        [JsonProperty("_duration")]
        public Element _Duration { get; set; }
        /// <summary>
        /// For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
        /// </summary>
        [JsonProperty("durationMax")]
        public decimal? DurationMax { get; set; }
        [JsonProperty("_durationMax")]
        public Element _DurationMax { get; set; }
        /// <summary>
        /// The units of time for the duration, in UCUM units.
        /// </summary>
        [JsonProperty("durationUnit")]
        public string DurationUnit { get; set; }
        [JsonProperty("_durationUnit")]
        public Element _DurationUnit { get; set; }
        /// <summary>
        /// The number of times to repeat the action within the specified period / period range (i.e. both period and periodMax provided).
        /// </summary>
        [JsonProperty("frequency")]
        public int? Frequency { get; set; }
        /// <summary>
        /// If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
        /// </summary>
        [JsonProperty("frequencyMax")]
        public int? FrequencyMax { get; set; }
        /// <summary>
        /// The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
        /// </summary>
        [JsonProperty("offset")]
        public uint? Offset { get; set; }
        /// <summary>
        /// Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period.
        /// </summary>
        [JsonProperty("period")]
        public decimal? Period { get; set; }
        [JsonProperty("_period")]
        public Element _Period { get; set; }
        /// <summary>
        /// If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
        /// </summary>
        [JsonProperty("periodMax")]
        public decimal? PeriodMax { get; set; }
        [JsonProperty("_periodMax")]
        public Element _PeriodMax { get; set; }
        /// <summary>
        /// The units of time for the period in UCUM units.
        /// </summary>
        [JsonProperty("periodUnit")]
        public string PeriodUnit { get; set; }
        [JsonProperty("_periodUnit")]
        public Element _PeriodUnit { get; set; }
        /// <summary>
        /// When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
        /// </summary>
        [JsonProperty("timeOfDay")]
        public string[] TimeOfDay { get; set; }
        [JsonProperty("_timeOfDay")]
        public Element[] _TimeOfDay { get; set; }
        /// <summary>
        /// When more than one event is listed, the event is tied to the union of the specified events.
        /// </summary>
        [JsonProperty("when")]
        public string[] When { get; set; }
        [JsonProperty("_when")]
        public Element[] _When { get; set; }
    }
    /// <summary>
    /// Code Values for the Timing.repeat.dayOfWeek field
    /// </summary>
    public static class TimingRepeatDayOfWeekCodes
    {
        public const string MON = "mon";
        public const string TUE = "tue";
        public const string WED = "wed";
        public const string THU = "thu";
        public const string FRI = "fri";
        public const string SAT = "sat";
        public const string SUN = "sun";
    }
    /// <summary>
    /// Code Values for the Timing.repeat.durationUnit field
    /// </summary>
    public static class TimingRepeatDurationUnitCodes
    {
        public const string S = "s";
        public const string MIN = "min";
        public const string H = "h";
        public const string D = "d";
        public const string WK = "wk";
        public const string MO = "mo";
        public const string A = "a";
    }
    /// <summary>
    /// Code Values for the Timing.repeat.periodUnit field
    /// </summary>
    public static class TimingRepeatPeriodUnitCodes
    {
        public const string S = "s";
        public const string MIN = "min";
        public const string H = "h";
        public const string D = "d";
        public const string WK = "wk";
        public const string MO = "mo";
        public const string A = "a";
    }
    /// <summary>
    /// Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
    /// </summary>
    public class Timing : Element
    {
        /// <summary>
        /// BID etc are defined as 'at institutionally specified times'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or the a structured representation should be used (in this case, specifying the two event times).
        /// </summary>
        [JsonProperty("code")]
        public CodeableConcept Code { get; set; }
        /// <summary>
        /// Identifies specific times when the event occurs.
        /// </summary>
        [JsonProperty("event")]
        public string[] Event { get; set; }
        [JsonProperty("_event")]
        public Element[] _Event { get; set; }
        /// <summary>
        /// A set of rules that describe when the event is scheduled.
        /// </summary>
        [JsonProperty("repeat")]
        public TimingRepeat Repeat { get; set; }
    }
    /// <summary>
    /// Specifies clinical/business/etc metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
    /// </summary>
    public class UsageContext : Element
    {
        /// <summary>
        /// A code that identifies the type of context being specified by this usage context.
        /// </summary>
        [JsonProperty("code")]
        public Coding Code { get; set; }
        /// <summary>
        /// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
        /// </summary>
        [JsonProperty("valueCodeableConcept")]
        public CodeableConcept ValueCodeableConcept { get; set; }
        /// <summary>
        /// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
        /// </summary>
        [JsonProperty("valueQuantity")]
        public Quantity ValueQuantity { get; set; }
        /// <summary>
        /// A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
        /// </summary>
        [JsonProperty("valueRange")]
        public Range ValueRange { get; set; }
    }
    /// <summary>
    /// Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
    /// </summary>
    public class CapabilityStatementSoftware : BackboneElement
    {
        /// <summary>
        /// Name software is known by.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Date this version of the software was released.
        /// </summary>
        [JsonProperty("releaseDate")]
        public string ReleaseDate { get; set; }
        [JsonProperty("_releaseDate")]
        public Element _ReleaseDate { get; set; }
        /// <summary>
        /// If possible, a version should be specified, as statements are likely to be different for different versions of software.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
    /// </summary>
    public class CapabilityStatementImplementation : BackboneElement
    {
        /// <summary>
        /// Information about the specific installation that this capability statement relates to.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
    }
    /// <summary>
    /// Certificates associated with security profiles.
    /// </summary>
    public class CapabilityStatementRestSecurityCertificate : BackboneElement
    {
        /// <summary>
        /// Actual certificate.
        /// </summary>
        [JsonProperty("blob")]
        public string Blob { get; set; }
        [JsonProperty("_blob")]
        public Element _Blob { get; set; }
        /// <summary>
        /// Mime type for a certificate.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
    }
    /// <summary>
    /// Information about security implementation from an interface perspective - what a client needs to know.
    /// </summary>
    public class CapabilityStatementRestSecurity : BackboneElement
    {
        /// <summary>
        /// Certificates associated with security profiles.
        /// </summary>
        [JsonProperty("certificate")]
        public CapabilityStatementRestSecurityCertificate[] Certificate { get; set; }
        /// <summary>
        /// The easiest CORS headers to add are Access-Control-Allow-Origin: * & Access-Control-Request-Method: GET, POST, PUT, DELETE. All servers SHOULD support CORS.
        /// </summary>
        [JsonProperty("cors")]
        public bool? Cors { get; set; }
        /// <summary>
        /// General description of how security works.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Types of security services that are supported/required by the system.
        /// </summary>
        [JsonProperty("service")]
        public CodeableConcept[] Service { get; set; }
    }
    /// <summary>
    /// Identifies a restful operation supported by the solution.
    /// </summary>
    public class CapabilityStatementRestResourceInteraction : BackboneElement
    {
        /// <summary>
        /// Coded identifier of the operation, supported by the system resource.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.resource.interaction.code field
    /// </summary>
    public static class CapabilityStatementRestResourceInteractionCodeCodes
    {
        public const string READ = "read";
        public const string VREAD = "vread";
        public const string UPDATE = "update";
        public const string PATCH = "patch";
        public const string DELETE = "delete";
        public const string HISTORY_INSTANCE = "history-instance";
        public const string HISTORY_TYPE = "history-type";
        public const string CREATE = "create";
        public const string SEARCH_TYPE = "search-type";
    }
    /// <summary>
    /// Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    /// </summary>
    public class CapabilityStatementRestResourceSearchParam : BackboneElement
    {
        /// <summary>
        /// This SHOULD be present, and matches refers to a SearchParameter by its canonical url. If systems wish to document their support for modifiers, comparators, target resource types, and chained parameters, they should do using a search parameter resource.
        /// </summary>
        [JsonProperty("definition")]
        public string Definition { get; set; }
        [JsonProperty("_definition")]
        public Element _Definition { get; set; }
        /// <summary>
        /// This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// Parameter names cannot overlap with standard parameter names, and standard parameters cannot be redefined.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// While this can be looked up from the definition, it is included here as a convenience for systems that autogenerate a query interface based on the server capability statement.  It SHALL be the same as the type in the search parameter definition.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.resource.searchParam.type field
    /// </summary>
    public static class CapabilityStatementRestResourceSearchParamTypeCodes
    {
        public const string NUMBER = "number";
        public const string DATE = "date";
        public const string VAL_STRING = "string";
        public const string TOKEN = "token";
        public const string REFERENCE = "reference";
        public const string COMPOSITE = "composite";
        public const string QUANTITY = "quantity";
        public const string URI = "uri";
    }
    /// <summary>
    /// Max of one repetition per resource type.
    /// </summary>
    public class CapabilityStatementRestResource : BackboneElement
    {
        /// <summary>
        /// Conditional Create is mainly appropriate for interface engine scripts converting from other formats, such as v2.
        /// </summary>
        [JsonProperty("conditionalCreate")]
        public bool? ConditionalCreate { get; set; }
        /// <summary>
        /// Conditional Delete is mainly appropriate for interface engine scripts converting from other formats, such as v2.
        /// </summary>
        [JsonProperty("conditionalDelete")]
        public string ConditionalDelete { get; set; }
        [JsonProperty("_conditionalDelete")]
        public Element _ConditionalDelete { get; set; }
        /// <summary>
        /// Conditional Read is mainly appropriate for interface engine scripts converting from other formats, such as v2.
        /// </summary>
        [JsonProperty("conditionalRead")]
        public string ConditionalRead { get; set; }
        [JsonProperty("_conditionalRead")]
        public Element _ConditionalRead { get; set; }
        /// <summary>
        /// Conditional Update is mainly appropriate for interface engine scripts converting from other formats, such as v2.
        /// </summary>
        [JsonProperty("conditionalUpdate")]
        public bool? ConditionalUpdate { get; set; }
        /// <summary>
        /// Additional information about the resource type used by the system.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// Identifies a restful operation supported by the solution.
        /// </summary>
        [JsonProperty("interaction")]
        public CapabilityStatementRestResourceInteraction[] Interaction { get; set; }
        /// <summary>
        /// The profile applies to all  resources of this type - i.e. it is the superset of what is supported by the system.
        /// </summary>
        [JsonProperty("profile")]
        public Reference Profile { get; set; }
        /// <summary>
        /// It is useful to support the vRead operation for current operations, even if past versions aren't available.
        /// </summary>
        [JsonProperty("readHistory")]
        public bool? ReadHistory { get; set; }
        /// <summary>
        /// A set of flags that defines how references are supported.
        /// </summary>
        [JsonProperty("referencePolicy")]
        public string[] ReferencePolicy { get; set; }
        [JsonProperty("_referencePolicy")]
        public Element[] _ReferencePolicy { get; set; }
        /// <summary>
        /// If this list is empty, the server does not support includes.
        /// </summary>
        [JsonProperty("searchInclude")]
        public string[] SearchInclude { get; set; }
        [JsonProperty("_searchInclude")]
        public Element[] _SearchInclude { get; set; }
        /// <summary>
        /// Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
        /// </summary>
        [JsonProperty("searchParam")]
        public CapabilityStatementRestResourceSearchParam[] SearchParam { get; set; }
        /// <summary>
        /// If this list is empty, the server does not support reverse includes.
        /// </summary>
        [JsonProperty("searchRevInclude")]
        public string[] SearchRevInclude { get; set; }
        [JsonProperty("_searchRevInclude")]
        public Element[] _SearchRevInclude { get; set; }
        /// <summary>
        /// A type of resource exposed via the restful interface.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// Allowing the clients to create new identities on the server means that the system administrator needs to have confidence that the clients do not create clashing identities between them. Obviously, if there is only one client, this won't happen. While creating identities on the client means that the clients need to be managed, it's much more convenient for many scenarios if such management can be put in place.
        /// </summary>
        [JsonProperty("updateCreate")]
        public bool? UpdateCreate { get; set; }
        /// <summary>
        /// If a server supports versionIds correctly, it SHOULD support vread too, but is not required to do so.
        /// </summary>
        [JsonProperty("versioning")]
        public string Versioning { get; set; }
        [JsonProperty("_versioning")]
        public Element _Versioning { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.resource.conditionalDelete field
    /// </summary>
    public static class CapabilityStatementRestResourceConditionalDeleteCodes
    {
        public const string NOT_SUPPORTED = "not-supported";
        public const string SINGLE = "single";
        public const string MULTIPLE = "multiple";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.resource.conditionalRead field
    /// </summary>
    public static class CapabilityStatementRestResourceConditionalReadCodes
    {
        public const string NOT_SUPPORTED = "not-supported";
        public const string MODIFIED_SINCE = "modified-since";
        public const string NOT_MATCH = "not-match";
        public const string FULL_SUPPORT = "full-support";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.resource.referencePolicy field
    /// </summary>
    public static class CapabilityStatementRestResourceReferencePolicyCodes
    {
        public const string LITERAL = "literal";
        public const string LOGICAL = "logical";
        public const string RESOLVES = "resolves";
        public const string ENFORCED = "enforced";
        public const string LOCAL = "local";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.resource.versioning field
    /// </summary>
    public static class CapabilityStatementRestResourceVersioningCodes
    {
        public const string NO_VERSION = "no-version";
        public const string VERSIONED = "versioned";
        public const string VERSIONED_UPDATE = "versioned-update";
    }
    /// <summary>
    /// A specification of restful operations supported by the system.
    /// </summary>
    public class CapabilityStatementRestInteraction : BackboneElement
    {
        /// <summary>
        /// A coded identifier of the operation, supported by the system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.interaction.code field
    /// </summary>
    public static class CapabilityStatementRestInteractionCodeCodes
    {
        public const string TRANSACTION = "transaction";
        public const string BATCH = "batch";
        public const string SEARCH_SYSTEM = "search-system";
        public const string HISTORY_SYSTEM = "history-system";
    }
    /// <summary>
    /// Definition of an operation or a named query together with its parameters and their meaning and type.
    /// </summary>
    public class CapabilityStatementRestOperation : BackboneElement
    {
        /// <summary>
        /// This can be used to build an HTML form to invoke the operation, for instance.
        /// </summary>
        [JsonProperty("definition")]
        public Reference Definition { get; set; }
        /// <summary>
        /// The name here SHOULD be the same as the name in the definition, unless there is a name clash and the name cannot be used. The name does not include the "$" portion that is always included in the URL.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
    }
    /// <summary>
    /// Multiple repetitions allow definition of both client and/or server behaviors or possibly behaviors under different configuration settings (for software or requirements statements).
    /// </summary>
    public class CapabilityStatementRest : BackboneElement
    {
        /// <summary>
        /// At present, the only defined compartments are at [CompartmentDefinition](compartmentdefinition.html).
        /// </summary>
        [JsonProperty("compartment")]
        public string[] Compartment { get; set; }
        [JsonProperty("_compartment")]
        public Element[] _Compartment { get; set; }
        /// <summary>
        /// Information about the system's restful capabilities that apply across all applications, such as security.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// A specification of restful operations supported by the system.
        /// </summary>
        [JsonProperty("interaction")]
        public CapabilityStatementRestInteraction[] Interaction { get; set; }
        /// <summary>
        /// Identifies whether this portion of the statement is describing the ability to initiate or receive restful operations.
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
        /// <summary>
        /// Definition of an operation or a named query together with its parameters and their meaning and type.
        /// </summary>
        [JsonProperty("operation")]
        public CapabilityStatementRestOperation[] Operation { get; set; }
        /// <summary>
        /// Max of one repetition per resource type.
        /// </summary>
        [JsonProperty("resource")]
        public CapabilityStatementRestResource[] Resource { get; set; }
        /// <summary>
        /// Typically, the only search parameters supported for all searchse are those that apply to all resources - tags, profiles, text search etc.
        /// </summary>
        [JsonProperty("searchParam")]
        public CapabilityStatementRestResourceSearchParam[] SearchParam { get; set; }
        /// <summary>
        /// Information about security implementation from an interface perspective - what a client needs to know.
        /// </summary>
        [JsonProperty("security")]
        public CapabilityStatementRestSecurity Security { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.rest.mode field
    /// </summary>
    public static class CapabilityStatementRestModeCodes
    {
        public const string CLIENT = "client";
        public const string SERVER = "server";
    }
    /// <summary>
    /// An endpoint (network accessible address) to which messages and/or replies are to be sent.
    /// </summary>
    public class CapabilityStatementMessagingEndpoint : BackboneElement
    {
        /// <summary>
        /// The network address of the end-point. For solutions that do not use network addresses for routing, it can be just an identifier.
        /// </summary>
        [JsonProperty("address")]
        public string Address { get; set; }
        [JsonProperty("_address")]
        public Element _Address { get; set; }
        /// <summary>
        /// A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
        /// </summary>
        [JsonProperty("protocol")]
        public Coding Protocol { get; set; }
    }
    /// <summary>
    /// This is a proposed alternative to the messaging.event structure.
    /// </summary>
    public class CapabilityStatementMessagingSupportedMessage : BackboneElement
    {
        /// <summary>
        /// Points to a message definition that identifies the messaging event, message structure, allowed responses, etc.
        /// </summary>
        [JsonProperty("definition")]
        public Reference Definition { get; set; }
        /// <summary>
        /// The mode of this event declaration - whether application is sender or receiver.
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.messaging.supportedMessage.mode field
    /// </summary>
    public static class CapabilityStatementMessagingSupportedMessageModeCodes
    {
        public const string SENDER = "sender";
        public const string RECEIVER = "receiver";
    }
    /// <summary>
    /// The same event may be listed up to two times - once as sender and once as receiver.
    /// </summary>
    public class CapabilityStatementMessagingEvent : BackboneElement
    {
        /// <summary>
        /// The impact of the content of the message.
        /// </summary>
        [JsonProperty("category")]
        public string Category { get; set; }
        [JsonProperty("_category")]
        public Element _Category { get; set; }
        /// <summary>
        /// A coded identifier of a supported messaging event.
        /// </summary>
        [JsonProperty("code")]
        public Coding Code { get; set; }
        /// <summary>
        /// Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// This SHALL be provided if the event type supports multiple different resource types.
        /// </summary>
        [JsonProperty("focus")]
        public string Focus { get; set; }
        [JsonProperty("_focus")]
        public Element _Focus { get; set; }
        /// <summary>
        /// The mode of this event declaration - whether an application is a sender or receiver.
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
        /// <summary>
        /// Information about the request for this event.
        /// </summary>
        [JsonProperty("request")]
        public Reference Request { get; set; }
        /// <summary>
        /// Information about the response for this event.
        /// </summary>
        [JsonProperty("response")]
        public Reference Response { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.messaging.event.category field
    /// </summary>
    public static class CapabilityStatementMessagingEventCategoryCodes
    {
        public const string CONSEQUENCE = "Consequence";
        public const string CURRENCY = "Currency";
        public const string NOTIFICATION = "Notification";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.messaging.event.mode field
    /// </summary>
    public static class CapabilityStatementMessagingEventModeCodes
    {
        public const string SENDER = "sender";
        public const string RECEIVER = "receiver";
    }
    /// <summary>
    /// Multiple repetitions allow the documentation of multiple endpoints per solution.
    /// </summary>
    public class CapabilityStatementMessaging : BackboneElement
    {
        /// <summary>
        /// Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the capability statement.  For example, the process for becoming an authorized messaging exchange partner.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// An endpoint (network accessible address) to which messages and/or replies are to be sent.
        /// </summary>
        [JsonProperty("endpoint")]
        public CapabilityStatementMessagingEndpoint[] Endpoint { get; set; }
        /// <summary>
        /// The same event may be listed up to two times - once as sender and once as receiver.
        /// </summary>
        [JsonProperty("event")]
        public CapabilityStatementMessagingEvent[] Event { get; set; }
        /// <summary>
        /// If this value is missing then the application does not implement (receiver) or depend on (sender) reliable messaging.
        /// </summary>
        [JsonProperty("reliableCache")]
        public uint? ReliableCache { get; set; }
        /// <summary>
        /// This is a proposed alternative to the messaging.event structure.
        /// </summary>
        [JsonProperty("supportedMessage")]
        public CapabilityStatementMessagingSupportedMessage[] SupportedMessage { get; set; }
    }
    /// <summary>
    /// A document definition.
    /// </summary>
    public class CapabilityStatementDocument : BackboneElement
    {
        /// <summary>
        /// A description of how the application supports or uses the specified document profile.  For example, when documents are created, what action is taken with consumed documents, etc.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// Mode of this document declaration - whether an application is a producer or consumer.
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
        /// <summary>
        /// The first resource is the document resource.
        /// </summary>
        [JsonProperty("profile")]
        public Reference Profile { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.document.mode field
    /// </summary>
    public static class CapabilityStatementDocumentModeCodes
    {
        public const string PRODUCER = "producer";
        public const string CONSUMER = "consumer";
    }
    /// <summary>
    /// A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
    /// </summary>
    public class CapabilityStatement : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "CapabilityStatement";
        /// <summary>
        /// Unknown elements in a resource can only arise as later versions of the specification are published, because this is the only place where such elements can be defined. Hence accepting unknown elements is about inter-version compatibility.
        /// Applications are recommended to accept unknown extensions and elements ('both'), but this is not always possible.
        /// </summary>
        [JsonProperty("acceptUnknown")]
        public string AcceptUnknown { get; set; }
        [JsonProperty("_acceptUnknown")]
        public Element _AcceptUnknown { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// A copyright statement relating to the capability statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the capability statement.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the capability statement. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the capability statement was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the capability statement as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created). This does not need to be populated if the description is adequately implied by the software or implementation details.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// A document definition.
        /// </summary>
        [JsonProperty("document")]
        public CapabilityStatementDocument[] Document { get; set; }
        /// <summary>
        /// Allows filtering of capability statement that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental capability statement in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// The version of the FHIR specification on which this capability statement is based.
        /// </summary>
        [JsonProperty("fhirVersion")]
        public string FhirVersion { get; set; }
        [JsonProperty("_fhirVersion")]
        public Element _FhirVersion { get; set; }
        /// <summary>
        /// "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
        /// </summary>
        [JsonProperty("format")]
        public string[] Format { get; set; }
        [JsonProperty("_format")]
        public Element[] _Format { get; set; }
        /// <summary>
        /// Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
        /// </summary>
        [JsonProperty("implementation")]
        public CapabilityStatementImplementation Implementation { get; set; }
        /// <summary>
        /// A list of implementation guides that the server does (or should) support in their entirety.
        /// </summary>
        [JsonProperty("implementationGuide")]
        public string[] ImplementationGuide { get; set; }
        [JsonProperty("_implementationGuide")]
        public Element[] _ImplementationGuide { get; set; }
        /// <summary>
        /// HL7 defines the following Services: [Terminology Service](terminology-service.html).
        /// Many [Implementation Guides](http://fhir.org/guides/registry) define additional services.
        /// </summary>
        [JsonProperty("instantiates")]
        public string[] Instantiates { get; set; }
        [JsonProperty("_instantiates")]
        public Element[] _Instantiates { get; set; }
        /// <summary>
        /// It may be possible for the capability statement to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind not instance of software) or a class of implementation (e.g. a desired purchase).
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// Multiple repetitions allow the documentation of multiple endpoints per solution.
        /// </summary>
        [JsonProperty("messaging")]
        public CapabilityStatementMessaging[] Messaging { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// At present, the patch mime types application/json-patch+json and application/xml-patch+xml are legal. Generally, if a server supports PATCH, it would be expected to support the patch formats and match the formats it supports, but this is not always possible or necessary.
        /// </summary>
        [JsonProperty("patchFormat")]
        public string[] PatchFormat { get; set; }
        [JsonProperty("_patchFormat")]
        public Element[] _PatchFormat { get; set; }
        /// <summary>
        /// Supported profiles are different than the profiles that apply to a particular resource in rest.resource.profile. The resource profile is a general statement of what features of the resource are supported overall by the system - the sum total of the facilities it supports. A supported profile is a deeper statement about the functionality of the data and services provided by the server (or used by the client). A typical case is a laboratory system that produces a set of different reports - this is the list of types of data that it publishes. A key aspect of declaring profiles here is the question of how the client converts knowledge that the server publishes this data into working with the data; the client can inspect individual resources to determine whether they conform to a particular profile, but how does it find the ones that does? It does so by searching using the _profile parameter, so any resources listed here must be valid values for the _profile resource (using the identifier in the target profile).  Typically, supported profiles cross resource types to describe a network of related resources, so they are listed here rather than by resource. However, they do not need to describe more than one resource.
        /// </summary>
        [JsonProperty("profile")]
        public Reference[] Profile { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the capability statement is the organization or individual primarily responsible for the maintenance and upkeep of the capability statement. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the capability statement. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the capability statement Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this capability statement.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Multiple repetitions allow definition of both client and/or server behaviors or possibly behaviors under different configuration settings (for software or requirements statements).
        /// </summary>
        [JsonProperty("rest")]
        public CapabilityStatementRest[] Rest { get; set; }
        /// <summary>
        /// Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
        /// </summary>
        [JsonProperty("software")]
        public CapabilityStatementSoftware Software { get; set; }
        /// <summary>
        /// Allows filtering of capability statements that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired capability statement without due consideration. This is not intended for use with actual capability statements, but where capability statements are used to describe possible or desired systems.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different capability statement instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the capability statement with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.acceptUnknown field
    /// </summary>
    public static class CapabilityStatementAcceptUnknownCodes
    {
        public const string NO = "no";
        public const string EXTENSIONS = "extensions";
        public const string ELEMENTS = "elements";
        public const string BOTH = "both";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.format field
    /// </summary>
    public static class CapabilityStatementFormatCodes
    {
        public const string FORMATS = "formats";
        public const string JSON = "json";
        public const string TTL = "ttl";
        public const string MIME = "mime";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.kind field
    /// </summary>
    public static class CapabilityStatementKindCodes
    {
        public const string INSTANCE = "instance";
        public const string CAPABILITY = "capability";
        public const string REQUIREMENTS = "requirements";
    }
    /// <summary>
    /// Code Values for the CapabilityStatement.status field
    /// </summary>
    public static class CapabilityStatementStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// A filter that can be used in a value set compose statement when selecting concepts using a filter.
    /// </summary>
    public class CodeSystemFilter : BackboneElement
    {
        /// <summary>
        /// The code that identifies this filter when it is used in the instance.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// A description of how or why the filter is used.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// A list of operators that can be used with the filter.
        /// </summary>
        [JsonProperty("operator")]
        public string[] Operator { get; set; }
        [JsonProperty("_operator")]
        public Element[] _Operator { get; set; }
        /// <summary>
        /// A description of what the value for the filter should be.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// A property defines an additional slot through which additional information can be provided about a concept.
    /// </summary>
    public class CodeSystemProperty : BackboneElement
    {
        /// <summary>
        /// A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// A description of the property- why it is defined, and how its value might be used.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// The type of the property value. Properties of type "code" contain a code defined by the code system (e.g. a reference to anotherr defined concept).
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
        /// </summary>
        [JsonProperty("uri")]
        public string Uri { get; set; }
        [JsonProperty("_uri")]
        public Element _Uri { get; set; }
    }
    /// <summary>
    /// Code Values for the CodeSystem.property.type field
    /// </summary>
    public static class CodeSystemPropertyTypeCodes
    {
        public const string CODE = "code";
        public const string CODING = "Coding";
        public const string VAL_STRING = "string";
        public const string INTEGER = "integer";
        public const string BOOLEAN = "boolean";
        public const string DATETIME = "dateTime";
    }
    /// <summary>
    /// Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
    /// </summary>
    public class CodeSystemConceptDesignation : BackboneElement
    {
        /// <summary>
        /// In the absence of a language, the resource language applies.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// If no use is provided, the designation can be assumed to be suitable for general display to a human user.
        /// </summary>
        [JsonProperty("use")]
        public Coding Use { get; set; }
        /// <summary>
        /// The text value for this designation.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// A property value for this concept.
    /// </summary>
    public class CodeSystemConceptProperty : BackboneElement
    {
        /// <summary>
        /// A code that is a reference to CodeSystem.property.code.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonProperty("valueCode")]
        public string ValueCode { get; set; }
        [JsonProperty("_valueCode")]
        public Element _ValueCode { get; set; }
        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonProperty("valueCoding")]
        public Coding ValueCoding { get; set; }
        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonProperty("valueInteger")]
        public int ValueInteger { get; set; }
        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool ValueBoolean { get; set; }
        /// <summary>
        /// The value of this property.
        /// </summary>
        [JsonProperty("valueDateTime")]
        public string ValueDateTime { get; set; }
        [JsonProperty("_valueDateTime")]
        public Element _ValueDateTime { get; set; }
    }
    /// <summary>
    /// If this is empty, it means that the code system resource does not represent the content of the code system.
    /// </summary>
    public class CodeSystemConcept : BackboneElement
    {
        /// <summary>
        /// A code - a text symbol - that uniquely identifies the concept within the code system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) - see hierarchyMeaning.
        /// </summary>
        [JsonProperty("concept")]
        public CodeSystemConcept[] Concept { get; set; }
        /// <summary>
        /// The formal definition of the concept. The code system resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
        /// </summary>
        [JsonProperty("definition")]
        public string Definition { get; set; }
        [JsonProperty("_definition")]
        public Element _Definition { get; set; }
        /// <summary>
        /// Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
        /// </summary>
        [JsonProperty("designation")]
        public CodeSystemConceptDesignation[] Designation { get; set; }
        /// <summary>
        /// A human readable string that is the recommended default way to present this concept to a user.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// A property value for this concept.
        /// </summary>
        [JsonProperty("property")]
        public CodeSystemConceptProperty[] Property { get; set; }
    }
    /// <summary>
    /// A code system resource specifies a set of codes drawn from one or more code systems.
    /// </summary>
    public class CodeSystem : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "CodeSystem";
        /// <summary>
        /// If this value is missing, then it is not specified whether a code system is case sensitive or not. When the rule is not known, Postel's law should be followed: produce codes with the correct case, and accept codes in any case. This element is primarily provided to support validation software.
        /// </summary>
        [JsonProperty("caseSensitive")]
        public bool? CaseSensitive { get; set; }
        /// <summary>
        /// Note that the code system resource does not define what the compositional grammar is, only whether or not there is one.
        /// </summary>
        [JsonProperty("compositional")]
        public bool? Compositional { get; set; }
        /// <summary>
        /// If this is empty, it means that the code system resource does not represent the content of the code system.
        /// </summary>
        [JsonProperty("concept")]
        public CodeSystemConcept[] Concept { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// How much of the content of the code system - the concepts and codes it defines - are represented in this resource.
        /// </summary>
        [JsonProperty("content")]
        public string Content { get; set; }
        [JsonProperty("_content")]
        public Element _Content { get; set; }
        /// <summary>
        /// ... Sometimes, the copyright differs between the code system and the codes that are included. The copyright statement should clearly differentiate between these when required.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// The count of concepts defined in this resource cannot be more than this value, but may be less for several reasons - see the content value.
        /// </summary>
        [JsonProperty("count")]
        public uint? Count { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the code system. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the code system was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the code system as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of code system that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental code system in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// A filter that can be used in a value set compose statement when selecting concepts using a filter.
        /// </summary>
        [JsonProperty("filter")]
        public CodeSystemFilter[] Filter { get; set; }
        /// <summary>
        /// The meaning of the hierarchy of concepts.
        /// </summary>
        [JsonProperty("hierarchyMeaning")]
        public string HierarchyMeaning { get; set; }
        [JsonProperty("_hierarchyMeaning")]
        public Element _HierarchyMeaning { get; set; }
        /// <summary>
        /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this code system outside of FHIR, where it is not possible to use the logical URI.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier Identifier { get; set; }
        /// <summary>
        /// It may be possible for the code system to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// A property defines an additional slot through which additional information can be provided about a concept.
        /// </summary>
        [JsonProperty("property")]
        public CodeSystemProperty[] Property { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the code system is the organization or individual primarily responsible for the maintenance and upkeep of the code system. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the code system. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the code system Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this code system.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Allows filtering of code systems that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired code system without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// The definition of the value set SHALL include all codes from this code system, and it SHALL be immutable.
        /// </summary>
        [JsonProperty("valueSet")]
        public string ValueSet { get; set; }
        [JsonProperty("_valueSet")]
        public Element _ValueSet { get; set; }
        /// <summary>
        /// There may be different code system instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the code system with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
        /// <summary>
        /// Best practice is that code systems do not redefine concepts, or that if concepts are redefined, a new code system definition is created. But this is not always possible, so some code systems may be defined as 'versionNeeded'.
        /// </summary>
        [JsonProperty("versionNeeded")]
        public bool? VersionNeeded { get; set; }
    }
    /// <summary>
    /// Code Values for the CodeSystem.content field
    /// </summary>
    public static class CodeSystemContentCodes
    {
        public const string NOT_PRESENT = "not-present";
        public const string EXAMPLE = "example";
        public const string FRAGMENT = "fragment";
        public const string COMPLETE = "complete";
    }
    /// <summary>
    /// Code Values for the CodeSystem.hierarchyMeaning field
    /// </summary>
    public static class CodeSystemHierarchyMeaningCodes
    {
        public const string GROUPED_BY = "grouped-by";
        public const string IS_A = "is-a";
        public const string PART_OF = "part-of";
        public const string CLASSIFIED_WITH = "classified-with";
    }
    /// <summary>
    /// Code Values for the CodeSystem.status field
    /// </summary>
    public static class CodeSystemStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// Information about how a resource is related to the compartment.
    /// </summary>
    public class CompartmentDefinitionResource : BackboneElement
    {
        /// <summary>
        /// The name of a resource supported by the server.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Additional documentation about the resource and compartment.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// If no search parameters are listed, then the resource is not linked to the compartment.
        /// </summary>
        [JsonProperty("param")]
        public string[] Param { get; set; }
        [JsonProperty("_param")]
        public Element[] _Param { get; set; }
    }
    /// <summary>
    /// A compartment definition that defines how resources are accessed on a server.
    /// </summary>
    public class CompartmentDefinition : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "CompartmentDefinition";
        /// <summary>
        /// Only the specification can define the compartments that can exist. Servers can choose to support them.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the compartment definition. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the compartment definition was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the compartment definition as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of compartment definition that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental compartment definition in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// It may be possible for the compartment definition to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly. This is often the same as the code for the parameter, but does not need to be.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the compartment definition is the organization or individual primarily responsible for the maintenance and upkeep of the compartment definition. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the compartment definition. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the compartment definition Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this compartment definition.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Information about how a resource is related to the compartment.
        /// </summary>
        [JsonProperty("resource")]
        public CompartmentDefinitionResource[] Resource { get; set; }
        /// <summary>
        /// Servers may define and use compartments to manage logical access without implementing the compartment related syntax.
        /// </summary>
        [JsonProperty("search")]
        public bool Search { get; set; }
        /// <summary>
        /// Allows filtering of compartment definitions that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired compartment definition without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
    }
    /// <summary>
    /// Code Values for the CompartmentDefinition.code field
    /// </summary>
    public static class CompartmentDefinitionCodeCodes
    {
        public const string PATIENT = "Patient";
        public const string ENCOUNTER = "Encounter";
        public const string RELATEDPERSON = "RelatedPerson";
        public const string PRACTITIONER = "Practitioner";
        public const string DEVICE = "Device";
    }
    /// <summary>
    /// Code Values for the CompartmentDefinition.status field
    /// </summary>
    public static class CompartmentDefinitionStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    /// </summary>
    public class ConceptMapGroupElementTargetDependsOn : BackboneElement
    {
        /// <summary>
        /// Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// The display is ignored when processing the map.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somwhere that is labeled to correspond with a code system property.
        /// </summary>
        [JsonProperty("property")]
        public string Property { get; set; }
        [JsonProperty("_property")]
        public Element _Property { get; set; }
        /// <summary>
        /// An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
    }
    /// <summary>
    /// Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
    /// </summary>
    public class ConceptMapGroupElementTarget : BackboneElement
    {
        /// <summary>
        /// Identity (code or path) or the element/item that the map refers to.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// A description of status/issues in mapping that conveys additional information not represented in  the structured data.
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
        /// </summary>
        [JsonProperty("dependsOn")]
        public ConceptMapGroupElementTargetDependsOn[] DependsOn { get; set; }
        /// <summary>
        /// The display is ignored when processing the map.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// This element is labeled as a modifier because it may indicate that a target does not apply.
        /// </summary>
        [JsonProperty("equivalence")]
        public string Equivalence { get; set; }
        [JsonProperty("_equivalence")]
        public Element _Equivalence { get; set; }
        /// <summary>
        /// A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
        /// </summary>
        [JsonProperty("product")]
        public ConceptMapGroupElementTargetDependsOn[] Product { get; set; }
    }
    /// <summary>
    /// Code Values for the ConceptMap.group.element.target.equivalence field
    /// </summary>
    public static class ConceptMapGroupElementTargetEquivalenceCodes
    {
        public const string RELATEDTO = "relatedto";
        public const string EQUIVALENT = "equivalent";
        public const string EQUAL = "equal";
        public const string WIDER = "wider";
        public const string SUBSUMES = "subsumes";
        public const string NARROWER = "narrower";
        public const string SPECIALIZES = "specializes";
        public const string INEXACT = "inexact";
        public const string UNMATCHED = "unmatched";
        public const string DISJOINT = "disjoint";
    }
    /// <summary>
    /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
    /// </summary>
    public class ConceptMapGroupElement : BackboneElement
    {
        /// <summary>
        /// Identity (code or path) or the element/item being mapped.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// The display is ignored when processing the map.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
        /// </summary>
        [JsonProperty("target")]
        public ConceptMapGroupElementTarget[] Target { get; set; }
    }
    /// <summary>
    /// This only applies if the source code is in the system defined for the group.
    /// </summary>
    public class ConceptMapGroupUnmapped : BackboneElement
    {
        /// <summary>
        /// The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// The display is ignored when processing the map.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// Defines which action to take if there is no match in the group. One of 3 actions is possible: use the unmapped code (this is useful when doing a mapping between versions, and only a few codes have changed), use a fixed code (a default code), or alternatively, a reference to a different concept map can be provided (by canonical URL).
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
        /// <summary>
        /// The canonical URL of the map to use if this map contains no mapping.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
    }
    /// <summary>
    /// Code Values for the ConceptMap.group.unmapped.mode field
    /// </summary>
    public static class ConceptMapGroupUnmappedModeCodes
    {
        public const string PROVIDED = "provided";
        public const string VAL_FIXED = "fixed";
        public const string OTHER_MAP = "other-map";
    }
    /// <summary>
    /// A group of mappings that all have the same source and target system.
    /// </summary>
    public class ConceptMapGroup : BackboneElement
    {
        /// <summary>
        /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
        /// </summary>
        [JsonProperty("element")]
        public ConceptMapGroupElement[] Element { get; set; }
        /// <summary>
        /// An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
        /// </summary>
        [JsonProperty("source")]
        public string Source { get; set; }
        [JsonProperty("_source")]
        public Element _Source { get; set; }
        /// <summary>
        /// The specification of a particular code system version may be required for code systems which lack concept permanence.
        /// </summary>
        [JsonProperty("sourceVersion")]
        public string SourceVersion { get; set; }
        [JsonProperty("_sourceVersion")]
        public Element _SourceVersion { get; set; }
        /// <summary>
        /// Target may be omitted if all the targget element equivalence values are 'unmatched'.
        /// </summary>
        [JsonProperty("target")]
        public string Target { get; set; }
        [JsonProperty("_target")]
        public Element _Target { get; set; }
        /// <summary>
        /// The specification of a particular code system version may be required for code systems which lack concept permanence.
        /// </summary>
        [JsonProperty("targetVersion")]
        public string TargetVersion { get; set; }
        [JsonProperty("_targetVersion")]
        public Element _TargetVersion { get; set; }
        /// <summary>
        /// This only applies if the source code is in the system defined for the group.
        /// </summary>
        [JsonProperty("unmapped")]
        public ConceptMapGroupUnmapped Unmapped { get; set; }
    }
    /// <summary>
    /// A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
    /// </summary>
    public class ConceptMap : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "ConceptMap";
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// null Frequently, the copyright differs between the concept map, and codes that are included. The copyright statement should clearly differentiate between these when required.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the concept map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// The description is not intended to describe the semantics of the concept map. The description should capture its intended use, which is needed for ensuring integrity for its use in models across future changes.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of concept map that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental concept map in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// A group of mappings that all have the same source and target system.
        /// </summary>
        [JsonProperty("group")]
        public ConceptMapGroup[] Group { get; set; }
        /// <summary>
        /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this concept map outside of FHIR, where it is not possible to use the logical URI.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier Identifier { get; set; }
        /// <summary>
        /// It may be possible for the concept map to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the concept map is the organization or individual primarily responsible for the maintenance and upkeep of the concept map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the concept map. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the concept map Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this concept map.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
        /// </summary>
        [JsonProperty("sourceUri")]
        public string SourceUri { get; set; }
        [JsonProperty("_sourceUri")]
        public Element _SourceUri { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
        /// </summary>
        [JsonProperty("sourceReference")]
        public Reference SourceReference { get; set; }
        /// <summary>
        /// Allows filtering of concept maps that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired concept map without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
        /// </summary>
        [JsonProperty("targetUri")]
        public string TargetUri { get; set; }
        [JsonProperty("_targetUri")]
        public Element _TargetUri { get; set; }
        /// <summary>
        /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
        /// </summary>
        [JsonProperty("targetReference")]
        public Reference TargetReference { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different concept map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the concept map with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the ConceptMap.status field
    /// </summary>
    public static class ConceptMapStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// A resource that includes narrative, extensions, and contained resources.
    /// </summary>
    public class DomainResource : Resource
    {
        /// <summary>
        /// This should never be done when the content can be identified properly, as once identification is lost, it is extremely difficult (and context dependent) to restore it again.
        /// </summary>
        [JsonProperty("contained")]
        public Resource[] Contained { get; set; }
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("extension")]
        public Extension[] Extension { get; set; }
        /// <summary>
        /// There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
        /// </summary>
        [JsonProperty("modifierExtension")]
        public Extension[] ModifierExtension { get; set; }
        /// <summary>
        /// Contained resources do not have narrative. Resources that are not contained SHOULD have a narrative. In some cases, a resource may only have text with little or no additional discrete data (as long as all minOccurs=1 elements are satisfied).  This may be necessary for data from legacy systems where information is captured as a "text blob" or where text is additionally entered raw or narrated and encoded in formation is added later.
        /// </summary>
        [JsonProperty("text")]
        public Narrative Text { get; set; }
    }
    /// <summary>
    /// Multiple identifiers may exist, either due to duplicate registration, regional rules, needs of different communication technologies, etc.
    /// </summary>
    public class NamingSystemUniqueId : BackboneElement
    {
        /// <summary>
        /// e.g. "must be used in Germany" or "was initially published in error with this value".
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// Within a registry, a given identifier should only be "active" for a single namespace at a time.  (Ideally, an identifier should only ever be associated with a single namespace across all time).
        /// </summary>
        [JsonProperty("period")]
        public Period Period { get; set; }
        /// <summary>
        /// Indicates whether this identifier is the "preferred" identifier of this type.
        /// </summary>
        [JsonProperty("preferred")]
        public bool? Preferred { get; set; }
        /// <summary>
        /// Different identifier types may be used in different types of communications (OIDs for v3, URIs for FHIR, etc.).  Other includes RUIDs from v3, standard v2 code name strings, etc.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// If the value is a URI intended for use as FHIR system identifier, the URI should not contain "\" or "?" or "," since this makes escaping very difficult.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the NamingSystem.uniqueId.type field
    /// </summary>
    public static class NamingSystemUniqueIdTypeCodes
    {
        public const string OID = "oid";
        public const string UUID = "uuid";
        public const string URI = "uri";
        public const string OTHER = "other";
    }
    /// <summary>
    /// A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
    /// </summary>
    public class NamingSystem : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "NamingSystem";
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the naming system. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the naming system was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the naming system as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// It may be possible for the naming system to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// Indicates the purpose for the naming system - what kinds of things does it make unique?
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly. The"symbolic name" for an OID would be captured as an extension.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the naming system is the organization or individual primarily responsible for the maintenance and upkeep of the naming system. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the naming system. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// For naming systems that are retired, indicates the naming system that should be used in their place (if any).
        /// </summary>
        [JsonProperty("replacedBy")]
        public Reference ReplacedBy { get; set; }
        /// <summary>
        /// This is the primary organization.  Responsibility for some aspects of a namespace may be delegated.
        /// </summary>
        [JsonProperty("responsible")]
        public string Responsible { get; set; }
        [JsonProperty("_responsible")]
        public Element _Responsible { get; set; }
        /// <summary>
        /// Allows filtering of naming systems that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired naming system without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This will most commonly be used for identifier namespaces, but categories could potentially be useful for code systems and authorities as well.
        /// </summary>
        [JsonProperty("type")]
        public CodeableConcept Type { get; set; }
        /// <summary>
        /// Multiple identifiers may exist, either due to duplicate registration, regional rules, needs of different communication technologies, etc.
        /// </summary>
        [JsonProperty("uniqueId")]
        public NamingSystemUniqueId[] UniqueId { get; set; }
        /// <summary>
        /// Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
        /// </summary>
        [JsonProperty("usage")]
        public string Usage { get; set; }
        [JsonProperty("_usage")]
        public Element _Usage { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
    }
    /// <summary>
    /// Code Values for the NamingSystem.kind field
    /// </summary>
    public static class NamingSystemKindCodes
    {
        public const string CODESYSTEM = "codesystem";
        public const string IDENTIFIER = "identifier";
        public const string ROOT = "root";
    }
    /// <summary>
    /// Code Values for the NamingSystem.status field
    /// </summary>
    public static class NamingSystemStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
    /// </summary>
    public class OperationDefinitionParameterBinding : BackboneElement
    {
        /// <summary>
        /// For further discussion, see [Using Terminologies](terminologies.html).
        /// </summary>
        [JsonProperty("strength")]
        public string Strength { get; set; }
        [JsonProperty("_strength")]
        public Element _Strength { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetUri")]
        public string ValueSetUri { get; set; }
        [JsonProperty("_valueSetUri")]
        public Element _ValueSetUri { get; set; }
        /// <summary>
        /// For value sets with a referenceResource, the display can contain the value set description.  The reference may be version-specific or not.
        /// </summary>
        [JsonProperty("valueSetReference")]
        public Reference ValueSetReference { get; set; }
    }
    /// <summary>
    /// Code Values for the OperationDefinition.parameter.binding.strength field
    /// </summary>
    public static class OperationDefinitionParameterBindingStrengthCodes
    {
        public const string REQUIRED = "required";
        public const string EXTENSIBLE = "extensible";
        public const string PREFERRED = "preferred";
        public const string EXAMPLE = "example";
    }
    /// <summary>
    /// Query Definitions only have one output parameter, named "result". This may not be described, but can be to allow a profile to be defined.
    /// </summary>
    public class OperationDefinitionParameter : BackboneElement
    {
        /// <summary>
        /// Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
        /// </summary>
        [JsonProperty("binding")]
        public OperationDefinitionParameterBinding Binding { get; set; }
        /// <summary>
        /// Describes the meaning or use of this parameter.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// The maximum number of times this element is permitted to appear in the request or response.
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// The minimum number of times this parameter SHALL appear in the request or response.
        /// </summary>
        [JsonProperty("min")]
        public int Min { get; set; }
        /// <summary>
        /// This name must be a token (start with a letter in a..z, and only contain letters, numerals, and underscore. Note that for search parameters (type = string, with a search type), the name may be altered by the search modifiers.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Query Definitions only have one output parameter, named "result". This may not be described, but can be to allow a profile to be defined.
        /// </summary>
        [JsonProperty("part")]
        public OperationDefinitionParameter[] Part { get; set; }
        /// <summary>
        /// A profile the specifies the rules that this parameter must conform to.
        /// </summary>
        [JsonProperty("profile")]
        public Reference Profile { get; set; }
        /// <summary>
        /// How the parameter is understood as a search parameter. This is only used if the parameter type is 'string'.
        /// </summary>
        [JsonProperty("searchType")]
        public string SearchType { get; set; }
        [JsonProperty("_searchType")]
        public Element _SearchType { get; set; }
        /// <summary>
        /// if there is no stated parameter, then the parameter is a multi-part parameter; type and must have at least one part defined.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// If a parameter name is used for both an input and an output parameter, the parameter should be defined twice.
        /// </summary>
        [JsonProperty("use")]
        public string Use { get; set; }
        [JsonProperty("_use")]
        public Element _Use { get; set; }
    }
    /// <summary>
    /// Code Values for the OperationDefinition.parameter.searchType field
    /// </summary>
    public static class OperationDefinitionParameterSearchTypeCodes
    {
        public const string NUMBER = "number";
        public const string DATE = "date";
        public const string VAL_STRING = "string";
        public const string TOKEN = "token";
        public const string REFERENCE = "reference";
        public const string COMPOSITE = "composite";
        public const string QUANTITY = "quantity";
        public const string URI = "uri";
    }
    /// <summary>
    /// Code Values for the OperationDefinition.parameter.use field
    /// </summary>
    public static class OperationDefinitionParameterUseCodes
    {
        public const string VAL_IN = "in";
        public const string VAL_OUT = "out";
    }
    /// <summary>
    /// The combinations are suggestions as to which sets of parameters to use together, but the combinations are not intended to be authoritative.
    /// </summary>
    public class OperationDefinitionOverload : BackboneElement
    {
        /// <summary>
        /// Comments to go on overload.
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// Name of parameter to include in overload.
        /// </summary>
        [JsonProperty("parameterName")]
        public string[] ParameterName { get; set; }
        [JsonProperty("_parameterName")]
        public Element[] _ParameterName { get; set; }
    }
    /// <summary>
    /// A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
    /// </summary>
    public class OperationDefinition : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "OperationDefinition";
        /// <summary>
        /// A constrained profile can make optional parameters required or not used and clarify documentation.
        /// </summary>
        [JsonProperty("base")]
        public Reference Base { get; set; }
        /// <summary>
        /// The code does not include the '$' prefix that is always included in the URL when the operation is invoked.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Additional information about how to use this operation or named query.
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the operation definition. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the operation definition was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the operation definition as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of operation definition that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental operation definition in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Operations that are idempotent (see [HTTP specification definition of idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) may be invoked by performing an HTTP GET operation instead of a POST.
        /// </summary>
        [JsonProperty("idempotent")]
        public bool? Idempotent { get; set; }
        /// <summary>
        /// Indicates whether this operation can be invoked on a particular instance of one of the given types.
        /// </summary>
        [JsonProperty("instance")]
        public bool Instance { get; set; }
        /// <summary>
        /// It may be possible for the operation definition to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// Named queries are invoked differently, and have different capabilities.
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// The combinations are suggestions as to which sets of parameters to use together, but the combinations are not intended to be authoritative.
        /// </summary>
        [JsonProperty("overload")]
        public OperationDefinitionOverload[] Overload { get; set; }
        /// <summary>
        /// Query Definitions only have one output parameter, named "result". This may not be described, but can be to allow a profile to be defined.
        /// </summary>
        [JsonProperty("parameter")]
        public OperationDefinitionParameter[] Parameter { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the operation definition is the organization or individual primarily responsible for the maintenance and upkeep of the operation definition. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the operation definition. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the operation definition Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this operation definition.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// If the type is an abstract resource ("Resource" or "DomainResource") then the operation can be invoked on any concrete specialization.
        /// </summary>
        [JsonProperty("resource")]
        public string[] Resource { get; set; }
        [JsonProperty("_resource")]
        public Element[] _Resource { get; set; }
        /// <summary>
        /// Allows filtering of operation definitions that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired operation definition without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
        /// </summary>
        [JsonProperty("system")]
        public bool System { get; set; }
        /// <summary>
        /// Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a specific resource id for the context).
        /// </summary>
        [JsonProperty("type")]
        public bool Type { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different operation definition instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the operation definition with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the OperationDefinition.kind field
    /// </summary>
    public static class OperationDefinitionKindCodes
    {
        public const string OPERATION = "operation";
        public const string QUERY = "query";
    }
    /// <summary>
    /// Code Values for the OperationDefinition.status field
    /// </summary>
    public static class OperationDefinitionStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// This is the base resource type for everything.
    /// </summary>
    public class Resource
    {
        /// <summary>
        /// The only time that a resource does not have an id is when it is being submitted to the server using a create operation.
        /// </summary>
        [JsonProperty("id")]
        public string Id { get; set; }
        [JsonProperty("_id")]
        public Element _Id { get; set; }
        /// <summary>
        /// Asserting this rule set restricts the content to be only understood by a limited set of trading partners. This inherently limits the usefulness of the data in the long term. However, the existing health eco-system is highly fractured, and not yet ready to define, collect, and exchange data in a generally computable sense. Wherever possible, implementers and/or specification writers should avoid using this element. 
        /// This element is labelled as a modifier because the implicit rules may provide additional knowledge about the resource that modifies it's meaning or interpretation.
        /// </summary>
        [JsonProperty("implicitRules")]
        public string ImplicitRules { get; set; }
        [JsonProperty("_implicitRules")]
        public Element _ImplicitRules { get; set; }
        /// <summary>
        /// Language is provided to support indexing and accessibility (typically, services such as text to speech use the language tag). The html language tag in the narrative applies  to the narrative. The language tag on the resource may be used to specify the language of other presentations generated from the data in the resource  Not all the content has to be in the base language. The Resource.language should not be assumed to apply to the narrative automatically. If a language is specified, it should it also be specified on the div element in the html (see rules in HTML5 for information about the relationship between xml:lang and the html lang attribute).
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource.
        /// </summary>
        [JsonProperty("meta")]
        public Meta Meta { get; set; }
    }
    /// <summary>
    /// Used to define the parts of a composite search parameter.
    /// </summary>
    public class SearchParameterComponent : BackboneElement
    {
        /// <summary>
        /// The definition of the search parameter that describes this part.
        /// </summary>
        [JsonProperty("definition")]
        public Reference Definition { get; set; }
        /// <summary>
        /// This expression overrides the expression in the definition, and extracts the index values from the outcome of the composite expression.
        /// </summary>
        [JsonProperty("expression")]
        public string Expression { get; set; }
        [JsonProperty("_expression")]
        public Element _Expression { get; set; }
    }
    /// <summary>
    /// A search parameter that defines a named search item that can be used to search/filter on a resource.
    /// </summary>
    public class SearchParameter : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "SearchParameter";
        /// <summary>
        /// A search parameter must always have at least one type. When search parameters have more than one resource, they can be used against any of the listed resource types, or in a cross-type search (see [Cross Resource Search](http.html#xres-search)).
        /// </summary>
        [JsonProperty("base")]
        public string[] Base { get; set; }
        [JsonProperty("_base")]
        public Element[] _Base { get; set; }
        /// <summary>
        /// Systems are not required to list all the chain names they support, but if they don't list them, clients may not know to use them.
        /// </summary>
        [JsonProperty("chain")]
        public string[] Chain { get; set; }
        [JsonProperty("_chain")]
        public Element[] _Chain { get; set; }
        /// <summary>
        /// For maximum compatibility, use only lowercase ASCII characters.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// If no comparators are listed, clients should not expect servers to support any comparators.
        /// </summary>
        [JsonProperty("comparator")]
        public string[] Comparator { get; set; }
        [JsonProperty("_comparator")]
        public Element[] _Comparator { get; set; }
        /// <summary>
        /// Used to define the parts of a composite search parameter.
        /// </summary>
        [JsonProperty("component")]
        public SearchParameterComponent[] Component { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the search parameter. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// The intent of this is that a server can designate that it provides support for a search parameter defined in the specification itself (e.g.  [`value-quantity`](http://hl7.org/fhir/SearchParameter/Observation-value-quantity), but detail how it is supported by the server.
        /// </summary>
        [JsonProperty("derivedFrom")]
        public string DerivedFrom { get; set; }
        [JsonProperty("_derivedFrom")]
        public Element _DerivedFrom { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the search parameter was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the search parameter as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of search parameter that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental search parameter in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Note that the elements returned by the expression are sometimes complex elements where logic is required to determine quite how to handle them; e.g. CodeableConcepts may contain text and/or multiple codings, where the codings themselves contain a code and a system. For composite search parameters, the outcome of the expression must a collection of base elements from which the composites are derived.
        /// </summary>
        [JsonProperty("expression")]
        public string Expression { get; set; }
        [JsonProperty("_expression")]
        public Element _Expression { get; set; }
        /// <summary>
        /// It may be possible for the search parameter to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// A modifier supported for the search parameter.
        /// </summary>
        [JsonProperty("modifier")]
        public string[] Modifier { get; set; }
        [JsonProperty("_modifier")]
        public Element[] _Modifier { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the search parameter is the organization or individual primarily responsible for the maintenance and upkeep of the search parameter. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the search parameter. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the search parameter Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this search parameter.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Allows filtering of search parameters that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired search parameter without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// Types of resource (if a resource is referenced).
        /// </summary>
        [JsonProperty("target")]
        public string[] Target { get; set; }
        [JsonProperty("_target")]
        public Element[] _Target { get; set; }
        /// <summary>
        /// The type of value a search parameter refers to, and how the content is interpreted.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different search parameter instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the search parameter with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
        /// <summary>
        /// Note that the elements returned by the XPath are sometimes complex elements where logic is required to determine quite how to handle them; e.g. CodeableConcepts may contain text and/or multiple codings, where the codings themselves contain a code and a system.
        /// </summary>
        [JsonProperty("xpath")]
        public string Xpath { get; set; }
        [JsonProperty("_xpath")]
        public Element _Xpath { get; set; }
        /// <summary>
        /// How the search parameter relates to the set of elements returned by evaluating the xpath query.
        /// </summary>
        [JsonProperty("xpathUsage")]
        public string XpathUsage { get; set; }
        [JsonProperty("_xpathUsage")]
        public Element _XpathUsage { get; set; }
    }
    /// <summary>
    /// Code Values for the SearchParameter.comparator field
    /// </summary>
    public static class SearchParameterComparatorCodes
    {
        public const string EQ = "eq";
        public const string NE = "ne";
        public const string GT = "gt";
        public const string LT = "lt";
        public const string GE = "ge";
        public const string LE = "le";
        public const string SA = "sa";
        public const string EB = "eb";
        public const string AP = "ap";
    }
    /// <summary>
    /// Code Values for the SearchParameter.modifier field
    /// </summary>
    public static class SearchParameterModifierCodes
    {
        public const string MISSING = "missing";
        public const string EXACT = "exact";
        public const string CONTAINS = "contains";
        public const string NOT = "not";
        public const string TEXT = "text";
        public const string VAL_IN = "in";
        public const string NOT_IN = "not-in";
        public const string BELOW = "below";
        public const string ABOVE = "above";
        public const string TYPE = "type";
    }
    /// <summary>
    /// Code Values for the SearchParameter.status field
    /// </summary>
    public static class SearchParameterStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// Code Values for the SearchParameter.type field
    /// </summary>
    public static class SearchParameterTypeCodes
    {
        public const string NUMBER = "number";
        public const string DATE = "date";
        public const string VAL_STRING = "string";
        public const string TOKEN = "token";
        public const string REFERENCE = "reference";
        public const string COMPOSITE = "composite";
        public const string QUANTITY = "quantity";
        public const string URI = "uri";
    }
    /// <summary>
    /// Code Values for the SearchParameter.xpathUsage field
    /// </summary>
    public static class SearchParameterXpathUsageCodes
    {
        public const string NORMAL = "normal";
        public const string PHONETIC = "phonetic";
        public const string NEARBY = "nearby";
        public const string DISTANCE = "distance";
        public const string OTHER = "other";
    }
    /// <summary>
    /// An external specification that the content is mapped to.
    /// </summary>
    public class StructureDefinitionMapping : BackboneElement
    {
        /// <summary>
        /// Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
        /// </summary>
        [JsonProperty("comment")]
        public string Comment { get; set; }
        [JsonProperty("_comment")]
        public Element _Comment { get; set; }
        /// <summary>
        /// The specification is described once, with general comments, and then specific mappings are made that reference this declaration.
        /// </summary>
        [JsonProperty("identity")]
        public string Identity { get; set; }
        [JsonProperty("_identity")]
        public Element _Identity { get; set; }
        /// <summary>
        /// A name for the specification that is being mapped to.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// A formal identity for the specification being mapped to helps with identifying maps consistently.
        /// </summary>
        [JsonProperty("uri")]
        public string Uri { get; set; }
        [JsonProperty("_uri")]
        public Element _Uri { get; set; }
    }
    /// <summary>
    /// A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
    /// </summary>
    public class StructureDefinitionSnapshot : BackboneElement
    {
        /// <summary>
        /// Captures constraints on each element within the resource.
        /// </summary>
        [JsonProperty("element")]
        public ElementDefinition[] Element { get; set; }
    }
    /// <summary>
    /// A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
    /// </summary>
    public class StructureDefinitionDifferential : BackboneElement
    {
        /// <summary>
        /// Captures constraints on each element within the resource.
        /// </summary>
        [JsonProperty("element")]
        public ElementDefinition[] Element { get; set; }
    }
    /// <summary>
    /// A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
    /// </summary>
    public class StructureDefinition : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "StructureDefinition";
        /// <summary>
        /// Abstract Resources cannot be instantiated - a concrete sub-type must be used. Abstract datatypes and extensions cannot be used in an instance. For logical models, the exact implication of "abstract" will rest with the author, depending how the logical model is used. Flagging a constraint structure as abstract conveys design intent but makes no difference to how the structure definition is handled. Note that inline declared elements that are given the type "Element" in the profile, but have children described, are anonymous concrete types that specialise Element.
        /// </summary>
        [JsonProperty("abstract")]
        public bool Abstract { get; set; }
        /// <summary>
        /// If differential constraints are specified in this structure, they are applied to the base in a "differential" fashion. If there is no base, then the differential constraints cannot be provided (snapshot only). Differential structures are useful for the editing perspective, and snapshot structures are suitable for operational use. The FHIR Project provides a number of tools/services to populate snapshots from differential constraints. Logical Models have a base of "Element" or another logical model.
        /// </summary>
        [JsonProperty("baseDefinition")]
        public string BaseDefinition { get; set; }
        [JsonProperty("_baseDefinition")]
        public Element _BaseDefinition { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// If the context is an element that can have multiple types, then use (e.g.) value[x] if the extension works on all choice types, or otherwise an enumeration of explicitly named elements if not. Note that a context of "string" doesn't mean that the extension can be used with one of the string patterns such as "id" etc.
        /// </summary>
        [JsonProperty("context")]
        public string[] Context { get; set; }
        [JsonProperty("_context")]
        public Element[] _Context { get; set; }
        /// <summary>
        /// All the rules must be true. When evaluating the invariant, the fluentpath focus is the element that holds the extension, and %extension refers to the extension itself.
        /// </summary>
        [JsonProperty("contextInvariant")]
        public string[] ContextInvariant { get; set; }
        [JsonProperty("_contextInvariant")]
        public Element[] _ContextInvariant { get; set; }
        /// <summary>
        /// If this is an extension, Identifies the context within FHIR resources where the extension can be used.
        /// </summary>
        [JsonProperty("contextType")]
        public string ContextType { get; set; }
        [JsonProperty("_contextType")]
        public Element _ContextType { get; set; }
        /// <summary>
        /// A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure definition.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the structure definition. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// If the definition is a specialization, then it adds new elements in the differential, and the snapshot includes the inherited elements.
        /// If the definition is a constraint, then it can not define new elements, it can only make new rules about existing content (see [Profiling Resources](profiling.html#resources)).
        /// </summary>
        [JsonProperty("derivation")]
        public string Derivation { get; set; }
        [JsonProperty("_derivation")]
        public Element _Derivation { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the structure definition was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the structure definition as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
        /// </summary>
        [JsonProperty("differential")]
        public StructureDefinitionDifferential Differential { get; set; }
        /// <summary>
        /// Allows filtering of structure definition that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental structure definition in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// A StructureDefinition does not need to specify the target it applies to,as StructureDefinitions will often be valid across multiple versions of FHIR. FHIR tooling can determine whether a StructureDefinition is consistent with a particular StructureDefinition if desired.
        /// </summary>
        [JsonProperty("fhirVersion")]
        public string FhirVersion { get; set; }
        [JsonProperty("_fhirVersion")]
        public Element _FhirVersion { get; set; }
        /// <summary>
        /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this structure definition outside of FHIR, where it is not possible to use the logical URI.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier[] Identifier { get; set; }
        /// <summary>
        /// It may be possible for the structure definition to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// A set of key words or terms from external terminologies that may be used to assist with indexing and searching of templates.
        /// </summary>
        [JsonProperty("keyword")]
        public Coding[] Keyword { get; set; }
        /// <summary>
        /// Defines the kind of structure that this definition is describing.
        /// </summary>
        [JsonProperty("kind")]
        public string Kind { get; set; }
        [JsonProperty("_kind")]
        public Element _Kind { get; set; }
        /// <summary>
        /// An external specification that the content is mapped to.
        /// </summary>
        [JsonProperty("mapping")]
        public StructureDefinitionMapping[] Mapping { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the structure definition is the organization or individual primarily responsible for the maintenance and upkeep of the structure definition. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the structure definition. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the structure definition Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this structure definition.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
        /// </summary>
        [JsonProperty("snapshot")]
        public StructureDefinitionSnapshot Snapshot { get; set; }
        /// <summary>
        /// Allows filtering of structure definitions that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired structure definition without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc. Applications don't have to use this name, but can always fall back to it. The title also corresponds to the label for the root element.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Note that in the case of constraints, the type could be determined by chasing through the baseDefinition references until a concrete structure (derivation = specialization) is reached, or by looking at the path of the first element in the snapshot - if present - but providing the type directly makes for simpler tooling and indexing.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different structure definition instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the structure definition with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureDefinition.contextType field
    /// </summary>
    public static class StructureDefinitionContextTypeCodes
    {
        public const string RESOURCE = "resource";
        public const string DATATYPE = "datatype";
        public const string EXTENSION = "extension";
    }
    /// <summary>
    /// Code Values for the StructureDefinition.derivation field
    /// </summary>
    public static class StructureDefinitionDerivationCodes
    {
        public const string SPECIALIZATION = "specialization";
        public const string CONSTRAINT = "constraint";
    }
    /// <summary>
    /// Code Values for the StructureDefinition.kind field
    /// </summary>
    public static class StructureDefinitionKindCodes
    {
        public const string PRIMITIVE_TYPE = "primitive-type";
        public const string COMPLEX_TYPE = "complex-type";
        public const string RESOURCE = "resource";
        public const string LOGICAL = "logical";
    }
    /// <summary>
    /// Code Values for the StructureDefinition.status field
    /// </summary>
    public static class StructureDefinitionStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// It is not necessary for a structure map to identify any dependent structures, though not losting them may restrict its usefulness.
    /// </summary>
    public class StructureMapStructure : BackboneElement
    {
        /// <summary>
        /// This is needed if both types have the same name (e.g. version conversion).
        /// </summary>
        [JsonProperty("alias")]
        public string Alias { get; set; }
        [JsonProperty("_alias")]
        public Element _Alias { get; set; }
        /// <summary>
        /// Documentation that describes how the structure is used in the mapping.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// How the referenced structure is used in this mapping.
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
        /// <summary>
        /// The canonical URL that identifies the structure.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureMap.structure.mode field
    /// </summary>
    public static class StructureMapStructureModeCodes
    {
        public const string SOURCE = "source";
        public const string QUERIED = "queried";
        public const string TARGET = "target";
        public const string PRODUCED = "produced";
    }
    /// <summary>
    /// If no inputs are named, then the entry mappings are type based.
    /// </summary>
    public class StructureMapGroupInput : BackboneElement
    {
        /// <summary>
        /// Documentation for this instance of data.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// Mode for this instance of data.
        /// </summary>
        [JsonProperty("mode")]
        public string Mode { get; set; }
        [JsonProperty("_mode")]
        public Element _Mode { get; set; }
        /// <summary>
        /// Name for this instance of data.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Type for this instance of data.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureMap.group.input.mode field
    /// </summary>
    public static class StructureMapGroupInputModeCodes
    {
        public const string SOURCE = "source";
        public const string TARGET = "target";
    }
    /// <summary>
    /// Source inputs to the mapping.
    /// </summary>
    public class StructureMapGroupRuleSource : BackboneElement
    {
        /// <summary>
        /// FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
        /// </summary>
        [JsonProperty("check")]
        public string Check { get; set; }
        [JsonProperty("_check")]
        public Element _Check { get; set; }
        /// <summary>
        /// FHIRPath expression  - must be true or the rule does not apply.
        /// </summary>
        [JsonProperty("condition")]
        public string Condition { get; set; }
        [JsonProperty("_condition")]
        public Element _Condition { get; set; }
        /// <summary>
        /// Type or variable this rule applies to.
        /// </summary>
        [JsonProperty("context")]
        public string Context { get; set; }
        [JsonProperty("_context")]
        public Element _Context { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueBase64Binary")]
        public string DefaultValueBase64Binary { get; set; }
        [JsonProperty("_defaultValueBase64Binary")]
        public Element _DefaultValueBase64Binary { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueBoolean")]
        public bool? DefaultValueBoolean { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueCode")]
        public string DefaultValueCode { get; set; }
        [JsonProperty("_defaultValueCode")]
        public Element _DefaultValueCode { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueDate")]
        public string DefaultValueDate { get; set; }
        [JsonProperty("_defaultValueDate")]
        public Element _DefaultValueDate { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueDateTime")]
        public string DefaultValueDateTime { get; set; }
        [JsonProperty("_defaultValueDateTime")]
        public Element _DefaultValueDateTime { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueDecimal")]
        public decimal? DefaultValueDecimal { get; set; }
        [JsonProperty("_defaultValueDecimal")]
        public Element _DefaultValueDecimal { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueId")]
        public string DefaultValueId { get; set; }
        [JsonProperty("_defaultValueId")]
        public Element _DefaultValueId { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueInstant")]
        public string DefaultValueInstant { get; set; }
        [JsonProperty("_defaultValueInstant")]
        public Element _DefaultValueInstant { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueInteger")]
        public int? DefaultValueInteger { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueMarkdown")]
        public string DefaultValueMarkdown { get; set; }
        [JsonProperty("_defaultValueMarkdown")]
        public Element _DefaultValueMarkdown { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueOid")]
        public string DefaultValueOid { get; set; }
        [JsonProperty("_defaultValueOid")]
        public Element _DefaultValueOid { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValuePositiveInt")]
        public uint? DefaultValuePositiveInt { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueString")]
        public string DefaultValueString { get; set; }
        [JsonProperty("_defaultValueString")]
        public Element _DefaultValueString { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueTime")]
        public string DefaultValueTime { get; set; }
        [JsonProperty("_defaultValueTime")]
        public Element _DefaultValueTime { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueUnsignedInt")]
        public uint? DefaultValueUnsignedInt { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueUri")]
        public string DefaultValueUri { get; set; }
        [JsonProperty("_defaultValueUri")]
        public Element _DefaultValueUri { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueAddress")]
        public Address DefaultValueAddress { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueAge")]
        public Age DefaultValueAge { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueAnnotation")]
        public Annotation DefaultValueAnnotation { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueAttachment")]
        public Attachment DefaultValueAttachment { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueCodeableConcept")]
        public CodeableConcept DefaultValueCodeableConcept { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueCoding")]
        public Coding DefaultValueCoding { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueContactPoint")]
        public ContactPoint DefaultValueContactPoint { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueCount")]
        public Count DefaultValueCount { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueDistance")]
        public Distance DefaultValueDistance { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueDuration")]
        public Duration DefaultValueDuration { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueHumanName")]
        public HumanName DefaultValueHumanName { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueIdentifier")]
        public Identifier DefaultValueIdentifier { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueMoney")]
        public Money DefaultValueMoney { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValuePeriod")]
        public Period DefaultValuePeriod { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueQuantity")]
        public Quantity DefaultValueQuantity { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueRange")]
        public Range DefaultValueRange { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueRatio")]
        public Ratio DefaultValueRatio { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueReference")]
        public Reference DefaultValueReference { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueSampledData")]
        public SampledData DefaultValueSampledData { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueSignature")]
        public Signature DefaultValueSignature { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueTiming")]
        public Timing DefaultValueTiming { get; set; }
        /// <summary>
        /// If there's a default value on an item that can repeat, it will only be used once.
        /// </summary>
        [JsonProperty("defaultValueMeta")]
        public Meta DefaultValueMeta { get; set; }
        /// <summary>
        /// Optional field for this source.
        /// </summary>
        [JsonProperty("element")]
        public string Element { get; set; }
        [JsonProperty("_element")]
        public Element _Element { get; set; }
        /// <summary>
        /// How to handle the list mode for this element.
        /// </summary>
        [JsonProperty("listMode")]
        public string ListMode { get; set; }
        [JsonProperty("_listMode")]
        public Element _ListMode { get; set; }
        /// <summary>
        /// Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
        /// </summary>
        [JsonProperty("max")]
        public string Max { get; set; }
        [JsonProperty("_max")]
        public Element _Max { get; set; }
        /// <summary>
        /// Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
        /// </summary>
        [JsonProperty("min")]
        public int? Min { get; set; }
        /// <summary>
        /// Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
        /// </summary>
        [JsonProperty("type")]
        public string Type { get; set; }
        [JsonProperty("_type")]
        public Element _Type { get; set; }
        /// <summary>
        /// Named context for field, if a field is specified.
        /// </summary>
        [JsonProperty("variable")]
        public string Variable { get; set; }
        [JsonProperty("_variable")]
        public Element _Variable { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureMap.group.rule.source.listMode field
    /// </summary>
    public static class StructureMapGroupRuleSourceListModeCodes
    {
        public const string FIRST = "first";
        public const string NOT_FIRST = "not_first";
        public const string LAST = "last";
        public const string NOT_LAST = "not_last";
        public const string ONLY_ONE = "only_one";
    }
    /// <summary>
    /// Parameters to the transform.
    /// </summary>
    public class StructureMapGroupRuleTargetParameter : BackboneElement
    {
        /// <summary>
        /// Parameter value - variable or literal.
        /// </summary>
        [JsonProperty("valueId")]
        public string ValueId { get; set; }
        [JsonProperty("_valueId")]
        public Element _ValueId { get; set; }
        /// <summary>
        /// Parameter value - variable or literal.
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// Parameter value - variable or literal.
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool ValueBoolean { get; set; }
        /// <summary>
        /// Parameter value - variable or literal.
        /// </summary>
        [JsonProperty("valueInteger")]
        public int ValueInteger { get; set; }
        /// <summary>
        /// Parameter value - variable or literal.
        /// </summary>
        [JsonProperty("valueDecimal")]
        public decimal ValueDecimal { get; set; }
        [JsonProperty("_valueDecimal")]
        public Element _ValueDecimal { get; set; }
    }
    /// <summary>
    /// Content to create because of this mapping rule.
    /// </summary>
    public class StructureMapGroupRuleTarget : BackboneElement
    {
        /// <summary>
        /// Type or variable this rule applies to.
        /// </summary>
        [JsonProperty("context")]
        public string Context { get; set; }
        [JsonProperty("_context")]
        public Element _Context { get; set; }
        /// <summary>
        /// How to interpret the context.
        /// </summary>
        [JsonProperty("contextType")]
        public string ContextType { get; set; }
        [JsonProperty("_contextType")]
        public Element _ContextType { get; set; }
        /// <summary>
        /// Field to create in the context.
        /// </summary>
        [JsonProperty("element")]
        public string Element { get; set; }
        [JsonProperty("_element")]
        public Element _Element { get; set; }
        /// <summary>
        /// If field is a list, how to manage the list.
        /// </summary>
        [JsonProperty("listMode")]
        public string[] ListMode { get; set; }
        [JsonProperty("_listMode")]
        public Element[] _ListMode { get; set; }
        /// <summary>
        /// Internal rule reference for shared list items.
        /// </summary>
        [JsonProperty("listRuleId")]
        public string ListRuleId { get; set; }
        [JsonProperty("_listRuleId")]
        public Element _ListRuleId { get; set; }
        /// <summary>
        /// Parameters to the transform.
        /// </summary>
        [JsonProperty("parameter")]
        public StructureMapGroupRuleTargetParameter[] Parameter { get; set; }
        /// <summary>
        /// How the data is copied / created.
        /// </summary>
        [JsonProperty("transform")]
        public string Transform { get; set; }
        [JsonProperty("_transform")]
        public Element _Transform { get; set; }
        /// <summary>
        /// Named context for field, if desired, and a field is specified.
        /// </summary>
        [JsonProperty("variable")]
        public string Variable { get; set; }
        [JsonProperty("_variable")]
        public Element _Variable { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureMap.group.rule.target.contextType field
    /// </summary>
    public static class StructureMapGroupRuleTargetContextTypeCodes
    {
        public const string TYPE = "type";
        public const string VARIABLE = "variable";
    }
    /// <summary>
    /// Code Values for the StructureMap.group.rule.target.listMode field
    /// </summary>
    public static class StructureMapGroupRuleTargetListModeCodes
    {
        public const string FIRST = "first";
        public const string SHARE = "share";
        public const string LAST = "last";
        public const string COLLATE = "collate";
    }
    /// <summary>
    /// Code Values for the StructureMap.group.rule.target.transform field
    /// </summary>
    public static class StructureMapGroupRuleTargetTransformCodes
    {
        public const string CREATE = "create";
        public const string COPY = "copy";
    }
    /// <summary>
    /// Which other rules to apply in the context of this rule.
    /// </summary>
    public class StructureMapGroupRuleDependent : BackboneElement
    {
        /// <summary>
        /// Name of a rule or group to apply.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Variable to pass to the rule or group.
        /// </summary>
        [JsonProperty("variable")]
        public string[] Variable { get; set; }
        [JsonProperty("_variable")]
        public Element[] _Variable { get; set; }
    }
    /// <summary>
    /// Transform Rule from source to target.
    /// </summary>
    public class StructureMapGroupRule : BackboneElement
    {
        /// <summary>
        /// Which other rules to apply in the context of this rule.
        /// </summary>
        [JsonProperty("dependent")]
        public StructureMapGroupRuleDependent[] Dependent { get; set; }
        /// <summary>
        /// Documentation for this instance of data.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// Name of the rule for internal references.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Rules contained in this rule.
        /// </summary>
        [JsonProperty("rule")]
        public StructureMapGroupRule[] Rule { get; set; }
        /// <summary>
        /// Source inputs to the mapping.
        /// </summary>
        [JsonProperty("source")]
        public StructureMapGroupRuleSource[] Source { get; set; }
        /// <summary>
        /// Content to create because of this mapping rule.
        /// </summary>
        [JsonProperty("target")]
        public StructureMapGroupRuleTarget[] Target { get; set; }
    }
    /// <summary>
    /// Organizes the mapping into managable chunks for human review/ease of maintenance.
    /// </summary>
    public class StructureMapGroup : BackboneElement
    {
        /// <summary>
        /// Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
        /// </summary>
        [JsonProperty("documentation")]
        public string Documentation { get; set; }
        [JsonProperty("_documentation")]
        public Element _Documentation { get; set; }
        /// <summary>
        /// Another group that this group adds rules to.
        /// </summary>
        [JsonProperty("extends")]
        public string Extends { get; set; }
        [JsonProperty("_extends")]
        public Element _Extends { get; set; }
        /// <summary>
        /// If no inputs are named, then the entry mappings are type based.
        /// </summary>
        [JsonProperty("input")]
        public StructureMapGroupInput[] Input { get; set; }
        /// <summary>
        /// A unique name for the group for the convenience of human readers.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Transform Rule from source to target.
        /// </summary>
        [JsonProperty("rule")]
        public StructureMapGroupRule[] Rule { get; set; }
        /// <summary>
        /// Not applicable if the underlying model is untyped. There can only be one default mapping for any particular type combination.
        /// </summary>
        [JsonProperty("typeMode")]
        public string TypeMode { get; set; }
        [JsonProperty("_typeMode")]
        public Element _TypeMode { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureMap.group.typeMode field
    /// </summary>
    public static class StructureMapGroupTypeModeCodes
    {
        public const string NONE = "none";
        public const string TYPES = "types";
        public const string TYPE_AND_TYPES = "type-and-types";
    }
    /// <summary>
    /// A Map of relationships between 2 structures that can be used to transform data.
    /// </summary>
    public class StructureMap : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "StructureMap";
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the structure map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the structure map was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the structure map as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created).
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Allows filtering of structure map that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental structure map in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Organizes the mapping into managable chunks for human review/ease of maintenance.
        /// </summary>
        [JsonProperty("group")]
        public StructureMapGroup[] Group { get; set; }
        /// <summary>
        /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this structure map outside of FHIR, where it is not possible to use the logical URI.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier[] Identifier { get; set; }
        /// <summary>
        /// Other maps used by this map (canonical URLs).
        /// </summary>
        [JsonProperty("import")]
        public string[] Import { get; set; }
        [JsonProperty("_import")]
        public Element[] _Import { get; set; }
        /// <summary>
        /// It may be possible for the structure map to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the structure map is the organization or individual primarily responsible for the maintenance and upkeep of the structure map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the structure map. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the structure map Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this structure map.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Allows filtering of structure maps that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired structure map without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// It is not necessary for a structure map to identify any dependent structures, though not losting them may restrict its usefulness.
        /// </summary>
        [JsonProperty("structure")]
        public StructureMapStructure[] Structure { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different structure map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the structure map with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the StructureMap.status field
    /// </summary>
    public static class StructureMapStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    /// <summary>
    /// Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
    /// </summary>
    public class ValueSetComposeIncludeConceptDesignation : BackboneElement
    {
        /// <summary>
        /// In the absence of a language, the resource language applies.
        /// </summary>
        [JsonProperty("language")]
        public string Language { get; set; }
        [JsonProperty("_language")]
        public Element _Language { get; set; }
        /// <summary>
        /// If no use is provided, the designation can be assumed to be suitable for general display to a human user.
        /// </summary>
        [JsonProperty("use")]
        public Coding Use { get; set; }
        /// <summary>
        /// The text value for this designation.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// The list of concepts is considered ordered, though the order may not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
    /// </summary>
    public class ValueSetComposeIncludeConcept : BackboneElement
    {
        /// <summary>
        /// Expressions are allowed if defined by the underlying code system.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
        /// </summary>
        [JsonProperty("designation")]
        public ValueSetComposeIncludeConceptDesignation[] Designation { get; set; }
        /// <summary>
        /// The value set resource allows for an alternative display to be specified for when this concept is used in this particular value set. See notes in the value set narrative about the correct use of this element.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
    }
    /// <summary>
    /// Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
    /// </summary>
    public class ValueSetComposeIncludeFilter : BackboneElement
    {
        /// <summary>
        /// The kind of operation to perform as a part of the filter criteria.
        /// </summary>
        [JsonProperty("op")]
        public string Op { get; set; }
        [JsonProperty("_op")]
        public Element _Op { get; set; }
        /// <summary>
        /// A code that identifies a property defined in the code system.
        /// </summary>
        [JsonProperty("property")]
        public string Property { get; set; }
        [JsonProperty("_property")]
        public Element _Property { get; set; }
        /// <summary>
        /// Use regex matching with care - full regex matching on every SNOMED CT term is prohibitive, for example.
        /// </summary>
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("_value")]
        public Element _Value { get; set; }
    }
    /// <summary>
    /// Code Values for the ValueSet.compose.include.filter.op field
    /// </summary>
    public static class ValueSetComposeIncludeFilterOpCodes
    {
        public const string EQUALS = "=";
        public const string IS_A = "is-a";
        public const string DESCENDENT_OF = "descendent-of";
        public const string IS_NOT_A = "is-not-a";
        public const string REGEX = "regex";
        public const string VAL_IN = "in";
        public const string NOT_IN = "not-in";
        public const string GENERALIZES = "generalizes";
        public const string EXISTS = "exists";
    }
    /// <summary>
    /// All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
    /// </summary>
    public class ValueSetComposeInclude : BackboneElement
    {
        /// <summary>
        /// The list of concepts is considered ordered, though the order may not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
        /// </summary>
        [JsonProperty("concept")]
        public ValueSetComposeIncludeConcept[] Concept { get; set; }
        /// <summary>
        /// Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
        /// </summary>
        [JsonProperty("filter")]
        public ValueSetComposeIncludeFilter[] Filter { get; set; }
        /// <summary>
        /// If there are no codes or filters, the entire code system is included. Note that the set of codes that are included may contain abstract codes. See ''Coding.system'' for further documentation about the correct value for the system element.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// The value set URI is either a logical reference to a defined value set such as a [SNOMED CT reference set]{snomedct.html#implicit}, or a direct reference to a value set definition using ValueSet.url. The reference may not refer to an actual FHIR ValueSet resource; in this case, whatever is referred to is an implicit definition of a value set that needs to be clear about how versions are resolved.
        /// </summary>
        [JsonProperty("valueSet")]
        public string[] ValueSet { get; set; }
        [JsonProperty("_valueSet")]
        public Element[] _ValueSet { get; set; }
        /// <summary>
        /// This is used when selecting the descendants of a concept - they may change between versions. If no version is specified, then the exact contents of the value set may not be known until a context of use binds it to a particular version.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// A set of criteria that define the content logical definition of the value set by including or excluding codes from outside this value set. This I also known as the "Content Logical Definition" (CLD).
    /// </summary>
    public class ValueSetCompose : BackboneElement
    {
        /// <summary>
        /// Usually this is used to selectively exclude codes that were included by subsumption in the inclusions. Any display names specified for the codes are ignored.
        /// </summary>
        [JsonProperty("exclude")]
        public ValueSetComposeInclude[] Exclude { get; set; }
        /// <summary>
        /// Note that in the FHIR terminology framework, "deprecated" does not mean inactive, but in some code systems (e.g. LOINC, deprecated means inactive). Code systems should define what codes are considered to be inactive. If this is not clearly defined (including in the FHIR code system resource), then all codes are assumed to be active.
        /// </summary>
        [JsonProperty("inactive")]
        public bool? Inactive { get; set; }
        /// <summary>
        /// All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
        /// </summary>
        [JsonProperty("include")]
        public ValueSetComposeInclude[] Include { get; set; }
        /// <summary>
        /// With a defined lockedDate the value set is considered "Locked". Otherwise, the value set may have different expansions as underlying code systems and/or value sets evolve.  The interpretation of lockedDate is often dependent on the context - e.g. a SNOMED CT derived value set with a lockedDate will have a different expansion in USA than in UK.  If a value set specifies a version for include and exclude statements, and also specifies a locked date, the specified versions need to be available that date, or the value set will not be usable.
        /// </summary>
        [JsonProperty("lockedDate")]
        public string LockedDate { get; set; }
        [JsonProperty("_lockedDate")]
        public Element _LockedDate { get; set; }
    }
    /// <summary>
    /// The server decides which parameters to include here, but at a minimum, the list SHOULD include the date, filter, and profile parameters passed to the $expand operation (if any).
    /// </summary>
    public class ValueSetExpansionParameter : BackboneElement
    {
        /// <summary>
        /// The names are assigned at the discretion of the server.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueString")]
        public string ValueString { get; set; }
        [JsonProperty("_valueString")]
        public Element _ValueString { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueBoolean")]
        public bool? ValueBoolean { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueInteger")]
        public int? ValueInteger { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueDecimal")]
        public decimal? ValueDecimal { get; set; }
        [JsonProperty("_valueDecimal")]
        public Element _ValueDecimal { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueUri")]
        public string ValueUri { get; set; }
        [JsonProperty("_valueUri")]
        public Element _ValueUri { get; set; }
        /// <summary>
        /// The value of the parameter.
        /// </summary>
        [JsonProperty("valueCode")]
        public string ValueCode { get; set; }
        [JsonProperty("_valueCode")]
        public Element _ValueCode { get; set; }
    }
    /// <summary>
    /// The codes that are contained in the value set expansion.
    /// </summary>
    public class ValueSetExpansionContains : BackboneElement
    {
        /// <summary>
        /// This should not be understood to exclude its use for searching (e.g. by subsumption testing). The client should know whether it is appropriate for the user to select an abstract code or not.
        /// </summary>
        [JsonProperty("abstract")]
        public bool? Abstract { get; set; }
        /// <summary>
        /// The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
        /// </summary>
        [JsonProperty("code")]
        public string Code { get; set; }
        [JsonProperty("_code")]
        public Element _Code { get; set; }
        /// <summary>
        /// If the expansion uses this element, there is  no implication about the logical relationship between them, and the  structure cannot be used for logical inferencing. The structure  exists to provide navigational assistance for helping human users to  locate codes in the expansion.
        /// </summary>
        [JsonProperty("contains")]
        public ValueSetExpansionContains[] Contains { get; set; }
        /// <summary>
        /// The designations provided must be based on the value set and code system definitions.
        /// </summary>
        [JsonProperty("designation")]
        public ValueSetComposeIncludeConceptDesignation[] Designation { get; set; }
        /// <summary>
        /// The recommended display for this item in the expansion.
        /// </summary>
        [JsonProperty("display")]
        public string Display { get; set; }
        [JsonProperty("_display")]
        public Element _Display { get; set; }
        /// <summary>
        /// This should only have a value if the concept is inactive.
        /// </summary>
        [JsonProperty("inactive")]
        public bool? Inactive { get; set; }
        /// <summary>
        /// An absolute URI which is the code system in which the code for this item in the expansion is defined.
        /// </summary>
        [JsonProperty("system")]
        public string System { get; set; }
        [JsonProperty("_system")]
        public Element _System { get; set; }
        /// <summary>
        /// The exact value of the version string is specified by the system from which the code is derived.
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Expansion is performed to produce a collection of codes that are ready to use for data entry or validation.
    /// </summary>
    public class ValueSetExpansion : BackboneElement
    {
        /// <summary>
        /// The codes that are contained in the value set expansion.
        /// </summary>
        [JsonProperty("contains")]
        public ValueSetExpansionContains[] Contains { get; set; }
        /// <summary>
        /// Typically, this uri is a UUID (e.g. urn:uuid:8230ff20-c97a-4167-a59d-dc2cb9df16dd).
        /// </summary>
        [JsonProperty("identifier")]
        public string Identifier { get; set; }
        [JsonProperty("_identifier")]
        public Element _Identifier { get; set; }
        /// <summary>
        /// Paging only applies to flat expansions. If a filter is applied, the count is the number of concepts that matched the filter, not the number of concepts in an unfiltered view of the expansion.
        /// </summary>
        [JsonProperty("offset")]
        public int? Offset { get; set; }
        /// <summary>
        /// The server decides which parameters to include here, but at a minimum, the list SHOULD include the date, filter, and profile parameters passed to the $expand operation (if any).
        /// </summary>
        [JsonProperty("parameter")]
        public ValueSetExpansionParameter[] Parameter { get; set; }
        /// <summary>
        /// This SHOULD be a fully populated instant, but in some circumstances, value sets are expanded by hand, and the expansion is published without that precision.
        /// </summary>
        [JsonProperty("timestamp")]
        public string Timestamp { get; set; }
        [JsonProperty("_timestamp")]
        public Element _Timestamp { get; set; }
        /// <summary>
        /// Paging only applies to flat expansions.
        /// </summary>
        [JsonProperty("total")]
        public int? Total { get; set; }
    }
    /// <summary>
    /// A value set specifies a set of codes drawn from one or more code systems.
    /// </summary>
    public class ValueSet : DomainResource
    {
        /** Resource Type Name (for serialization) */
        [JsonProperty("resourceType")]
        public string ResourceType => "ValueSet";
        /// <summary>
        /// A set of criteria that define the content logical definition of the value set by including or excluding codes from outside this value set. This I also known as the "Content Logical Definition" (CLD).
        /// </summary>
        [JsonProperty("compose")]
        public ValueSetCompose Compose { get; set; }
        /// <summary>
        /// May be a web site, an email address, a telephone number, etc.
        /// </summary>
        [JsonProperty("contact")]
        public ContactDetail[] Contact { get; set; }
        /// <summary>
        /// null Frequently, the copyright differs between the value set and the codes that are included. The copyright statement should clearly differentiate between these when required.
        /// </summary>
        [JsonProperty("copyright")]
        public string Copyright { get; set; }
        [JsonProperty("_copyright")]
        public Element _Copyright { get; set; }
        /// <summary>
        /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the value set. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }
        [JsonProperty("_date")]
        public Element _Date { get; set; }
        /// <summary>
        /// This description can be used to capture details such as why the value set was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the value set as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the profile is presumed to be the predominant language in the place the profile was created). The description is not intended to describe the semantics of the Value Set - there are no intrinsic semantics separate from the codes contained in its expansion. The description should capture its intended use, which is needed for ensuring integrity for its use in models across future changes. A description should be provided unless the value set is a contained resource (e.g. an anonymous value set in a profile). Most registries will require a description.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }
        [JsonProperty("_description")]
        public Element _Description { get; set; }
        /// <summary>
        /// Expansion is performed to produce a collection of codes that are ready to use for data entry or validation.
        /// </summary>
        [JsonProperty("expansion")]
        public ValueSetExpansion Expansion { get; set; }
        /// <summary>
        /// Allows filtering of value set that are appropriate for use vs. not. This is labeled as "Is Modifier" because applications should not use an experimental value set in production.
        /// </summary>
        [JsonProperty("experimental")]
        public bool? Experimental { get; set; }
        /// <summary>
        /// Whether this is intended to be used with an extensible binding or not.
        /// </summary>
        [JsonProperty("extensible")]
        public bool? Extensible { get; set; }
        /// <summary>
        /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, e.g., to identify this value set outside of FHIR, where it is not possible to use the logical URI.
        /// </summary>
        [JsonProperty("identifier")]
        public Identifier[] Identifier { get; set; }
        /// <summary>
        /// Normally immutability is set to 'false', which is the default assumption if it is not populated.  Note that the implication is that if this is set to 'true', there may be only one ValueSet version for this definition. Immutability tends to be set to 'true' in one of two cases: - Where the value set, by the nature of its usage, cannot change.  For example "All specializations of ACT in ActClassCode" - Where there's no safe way to express the "Purpose" such that someone else could safely make changes to the value set definition. Source workflow control must guarantee that the same URI always yields the same definition.
        /// </summary>
        [JsonProperty("immutable")]
        public bool? Immutable { get; set; }
        /// <summary>
        /// It may be possible for the value set to be used in jurisdictions other than those for which it was originally designed or intended.
        /// </summary>
        [JsonProperty("jurisdiction")]
        public CodeableConcept[] Jurisdiction { get; set; }
        /// <summary>
        /// The name is not expected to be globally unique. The name should be a simple alpha-numeric type name to ensure that it is computable friendly. A name should be provided unless the value set is a contained resource (e.g. an anonymous value set in a profile). Most registries will require a name.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("_name")]
        public Element _Name { get; set; }
        /// <summary>
        /// Usually an organization, but may be an individual. The publisher (or steward) of the value set is the organization or individual primarily responsible for the maintenance and upkeep of the value set. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the value set. This item SHOULD be populated unless the information is available from context.
        /// </summary>
        [JsonProperty("publisher")]
        public string Publisher { get; set; }
        [JsonProperty("_publisher")]
        public Element _Publisher { get; set; }
        /// <summary>
        /// This element does not describe the usage of the value set Instead  it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this value set.
        /// </summary>
        [JsonProperty("purpose")]
        public string Purpose { get; set; }
        [JsonProperty("_purpose")]
        public Element _Purpose { get; set; }
        /// <summary>
        /// Allows filtering of value sets that are appropriate for use vs. not.  
        /// This is labeled as "Is Modifier" because applications should not use a retired value set without due consideration.
        /// </summary>
        [JsonProperty("status")]
        public string Status { get; set; }
        [JsonProperty("_status")]
        public Element _Status { get; set; }
        /// <summary>
        /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }
        [JsonProperty("_title")]
        public Element _Title { get; set; }
        /// <summary>
        /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred.  Multiple instances may share the same url if they have a distinct version.
        /// </summary>
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("_url")]
        public Element _Url { get; set; }
        /// <summary>
        /// When multiple useContexts are specified, there is no expectation whether all or any of the contexts apply.
        /// </summary>
        [JsonProperty("useContext")]
        public UsageContext[] UseContext { get; set; }
        /// <summary>
        /// There may be different value set instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a refrence to a particular business version of the value set with the format [url]|[version].
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
        [JsonProperty("_version")]
        public Element _Version { get; set; }
    }
    /// <summary>
    /// Code Values for the ValueSet.status field
    /// </summary>
    public static class ValueSetStatusCodes
    {
        public const string DRAFT = "draft";
        public const string ACTIVE = "active";
        public const string RETIRED = "retired";
        public const string UNKNOWN = "unknown";
    }
    public class ResourceConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return typeof(Resource).IsAssignableFrom(objectType);
        }
        public override bool CanWrite
        {
            get { return false; }
        }
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            throw new NotImplementedException();
        }
        public override bool CanRead
        {
            get { return true; }
        }
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            JObject jObject = JObject.Load(reader);
            string resourceType = jObject["resourceType"].Value<string>();
            object target = null;
            switch (resourceType)
            {
                case "CapabilityStatement":
                    target = new CapabilityStatement();
                    break;
                case "CodeSystem":
                    target = new CodeSystem();
                    break;
                case "CompartmentDefinition":
                    target = new CompartmentDefinition();
                    break;
                case "ConceptMap":
                    target = new ConceptMap();
                    break;
                case "NamingSystem":
                    target = new NamingSystem();
                    break;
                case "OperationDefinition":
                    target = new OperationDefinition();
                    break;
                case "SearchParameter":
                    target = new SearchParameter();
                    break;
                case "StructureDefinition":
                    target = new StructureDefinition();
                    break;
                case "StructureMap":
                    target = new StructureMap();
                    break;
                case "ValueSet":
                    target = new ValueSet();
                    break;
                default:
                    target = new Resource();
                    break;
            }
            serializer.Populate(jObject.CreateReader(), target);
            return target;
        }
    }
}
/// end of file
