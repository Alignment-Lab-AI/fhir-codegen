// <auto-generated />
// Built from: hl7.fhir.r4.core version: 4.0.1

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using Fhir.R4.ValueSets;
using Fhir.R4.Serialization;

namespace Fhir.R4.Models
{
  /// <summary>
  /// Optional Extension Element - found in all resources.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<Extension>))]
  public class Extension : Element,  IFhirJsonSerializable {
    /// <summary>
    /// The definition may point directly to a computable or human-readable definition of the extensibility codes, or it may be a logical URI as declared in some other specification. The definition SHALL be a URI for the Structure Definition defining the extension.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueBase64Binary { get; set; }
    /// <summary>
    /// Extension container element for ValueBase64Binary
    /// </summary>
    public Element _ValueBase64Binary { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public bool? ValueBoolean { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueCanonical { get; set; }
    /// <summary>
    /// Extension container element for ValueCanonical
    /// </summary>
    public Element _ValueCanonical { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueCode { get; set; }
    /// <summary>
    /// Extension container element for ValueCode
    /// </summary>
    public Element _ValueCode { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueDate { get; set; }
    /// <summary>
    /// Extension container element for ValueDate
    /// </summary>
    public Element _ValueDate { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for ValueDateTime
    /// </summary>
    public Element _ValueDateTime { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public decimal? ValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for ValueDecimal
    /// </summary>
    public Element _ValueDecimal { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueId { get; set; }
    /// <summary>
    /// Extension container element for ValueId
    /// </summary>
    public Element _ValueId { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueInstant { get; set; }
    /// <summary>
    /// Extension container element for ValueInstant
    /// </summary>
    public Element _ValueInstant { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public int? ValueInteger { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueMarkdown { get; set; }
    /// <summary>
    /// Extension container element for ValueMarkdown
    /// </summary>
    public Element _ValueMarkdown { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueOid { get; set; }
    /// <summary>
    /// Extension container element for ValueOid
    /// </summary>
    public Element _ValueOid { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public uint? ValuePositiveInt { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueString { get; set; }
    /// <summary>
    /// Extension container element for ValueString
    /// </summary>
    public Element _ValueString { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueTime { get; set; }
    /// <summary>
    /// Extension container element for ValueTime
    /// </summary>
    public Element _ValueTime { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public uint? ValueUnsignedInt { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueUri { get; set; }
    /// <summary>
    /// Extension container element for ValueUri
    /// </summary>
    public Element _ValueUri { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public string ValueUrl { get; set; }
    /// <summary>
    /// Extension container element for ValueUrl
    /// </summary>
    public Element _ValueUrl { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Guid? ValueUuid { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Address ValueAddress { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Age ValueAge { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Annotation ValueAnnotation { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Attachment ValueAttachment { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Coding ValueCoding { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public ContactPoint ValueContactPoint { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Count ValueCount { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Distance ValueDistance { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Duration ValueDuration { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public HumanName ValueHumanName { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Identifier ValueIdentifier { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Money ValueMoney { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Period ValuePeriod { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Ratio ValueRatio { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Reference ValueReference { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public SampledData ValueSampledData { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Signature ValueSignature { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Timing ValueTiming { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public ContactDetail ValueContactDetail { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Contributor ValueContributor { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public DataRequirement ValueDataRequirement { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Expression ValueExpression { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public ParameterDefinition ValueParameterDefinition { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public RelatedArtifact ValueRelatedArtifact { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public TriggerDefinition ValueTriggerDefinition { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public UsageContext ValueUsageContext { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Dosage ValueDosage { get; set; }
    /// <summary>
    /// Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    /// </summary>
    public Meta ValueMeta { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new Fhir.R4.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "valueBase64Binary":
          ValueBase64Binary = reader.GetString();
          break;

        case "_valueBase64Binary":
          _ValueBase64Binary = new Fhir.R4.Models.Element();
          _ValueBase64Binary.DeserializeJson(ref reader, options);
          break;

        case "valueBoolean":
          ValueBoolean = reader.GetBoolean();
          break;

        case "valueCanonical":
          ValueCanonical = reader.GetString();
          break;

        case "_valueCanonical":
          _ValueCanonical = new Fhir.R4.Models.Element();
          _ValueCanonical.DeserializeJson(ref reader, options);
          break;

        case "valueCode":
          ValueCode = reader.GetString();
          break;

        case "_valueCode":
          _ValueCode = new Fhir.R4.Models.Element();
          _ValueCode.DeserializeJson(ref reader, options);
          break;

        case "valueDate":
          ValueDate = reader.GetString();
          break;

        case "_valueDate":
          _ValueDate = new Fhir.R4.Models.Element();
          _ValueDate.DeserializeJson(ref reader, options);
          break;

        case "valueDateTime":
          ValueDateTime = reader.GetString();
          break;

        case "_valueDateTime":
          _ValueDateTime = new Fhir.R4.Models.Element();
          _ValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "valueDecimal":
          ValueDecimal = reader.GetDecimal();
          break;

        case "_valueDecimal":
          _ValueDecimal = new Fhir.R4.Models.Element();
          _ValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "valueId":
          ValueId = reader.GetString();
          break;

        case "_valueId":
          _ValueId = new Fhir.R4.Models.Element();
          _ValueId.DeserializeJson(ref reader, options);
          break;

        case "valueInstant":
          ValueInstant = reader.GetString();
          break;

        case "_valueInstant":
          _ValueInstant = new Fhir.R4.Models.Element();
          _ValueInstant.DeserializeJson(ref reader, options);
          break;

        case "valueInteger":
          ValueInteger = reader.GetInt32();
          break;

        case "valueMarkdown":
          ValueMarkdown = reader.GetString();
          break;

        case "_valueMarkdown":
          _ValueMarkdown = new Fhir.R4.Models.Element();
          _ValueMarkdown.DeserializeJson(ref reader, options);
          break;

        case "valueOid":
          ValueOid = reader.GetString();
          break;

        case "_valueOid":
          _ValueOid = new Fhir.R4.Models.Element();
          _ValueOid.DeserializeJson(ref reader, options);
          break;

        case "valuePositiveInt":
          ValuePositiveInt = reader.GetUInt32();
          break;

        case "valueString":
          ValueString = reader.GetString();
          break;

        case "_valueString":
          _ValueString = new Fhir.R4.Models.Element();
          _ValueString.DeserializeJson(ref reader, options);
          break;

        case "valueTime":
          ValueTime = reader.GetString();
          break;

        case "_valueTime":
          _ValueTime = new Fhir.R4.Models.Element();
          _ValueTime.DeserializeJson(ref reader, options);
          break;

        case "valueUnsignedInt":
          ValueUnsignedInt = reader.GetUInt32();
          break;

        case "valueUri":
          ValueUri = reader.GetString();
          break;

        case "_valueUri":
          _ValueUri = new Fhir.R4.Models.Element();
          _ValueUri.DeserializeJson(ref reader, options);
          break;

        case "valueUrl":
          ValueUrl = reader.GetString();
          break;

        case "_valueUrl":
          _ValueUrl = new Fhir.R4.Models.Element();
          _ValueUrl.DeserializeJson(ref reader, options);
          break;

        case "valueUuid":
          ValueUuid = reader.GetGuid();
          break;

        case "valueAddress":
          ValueAddress = new Fhir.R4.Models.Address();
          ValueAddress.DeserializeJson(ref reader, options);
          break;

        case "valueAge":
          ValueAge = new Fhir.R4.Models.Age();
          ValueAge.DeserializeJson(ref reader, options);
          break;

        case "valueAnnotation":
          ValueAnnotation = new Fhir.R4.Models.Annotation();
          ValueAnnotation.DeserializeJson(ref reader, options);
          break;

        case "valueAttachment":
          ValueAttachment = new Fhir.R4.Models.Attachment();
          ValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new Fhir.R4.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueCoding":
          ValueCoding = new Fhir.R4.Models.Coding();
          ValueCoding.DeserializeJson(ref reader, options);
          break;

        case "valueContactPoint":
          ValueContactPoint = new Fhir.R4.Models.ContactPoint();
          ValueContactPoint.DeserializeJson(ref reader, options);
          break;

        case "valueCount":
          ValueCount = new Fhir.R4.Models.Count();
          ValueCount.DeserializeJson(ref reader, options);
          break;

        case "valueDistance":
          ValueDistance = new Fhir.R4.Models.Distance();
          ValueDistance.DeserializeJson(ref reader, options);
          break;

        case "valueDuration":
          ValueDuration = new Fhir.R4.Models.Duration();
          ValueDuration.DeserializeJson(ref reader, options);
          break;

        case "valueHumanName":
          ValueHumanName = new Fhir.R4.Models.HumanName();
          ValueHumanName.DeserializeJson(ref reader, options);
          break;

        case "valueIdentifier":
          ValueIdentifier = new Fhir.R4.Models.Identifier();
          ValueIdentifier.DeserializeJson(ref reader, options);
          break;

        case "valueMoney":
          ValueMoney = new Fhir.R4.Models.Money();
          ValueMoney.DeserializeJson(ref reader, options);
          break;

        case "valuePeriod":
          ValuePeriod = new Fhir.R4.Models.Period();
          ValuePeriod.DeserializeJson(ref reader, options);
          break;

        case "valueQuantity":
          ValueQuantity = new Fhir.R4.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new Fhir.R4.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        case "valueRatio":
          ValueRatio = new Fhir.R4.Models.Ratio();
          ValueRatio.DeserializeJson(ref reader, options);
          break;

        case "valueReference":
          ValueReference = new Fhir.R4.Models.Reference();
          ValueReference.DeserializeJson(ref reader, options);
          break;

        case "valueSampledData":
          ValueSampledData = new Fhir.R4.Models.SampledData();
          ValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "valueSignature":
          ValueSignature = new Fhir.R4.Models.Signature();
          ValueSignature.DeserializeJson(ref reader, options);
          break;

        case "valueTiming":
          ValueTiming = new Fhir.R4.Models.Timing();
          ValueTiming.DeserializeJson(ref reader, options);
          break;

        case "valueContactDetail":
          ValueContactDetail = new Fhir.R4.Models.ContactDetail();
          ValueContactDetail.DeserializeJson(ref reader, options);
          break;

        case "valueContributor":
          ValueContributor = new Fhir.R4.Models.Contributor();
          ValueContributor.DeserializeJson(ref reader, options);
          break;

        case "valueDataRequirement":
          ValueDataRequirement = new Fhir.R4.Models.DataRequirement();
          ValueDataRequirement.DeserializeJson(ref reader, options);
          break;

        case "valueExpression":
          ValueExpression = new Fhir.R4.Models.Expression();
          ValueExpression.DeserializeJson(ref reader, options);
          break;

        case "valueParameterDefinition":
          ValueParameterDefinition = new Fhir.R4.Models.ParameterDefinition();
          ValueParameterDefinition.DeserializeJson(ref reader, options);
          break;

        case "valueRelatedArtifact":
          ValueRelatedArtifact = new Fhir.R4.Models.RelatedArtifact();
          ValueRelatedArtifact.DeserializeJson(ref reader, options);
          break;

        case "valueTriggerDefinition":
          ValueTriggerDefinition = new Fhir.R4.Models.TriggerDefinition();
          ValueTriggerDefinition.DeserializeJson(ref reader, options);
          break;

        case "valueUsageContext":
          ValueUsageContext = new Fhir.R4.Models.UsageContext();
          ValueUsageContext.DeserializeJson(ref reader, options);
          break;

        case "valueDosage":
          ValueDosage = new Fhir.R4.Models.Dosage();
          ValueDosage.DeserializeJson(ref reader, options);
          break;

        case "valueMeta":
          ValueMeta = new Fhir.R4.Models.Meta();
          ValueMeta.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
}
