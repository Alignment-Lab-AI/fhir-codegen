// <auto-generated />
// Built from: hl7.fhir.r4.core version: 4.0.1

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using Fhir.R4.ValueSets;
using Fhir.R4.Serialization;

namespace Fhir.R4.Models
{
  /// <summary>
  /// Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesSoftware>))]
  public class TerminologyCapabilitiesSoftware : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Name the software is known by.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// If possible, a version should be specified, as statements are likely to be different for different versions of software.
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new Fhir.R4.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new Fhir.R4.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesImplementation>))]
  public class TerminologyCapabilitiesImplementation : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Information about the specific installation that this terminology capability statement relates to.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// An absolute base URL for the implementation.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new Fhir.R4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new Fhir.R4.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Filter Properties supported.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesCodeSystemVersionFilter>))]
  public class TerminologyCapabilitiesCodeSystemVersionFilter : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Code of the property supported.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// Operations supported for the property.
    /// </summary>
    public List<string> Op { get; set; }
    /// <summary>
    /// Extension container element for Op
    /// </summary>
    public List<Element> _Op { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new Fhir.R4.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "op":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Op = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Op.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Op.Count == 0)
          {
            Op = null;
          }

          break;

        case "_op":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Op = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Element obj_Op = new Fhir.R4.Models.Element();
            obj_Op.DeserializeJson(ref reader, options);
            _Op.Add(obj_Op);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Op.Count == 0)
          {
            _Op = null;
          }

          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Language translations might not be available for all codes.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesCodeSystemVersion>))]
  public class TerminologyCapabilitiesCodeSystemVersion : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// For version-less code systems, there should be a single version with no identifier.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// If the compositional grammar defined by the code system is supported.
    /// </summary>
    public bool? Compositional { get; set; }
    /// <summary>
    /// Filter Properties supported.
    /// </summary>
    public List<TerminologyCapabilitiesCodeSystemVersionFilter> Filter { get; set; }
    /// <summary>
    /// If this is the default version for this code system.
    /// </summary>
    public bool? IsDefault { get; set; }
    /// <summary>
    /// Language Displays supported.
    /// </summary>
    public List<string> Language { get; set; }
    /// <summary>
    /// Extension container element for Language
    /// </summary>
    public List<Element> _Language { get; set; }
    /// <summary>
    /// Properties supported for $lookup.
    /// </summary>
    public List<string> Property { get; set; }
    /// <summary>
    /// Extension container element for Property
    /// </summary>
    public List<Element> _Property { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new Fhir.R4.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "compositional":
          Compositional = reader.GetBoolean();
          break;

        case "filter":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Filter = new List<TerminologyCapabilitiesCodeSystemVersionFilter>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.TerminologyCapabilitiesCodeSystemVersionFilter objFilter = new Fhir.R4.Models.TerminologyCapabilitiesCodeSystemVersionFilter();
            objFilter.DeserializeJson(ref reader, options);
            Filter.Add(objFilter);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Filter.Count == 0)
          {
            Filter = null;
          }

          break;

        case "isDefault":
          IsDefault = reader.GetBoolean();
          break;

        case "language":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Language = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Language.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Language.Count == 0)
          {
            Language = null;
          }

          break;

        case "_language":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Language = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Element obj_Language = new Fhir.R4.Models.Element();
            obj_Language.DeserializeJson(ref reader, options);
            _Language.Add(obj_Language);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Language.Count == 0)
          {
            _Language = null;
          }

          break;

        case "property":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Property = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Property.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Property.Count == 0)
          {
            Property = null;
          }

          break;

        case "_property":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Property = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Element obj_Property = new Fhir.R4.Models.Element();
            obj_Property.DeserializeJson(ref reader, options);
            _Property.Add(obj_Property);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Property.Count == 0)
          {
            _Property = null;
          }

          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesCodeSystem>))]
  public class TerminologyCapabilitiesCodeSystem : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// True if subsumption is supported for this version of the code system.
    /// </summary>
    public bool? Subsumption { get; set; }
    /// <summary>
    /// URI for the Code System.
    /// </summary>
    public string Uri { get; set; }
    /// <summary>
    /// Extension container element for Uri
    /// </summary>
    public Element _Uri { get; set; }
    /// <summary>
    /// Language translations might not be available for all codes.
    /// </summary>
    public List<TerminologyCapabilitiesCodeSystemVersion> Version { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "subsumption":
          Subsumption = reader.GetBoolean();
          break;

        case "uri":
          Uri = reader.GetString();
          break;

        case "_uri":
          _Uri = new Fhir.R4.Models.Element();
          _Uri.DeserializeJson(ref reader, options);
          break;

        case "version":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Version = new List<TerminologyCapabilitiesCodeSystemVersion>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.TerminologyCapabilitiesCodeSystemVersion objVersion = new Fhir.R4.Models.TerminologyCapabilitiesCodeSystemVersion();
            objVersion.DeserializeJson(ref reader, options);
            Version.Add(objVersion);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Version.Count == 0)
          {
            Version = null;
          }

          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Supported expansion parameter.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesExpansionParameter>))]
  public class TerminologyCapabilitiesExpansionParameter : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Description of support for parameter.
    /// </summary>
    public string Documentation { get; set; }
    /// <summary>
    /// Extension container element for Documentation
    /// </summary>
    public Element _Documentation { get; set; }
    /// <summary>
    /// Expansion Parameter name.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "documentation":
          Documentation = reader.GetString();
          break;

        case "_documentation":
          _Documentation = new Fhir.R4.Models.Element();
          _Documentation.DeserializeJson(ref reader, options);
          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new Fhir.R4.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesExpansion>))]
  public class TerminologyCapabilitiesExpansion : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Whether the server can return nested value sets.
    /// </summary>
    public bool? Hierarchical { get; set; }
    /// <summary>
    /// Allow request for incomplete expansions?
    /// </summary>
    public bool? Incomplete { get; set; }
    /// <summary>
    /// Whether the server supports paging on expansion.
    /// </summary>
    public bool? Paging { get; set; }
    /// <summary>
    /// Supported expansion parameter.
    /// </summary>
    public List<TerminologyCapabilitiesExpansionParameter> Parameter { get; set; }
    /// <summary>
    /// This documentation should cover things like case sensitivity,  use of punctuation if not ignored, what wild cards are supported (if any), whether text is starts with or contains, and whether word order matters.
    /// </summary>
    public string TextFilter { get; set; }
    /// <summary>
    /// Extension container element for TextFilter
    /// </summary>
    public Element _TextFilter { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "hierarchical":
          Hierarchical = reader.GetBoolean();
          break;

        case "incomplete":
          Incomplete = reader.GetBoolean();
          break;

        case "paging":
          Paging = reader.GetBoolean();
          break;

        case "parameter":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Parameter = new List<TerminologyCapabilitiesExpansionParameter>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.TerminologyCapabilitiesExpansionParameter objParameter = new Fhir.R4.Models.TerminologyCapabilitiesExpansionParameter();
            objParameter.DeserializeJson(ref reader, options);
            Parameter.Add(objParameter);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Parameter.Count == 0)
          {
            Parameter = null;
          }

          break;

        case "textFilter":
          TextFilter = reader.GetString();
          break;

        case "_textFilter":
          _TextFilter = new Fhir.R4.Models.Element();
          _TextFilter.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesValidateCode>))]
  public class TerminologyCapabilitiesValidateCode : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Whether translations are validated.
    /// </summary>
    public bool Translations { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "translations":
          Translations = reader.GetBoolean();
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesTranslation>))]
  public class TerminologyCapabilitiesTranslation : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Whether the client must identify the map.
    /// </summary>
    public bool NeedsMap { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "needsMap":
          NeedsMap = reader.GetBoolean();
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Whether the $closure operation is supported.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<TerminologyCapabilitiesClosure>))]
  public class TerminologyCapabilitiesClosure : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// If cross-system closure is supported.
    /// </summary>
    public bool? Translation { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "translation":
          Translation = reader.GetBoolean();
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonResourceConverter))]
  public class TerminologyCapabilities : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public string ResourceType => "TerminologyCapabilities";
    /// <summary>
    /// Whether the $closure operation is supported.
    /// </summary>
    public TerminologyCapabilitiesClosure Closure { get; set; }
    /// <summary>
    /// See notes on the [ValueSet](valueset.html#) resource.
    /// </summary>
    public string CodeSearch { get; set; }
    /// <summary>
    /// Extension container element for CodeSearch
    /// </summary>
    public Element _CodeSearch { get; set; }
    /// <summary>
    /// The code system - identified by its system URL - may also be declared explicitly as a Code System Resource at /CodeSystem, but it might not be.
    /// </summary>
    public List<TerminologyCapabilitiesCodeSystem> CodeSystem { get; set; }
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// A copyright statement relating to the terminology capabilities and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the terminology capabilities.
    /// </summary>
    public string Copyright { get; set; }
    /// <summary>
    /// Extension container element for Copyright
    /// </summary>
    public Element _Copyright { get; set; }
    /// <summary>
    /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the terminology capabilities. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// This description can be used to capture details such as why the terminology capabilities was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the terminology capabilities as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the terminology capabilities is presumed to be the predominant language in the place the terminology capabilities was created).This does not need to be populated if the description is adequately implied by the software or implementation details.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
    /// </summary>
    public TerminologyCapabilitiesExpansion Expansion { get; set; }
    /// <summary>
    /// Allows filtering of terminology capabilitiess that are appropriate for use versus not.
    /// </summary>
    public bool? Experimental { get; set; }
    /// <summary>
    /// Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
    /// </summary>
    public TerminologyCapabilitiesImplementation Implementation { get; set; }
    /// <summary>
    /// It may be possible for the terminology capabilities to be used in jurisdictions other than those for which it was originally designed or intended.
    /// </summary>
    public List<CodeableConcept> Jurisdiction { get; set; }
    /// <summary>
    /// The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind, not instance of software) or a class of implementation (e.g. a desired purchase).
    /// </summary>
    public string Kind { get; set; }
    /// <summary>
    /// Extension container element for Kind
    /// </summary>
    public Element _Kind { get; set; }
    /// <summary>
    /// Whether the server supports lockedDate.
    /// </summary>
    public bool? LockedDate { get; set; }
    /// <summary>
    /// The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Usually an organization but may be an individual. The publisher (or steward) of the terminology capabilities is the organization or individual primarily responsible for the maintenance and upkeep of the terminology capabilities. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the terminology capabilities. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Publisher { get; set; }
    /// <summary>
    /// Extension container element for Publisher
    /// </summary>
    public Element _Publisher { get; set; }
    /// <summary>
    /// This element does not describe the usage of the terminology capabilities. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this terminology capabilities.
    /// </summary>
    public string Purpose { get; set; }
    /// <summary>
    /// Extension container element for Purpose
    /// </summary>
    public Element _Purpose { get; set; }
    /// <summary>
    /// Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
    /// </summary>
    public TerminologyCapabilitiesSoftware Software { get; set; }
    /// <summary>
    /// Allows filtering of terminology capabilitiess that are appropriate for use versus not.This is not intended for use with actual capability statements, but where capability statements are used to describe possible or desired systems.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
    /// </summary>
    public TerminologyCapabilitiesTranslation Translation { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
    /// The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
    /// In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
    /// </summary>
    public TerminologyCapabilitiesValidateCode ValidateCode { get; set; }
    /// <summary>
    /// There may be different terminology capabilities instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the terminology capabilities with the format [url]|[version].
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "closure":
          Closure = new Fhir.R4.Models.TerminologyCapabilitiesClosure();
          Closure.DeserializeJson(ref reader, options);
          break;

        case "codeSearch":
          CodeSearch = reader.GetString();
          break;

        case "_codeSearch":
          _CodeSearch = new Fhir.R4.Models.Element();
          _CodeSearch.DeserializeJson(ref reader, options);
          break;

        case "codeSystem":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          CodeSystem = new List<TerminologyCapabilitiesCodeSystem>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.TerminologyCapabilitiesCodeSystem objCodeSystem = new Fhir.R4.Models.TerminologyCapabilitiesCodeSystem();
            objCodeSystem.DeserializeJson(ref reader, options);
            CodeSystem.Add(objCodeSystem);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (CodeSystem.Count == 0)
          {
            CodeSystem = null;
          }

          break;

        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.ContactDetail objContact = new Fhir.R4.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "copyright":
          Copyright = reader.GetString();
          break;

        case "_copyright":
          _Copyright = new Fhir.R4.Models.Element();
          _Copyright.DeserializeJson(ref reader, options);
          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new Fhir.R4.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new Fhir.R4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "expansion":
          Expansion = new Fhir.R4.Models.TerminologyCapabilitiesExpansion();
          Expansion.DeserializeJson(ref reader, options);
          break;

        case "experimental":
          Experimental = reader.GetBoolean();
          break;

        case "implementation":
          Implementation = new Fhir.R4.Models.TerminologyCapabilitiesImplementation();
          Implementation.DeserializeJson(ref reader, options);
          break;

        case "jurisdiction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Jurisdiction = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.CodeableConcept objJurisdiction = new Fhir.R4.Models.CodeableConcept();
            objJurisdiction.DeserializeJson(ref reader, options);
            Jurisdiction.Add(objJurisdiction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Jurisdiction.Count == 0)
          {
            Jurisdiction = null;
          }

          break;

        case "kind":
          Kind = reader.GetString();
          break;

        case "_kind":
          _Kind = new Fhir.R4.Models.Element();
          _Kind.DeserializeJson(ref reader, options);
          break;

        case "lockedDate":
          LockedDate = reader.GetBoolean();
          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new Fhir.R4.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "publisher":
          Publisher = reader.GetString();
          break;

        case "_publisher":
          _Publisher = new Fhir.R4.Models.Element();
          _Publisher.DeserializeJson(ref reader, options);
          break;

        case "purpose":
          Purpose = reader.GetString();
          break;

        case "_purpose":
          _Purpose = new Fhir.R4.Models.Element();
          _Purpose.DeserializeJson(ref reader, options);
          break;

        case "software":
          Software = new Fhir.R4.Models.TerminologyCapabilitiesSoftware();
          Software.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new Fhir.R4.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new Fhir.R4.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "translation":
          Translation = new Fhir.R4.Models.TerminologyCapabilitiesTranslation();
          Translation.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new Fhir.R4.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.UsageContext objUseContext = new Fhir.R4.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        case "validateCode":
          ValidateCode = new Fhir.R4.Models.TerminologyCapabilitiesValidateCode();
          ValidateCode.DeserializeJson(ref reader, options);
          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new Fhir.R4.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
}
